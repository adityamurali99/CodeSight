{"commit_hash": "ad268bb80e91d2da7ade632ec10c7e5888277165", "issue_description": ":bug: Fix tests imports", "code_before": "from fastapi.applications import (\n    Body,\n    Cookie,\n    Depends,\n    FastAPI,\n    File,\n    Form,\n    Header,\n    Path,\n    Query,\n    Security,\n)\nfrom fastapi.security import HTTPBasic, OAuth2, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom starlette.responses import HTMLResponse, JSONResponse, PlainTextResponse\nfrom starlette.status import HTTP_202_ACCEPTED\nfrom starlette.testclient import TestClient\n\nfrom .endpoints.a import router as router_a\nfrom .endpoints.b import router as router_b\n\napp = FastAPI()\n\n\napp.include_router(router_a)\napp.include_router(router_b, prefix=\"/b\")\n\n\n@app.get(\"/text\")\ndef get_text():\n    return \"Hello World\"\n\n\n@app.get(\"/path/{item_id}\")\ndef get_id(item_id):\n    return item_id\n\n\n@app.get(\"/path/str/{item_id}\")\ndef get_str_id(item_id: str):\n    return item_id\n\n\n@app.get(\"/path/int/{item_id}\")\ndef get_int_id(item_id: int):\n    return item_id\n\n\n@app.get(\"/path/float/{item_id}\")\ndef get_float_id(item_id: float):\n    return item_id\n\n\n@app.get(\"/path/bool/{item_id}\")\ndef get_bool_id(item_id: bool):\n    return item_id\n\n\n@app.get(\"/path/param/{item_id}\")\ndef get_path_param_id(item_id: str = Path(None)):\n    return item_id\n\n\n@app.get(\"/path/param-required/{item_id}\")\ndef get_path_param_required_id(item_id: str = Path(...)):\n    return item_id\n\n\n@app.get(\"/path/param-minlength/{item_id}\")\ndef get_path_param_min_length(item_id: str = Path(..., min_length = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-maxlength/{item_id}\")\ndef get_path_param_max_length(item_id: str = Path(..., max_length = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-min_maxlength/{item_id}\")\ndef get_path_param_min_max_length(item_id: str = Path(..., max_length = 3, min_length = 2)):\n    return item_id\n\n\n@app.get(\"/path/param-gt/{item_id}\")\ndef get_path_param_gt(item_id: float = Path(..., gt = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-gt0/{item_id}\")\ndef get_path_param_gt0(item_id: float = Path(..., gt = 0)):\n    return item_id\n\n\n@app.get(\"/path/param-ge/{item_id}\")\ndef get_path_param_ge(item_id: float = Path(..., ge = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-lt/{item_id}\")\ndef get_path_param_lt(item_id: float = Path(..., lt = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-lt0/{item_id}\")\ndef get_path_param_lt0(item_id: float = Path(..., lt = 0)):\n    return item_id\n\n\n@app.get(\"/path/param-le/{item_id}\")\ndef get_path_param_le(item_id: float = Path(..., le = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-lt-gt/{item_id}\")\ndef get_path_param_lt_gt(item_id: float = Path(..., lt = 3, gt = 1)):\n    return item_id\n\n\n@app.get(\"/path/param-le-ge/{item_id}\")\ndef get_path_param_le_ge(item_id: float = Path(..., le = 3, ge = 1)):\n    return item_id\n\n\n@app.get(\"/path/param-lt-int/{item_id}\")\ndef get_path_param_lt_int(item_id: int = Path(..., lt = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-gt-int/{item_id}\")\ndef get_path_param_gt_int(item_id: int = Path(..., gt = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-le-int/{item_id}\")\ndef get_path_param_le_int(item_id: int = Path(..., le = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-ge-int/{item_id}\")\ndef get_path_param_ge_int(item_id: int = Path(..., ge = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-lt-gt-int/{item_id}\")\ndef get_path_param_lt_gt_int(item_id: int = Path(..., lt = 3, gt = 1)):\n    return item_id\n\n\n@app.get(\"/path/param-le-ge-int/{item_id}\")\ndef get_path_param_le_ge_int(item_id: int = Path(..., le = 3, ge = 1)):\n    return item_id\n\n\n@app.get(\"/query\")\ndef get_query(query):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/optional\")\ndef get_query_optional(query=None):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/int\")\ndef get_query_type(query: int):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/int/optional\")\ndef get_query_type_optional(query: int = None):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/param\")\ndef get_query_param(query=Query(None)):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/param-required\")\ndef get_query_param_required(query=Query(...)):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/param-required/int\")\ndef get_query_param_required_type(query: int = Query(...)):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/cookie\")\ndef get_cookie(coo=Cookie(None)):\n    return coo\n\n\n@app.get(\"/header\")\ndef get_header(head_name=Header(None)):\n    return head_name\n\n\n@app.get(\"/header_under\")\ndef get_header(head_name=Header(None, convert_underscores=False)):\n    return head_name\n\n\n@app.get(\"/param\")\ndef get_param(par=Param(None)):\n    return par\n\n\n@app.get(\"/security\")\ndef get_security(sec=Security(HTTPBasic())):\n    return sec\n\n\nreusable_oauth2 = OAuth2(\n    flows={\n        \"password\": {\n            \"tokenUrl\": \"/token\",\n            \"scopes\": {\"read:user\": \"Read a User\", \"write:user\": \"Create a user\"},\n        }\n    }\n)\n\n\n@app.get(\"/security/oauth2\")\ndef get_security_oauth2(sec=Security(reusable_oauth2, scopes=[\"read:user\"])):\n    return sec\n\n\n@app.post(\"/token\")\ndef post_token(request_data: OAuth2PasswordRequestForm = Form(...)):\n    print(request_data)\n    data = request_data.parse()\n    print(data)\n\n    print(request_data())\n    access_token = request_data.username + \":\" + request_data.password\n    return {\"access_token\": access_token}\n\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: bool\n\n\n@app.put(\"/items/{item_id}\")\ndef put_item(item_id: str, item: Item):\n    return item\n\n\n@app.post(\"/items/\")\ndef post_item(item: Item):\n    return item\n\n\n@app.post(\"/items-all-params/{item_id}\")\ndef post_items_all_params(\n    item_id: str = Path(...),\n    body: Item = Body(...),\n    query_a: int = Query(None),\n    query_b=Query(None),\n    coo: str = Cookie(None),\n    x_head: int = Header(None),\n    x_under: str = Header(None, convert_underscores=False),\n):\n    return {\n        \"item_id\": item_id,\n        \"body\": body,\n        \"query_a\": query_a,\n        \"query_b\": query_b,\n        \"coo\": coo,\n        \"x_head\": x_head,\n        \"x_under\": x_under,\n    }\n\n\n@app.post(\"/items-all-params-defaults/{item_id}\")\ndef post_items_all_params_default(\n    item_id: str,\n    body_item_a: Item,\n    body_item_b: Item,\n    query_a: int,\n    query_b: int,\n    coo: str = Cookie(None),\n    x_head: int = Header(None),\n    x_under: str = Header(None, convert_underscores=False),\n):\n    return {\n        \"item_id\": item_id,\n        \"body_item_a\": body_item_a,\n        \"body_item_b\": body_item_b,\n        \"query_a\": query_a,\n        \"query_b\": query_b,\n        \"coo\": coo,\n        \"x_head\": x_head,\n        \"x_under\": x_under,\n    }\n\n\n@app.delete(\"/items/{item_id}\")\ndef delete_item(item_id: str):\n    return item_id\n\n\n@app.options(\"/options/\")\ndef options():\n    return JSONResponse(headers={\"x-fastapi\": \"fast\"})\n\n\n@app.head(\"/head/\")\ndef head():\n    return {\"not sent\": \"nope\"}\n\n\n@app.patch(\"/patch/{user_id}\")\ndef patch(user_id: str, increment: float):\n    return {\"user_id\": user_id, \"total\": 5 + increment}\n\n\n@app.trace(\"/trace/\")\ndef trace():\n    return PlainTextResponse(media_type=\"message/http\")\n\n\n@app.get(\"/model\", response_model=Item, status_code=HTTP_202_ACCEPTED)\ndef model():\n    return {\"name\": \"Foo\", \"price\": \"5.0\", \"password\": \"not sent\"}\n\n\n@app.get(\n    \"/metadata\",\n    tags=[\"tag1\", \"tag2\"],\n    summary=\"The summary\",\n    description=\"The description\",\n    response_description=\"Response description\",\n    deprecated=True,\n    operation_id=\"a_very_long_and_strange_operation_id\",\n)\ndef get_meta():\n    return \"Foo\"\n\n\n@app.get(\"/html\", content_type=HTMLResponse)\ndef get_html():\n    return \"\"\"\n    <html>\n    <body>\n    <h1>\n    Some text inside\n    </h1>\n    </body>\n    </html>\n    \"\"\"\n\n\nclass FakeDB:\n    def __init__(self):\n        self.data = {\n            \"johndoe\": {\n                \"username\": \"johndoe\",\n                \"password\": \"shouldbehashed\",\n                \"fist_name\": \"John\",\n                \"last_name\": \"Doe\",\n            }\n        }\n\n\nclass DBConnectionManager:\n    def __init__(self):\n        self.db = FakeDB()\n\n    def __call__(self):\n        return self.db\n\n\nconnection_manager = DBConnectionManager()\n\n\nclass TokenUserData(BaseModel):\n    username: str\n    password: str\n\n\nclass UserInDB(BaseModel):\n    username: str\n    password: str\n    fist_name: str\n    last_name: str\n\n\ndef require_token(\n    token: str = Security(reusable_oauth2, scopes=[\"read:user\", \"write:user\"])\n):\n    raw_token = token.replace(\"Bearer \", \"\")\n    # Never do this plaintext password usage in production\n    username, password = raw_token.split(\":\")\n    return TokenUserData(username=username, password=password)\n\n\ndef require_user(\n    db: FakeDB = Depends(connection_manager),\n    user_data: TokenUserData = Depends(require_token),\n):\n    return db.data[user_data.username]\n\n\nclass UserOut(BaseModel):\n    username: str\n    fist_name: str\n    last_name: str\n\n\n@app.get(\"/dependency\", response_model=UserOut)\ndef get_dependency(user: UserInDB = Depends(require_user)):\n    return user\n", "fix_code": "from fastapi import (\n    Body,\n    Cookie,\n    Depends,\n    FastAPI,\n    File,\n    Form,\n    Header,\n    Path,\n    Query,\n    Security,\n)\nfrom fastapi.security import HTTPBasic, OAuth2, OAuth2PasswordRequestForm\nfrom pydantic import BaseModel\nfrom starlette.responses import HTMLResponse, JSONResponse, PlainTextResponse\nfrom starlette.status import HTTP_202_ACCEPTED\nfrom starlette.testclient import TestClient\n\nfrom .endpoints.a import router as router_a\nfrom .endpoints.b import router as router_b\n\napp = FastAPI()\n\n\napp.include_router(router_a)\napp.include_router(router_b, prefix=\"/b\")\n\n\n@app.get(\"/text\")\ndef get_text():\n    return \"Hello World\"\n\n\n@app.get(\"/path/{item_id}\")\ndef get_id(item_id):\n    return item_id\n\n\n@app.get(\"/path/str/{item_id}\")\ndef get_str_id(item_id: str):\n    return item_id\n\n\n@app.get(\"/path/int/{item_id}\")\ndef get_int_id(item_id: int):\n    return item_id\n\n\n@app.get(\"/path/float/{item_id}\")\ndef get_float_id(item_id: float):\n    return item_id\n\n\n@app.get(\"/path/bool/{item_id}\")\ndef get_bool_id(item_id: bool):\n    return item_id\n\n\n@app.get(\"/path/param/{item_id}\")\ndef get_path_param_id(item_id: str = Path(None)):\n    return item_id\n\n\n@app.get(\"/path/param-required/{item_id}\")\ndef get_path_param_required_id(item_id: str = Path(...)):\n    return item_id\n\n\n@app.get(\"/path/param-minlength/{item_id}\")\ndef get_path_param_min_length(item_id: str = Path(..., min_length = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-maxlength/{item_id}\")\ndef get_path_param_max_length(item_id: str = Path(..., max_length = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-min_maxlength/{item_id}\")\ndef get_path_param_min_max_length(item_id: str = Path(..., max_length = 3, min_length = 2)):\n    return item_id\n\n\n@app.get(\"/path/param-gt/{item_id}\")\ndef get_path_param_gt(item_id: float = Path(..., gt = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-gt0/{item_id}\")\ndef get_path_param_gt0(item_id: float = Path(..., gt = 0)):\n    return item_id\n\n\n@app.get(\"/path/param-ge/{item_id}\")\ndef get_path_param_ge(item_id: float = Path(..., ge = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-lt/{item_id}\")\ndef get_path_param_lt(item_id: float = Path(..., lt = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-lt0/{item_id}\")\ndef get_path_param_lt0(item_id: float = Path(..., lt = 0)):\n    return item_id\n\n\n@app.get(\"/path/param-le/{item_id}\")\ndef get_path_param_le(item_id: float = Path(..., le = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-lt-gt/{item_id}\")\ndef get_path_param_lt_gt(item_id: float = Path(..., lt = 3, gt = 1)):\n    return item_id\n\n\n@app.get(\"/path/param-le-ge/{item_id}\")\ndef get_path_param_le_ge(item_id: float = Path(..., le = 3, ge = 1)):\n    return item_id\n\n\n@app.get(\"/path/param-lt-int/{item_id}\")\ndef get_path_param_lt_int(item_id: int = Path(..., lt = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-gt-int/{item_id}\")\ndef get_path_param_gt_int(item_id: int = Path(..., gt = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-le-int/{item_id}\")\ndef get_path_param_le_int(item_id: int = Path(..., le = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-ge-int/{item_id}\")\ndef get_path_param_ge_int(item_id: int = Path(..., ge = 3)):\n    return item_id\n\n\n@app.get(\"/path/param-lt-gt-int/{item_id}\")\ndef get_path_param_lt_gt_int(item_id: int = Path(..., lt = 3, gt = 1)):\n    return item_id\n\n\n@app.get(\"/path/param-le-ge-int/{item_id}\")\ndef get_path_param_le_ge_int(item_id: int = Path(..., le = 3, ge = 1)):\n    return item_id\n\n\n@app.get(\"/query\")\ndef get_query(query):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/optional\")\ndef get_query_optional(query=None):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/int\")\ndef get_query_type(query: int):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/int/optional\")\ndef get_query_type_optional(query: int = None):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/param\")\ndef get_query_param(query=Query(None)):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/param-required\")\ndef get_query_param_required(query=Query(...)):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/query/param-required/int\")\ndef get_query_param_required_type(query: int = Query(...)):\n    if query is None:\n        return \"foo bar\"\n    return f\"foo bar {query}\"\n\n\n@app.get(\"/cookie\")\ndef get_cookie(coo=Cookie(None)):\n    return coo\n\n\n@app.get(\"/header\")\ndef get_header(head_name=Header(None)):\n    return head_name\n\n\n@app.get(\"/header_under\")\ndef get_header(head_name=Header(None, convert_underscores=False)):\n    return head_name\n\n\n@app.get(\"/security\")\ndef get_security(sec=Security(HTTPBasic())):\n    return sec\n\n\nreusable_oauth2 = OAuth2(\n    flows={\n        \"password\": {\n            \"tokenUrl\": \"/token\",\n            \"scopes\": {\"read:user\": \"Read a User\", \"write:user\": \"Create a user\"},\n        }\n    }\n)\n\n\n@app.get(\"/security/oauth2\")\ndef get_security_oauth2(sec=Security(reusable_oauth2, scopes=[\"read:user\"])):\n    return sec\n\n\n@app.post(\"/token\")\ndef post_token(request_data: OAuth2PasswordRequestForm = Form(...)):\n    print(request_data)\n    data = request_data.parse()\n    print(data)\n\n    print(request_data())\n    access_token = request_data.username + \":\" + request_data.password\n    return {\"access_token\": access_token}\n\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    is_offer: bool\n\n\n@app.put(\"/items/{item_id}\")\ndef put_item(item_id: str, item: Item):\n    return item\n\n\n@app.post(\"/items/\")\ndef post_item(item: Item):\n    return item\n\n\n@app.post(\"/items-all-params/{item_id}\")\ndef post_items_all_params(\n    item_id: str = Path(...),\n    body: Item = Body(...),\n    query_a: int = Query(None),\n    query_b=Query(None),\n    coo: str = Cookie(None),\n    x_head: int = Header(None),\n    x_under: str = Header(None, convert_underscores=False),\n):\n    return {\n        \"item_id\": item_id,\n        \"body\": body,\n        \"query_a\": query_a,\n        \"query_b\": query_b,\n        \"coo\": coo,\n        \"x_head\": x_head,\n        \"x_under\": x_under,\n    }\n\n\n@app.post(\"/items-all-params-defaults/{item_id}\")\ndef post_items_all_params_default(\n    item_id: str,\n    body_item_a: Item,\n    body_item_b: Item,\n    query_a: int,\n    query_b: int,\n    coo: str = Cookie(None),\n    x_head: int = Header(None),\n    x_under: str = Header(None, convert_underscores=False),\n):\n    return {\n        \"item_id\": item_id,\n        \"body_item_a\": body_item_a,\n        \"body_item_b\": body_item_b,\n        \"query_a\": query_a,\n        \"query_b\": query_b,\n        \"coo\": coo,\n        \"x_head\": x_head,\n        \"x_under\": x_under,\n    }\n\n\n@app.delete(\"/items/{item_id}\")\ndef delete_item(item_id: str):\n    return item_id\n\n\n@app.options(\"/options/\")\ndef options():\n    return JSONResponse(headers={\"x-fastapi\": \"fast\"})\n\n\n@app.head(\"/head/\")\ndef head():\n    return {\"not sent\": \"nope\"}\n\n\n@app.patch(\"/patch/{user_id}\")\ndef patch(user_id: str, increment: float):\n    return {\"user_id\": user_id, \"total\": 5 + increment}\n\n\n@app.trace(\"/trace/\")\ndef trace():\n    return PlainTextResponse(media_type=\"message/http\")\n\n\n@app.get(\"/model\", response_model=Item, status_code=HTTP_202_ACCEPTED)\ndef model():\n    return {\"name\": \"Foo\", \"price\": \"5.0\", \"password\": \"not sent\"}\n\n\n@app.get(\n    \"/metadata\",\n    tags=[\"tag1\", \"tag2\"],\n    summary=\"The summary\",\n    description=\"The description\",\n    response_description=\"Response description\",\n    deprecated=True,\n    operation_id=\"a_very_long_and_strange_operation_id\",\n)\ndef get_meta():\n    return \"Foo\"\n\n\n@app.get(\"/html\", content_type=HTMLResponse)\ndef get_html():\n    return \"\"\"\n    <html>\n    <body>\n    <h1>\n    Some text inside\n    </h1>\n    </body>\n    </html>\n    \"\"\"\n\n\nclass FakeDB:\n    def __init__(self):\n        self.data = {\n            \"johndoe\": {\n                \"username\": \"johndoe\",\n                \"password\": \"shouldbehashed\",\n                \"fist_name\": \"John\",\n                \"last_name\": \"Doe\",\n            }\n        }\n\n\nclass DBConnectionManager:\n    def __init__(self):\n        self.db = FakeDB()\n\n    def __call__(self):\n        return self.db\n\n\nconnection_manager = DBConnectionManager()\n\n\nclass TokenUserData(BaseModel):\n    username: str\n    password: str\n\n\nclass UserInDB(BaseModel):\n    username: str\n    password: str\n    fist_name: str\n    last_name: str\n\n\ndef require_token(\n    token: str = Security(reusable_oauth2, scopes=[\"read:user\", \"write:user\"])\n):\n    raw_token = token.replace(\"Bearer \", \"\")\n    # Never do this plaintext password usage in production\n    username, password = raw_token.split(\":\")\n    return TokenUserData(username=username, password=password)\n\n\ndef require_user(\n    db: FakeDB = Depends(connection_manager),\n    user_data: TokenUserData = Depends(require_token),\n):\n    return db.data[user_data.username]\n\n\nclass UserOut(BaseModel):\n    username: str\n    fist_name: str\n    last_name: str\n\n\n@app.get(\"/dependency\", response_model=UserOut)\ndef get_dependency(user: UserInDB = Depends(require_user)):\n    return user\n", "diff": "@@ -1,4 +1,4 @@\n-from fastapi.applications import (\n+from fastapi import (\n     Body,\n     Cookie,\n     Depends,\n@@ -215,11 +215,6 @@ def get_header(head_name=Header(None, convert_underscores=False)):\n     return head_name\n \n \n-@app.get(\"/param\")\n-def get_param(par=Param(None)):\n-    return par\n-\n-\n @app.get(\"/security\")\n def get_security(sec=Security(HTTPBasic())):\n     return sec\n"}
{"commit_hash": "4eb29506267cec07c7c9d45b569b951dfae61355", "issue_description": ":bug: Fix error location for required parameters", "code_before": "import asyncio\nimport inspect\nfrom copy import deepcopy\nfrom typing import Any, Callable, Dict, List, Mapping, Sequence, Tuple, Type\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant, SecurityRequirement\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.utils import get_path_param_names\nfrom pydantic import BaseConfig, Schema, create_model\nfrom pydantic.error_wrappers import ErrorWrapper\nfrom pydantic.errors import MissingError\nfrom pydantic.fields import Field, Required\nfrom pydantic.schema import get_annotation_from_schema\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.requests import Request\n\nparam_supported_types = (str, int, float, bool)\n\n\ndef get_sub_dependant(*, param: inspect.Parameter, path: str) -> Dependant:\n    depends: params.Depends = param.default\n    if depends.dependency:\n        dependency = depends.dependency\n    else:\n        dependency = param.annotation\n    sub_dependant = get_dependant(path=path, call=dependency, name=param.name)\n    if isinstance(depends, params.Security) and isinstance(dependency, SecurityBase):\n        security_requirement = SecurityRequirement(\n            security_scheme=dependency, scopes=depends.scopes\n        )\n        sub_dependant.security_requirements.append(security_requirement)\n    return sub_dependant\n\n\ndef get_flat_dependant(dependant: Dependant) -> Dependant:\n    flat_dependant = Dependant(\n        path_params=dependant.path_params.copy(),\n        query_params=dependant.query_params.copy(),\n        header_params=dependant.header_params.copy(),\n        cookie_params=dependant.cookie_params.copy(),\n        body_params=dependant.body_params.copy(),\n        security_schemes=dependant.security_requirements.copy(),\n    )\n    for sub_dependant in dependant.dependencies:\n        if sub_dependant is dependant:\n            raise ValueError(\"recursion\", dependant.dependencies)\n        flat_sub = get_flat_dependant(sub_dependant)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant\n\n\ndef get_dependant(*, path: str, call: Callable, name: str = None) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = inspect.signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name)\n    for param_name in signature_params:\n        param = signature_params[param_name]\n        if isinstance(param.default, params.Depends):\n            sub_dependant = get_sub_dependant(param=param, path=path)\n            dependant.dependencies.append(sub_dependant)\n    for param_name in signature_params:\n        param = signature_params[param_name]\n        if (\n            (param.default == param.empty) or isinstance(param.default, params.Path)\n        ) and (param_name in path_param_names):\n            assert (\n                lenient_issubclass(param.annotation, param_supported_types)\n                or param.annotation == param.empty\n            ), f\"Path params must be of type str, int, float or boot: {param}\"\n            param = signature_params[param_name]\n            add_param_to_fields(\n                param=param,\n                dependant=dependant,\n                default_schema=params.Path,\n                force_type=params.ParamTypes.path,\n            )\n        elif (\n            param.default == param.empty\n            or param.default is None\n            or type(param.default) in param_supported_types\n        ) and (\n            param.annotation == param.empty\n            or lenient_issubclass(param.annotation, param_supported_types)\n        ):\n            add_param_to_fields(\n                param=param, dependant=dependant, default_schema=params.Query\n            )\n        elif isinstance(param.default, params.Param):\n            if param.annotation != param.empty:\n                assert lenient_issubclass(\n                    param.annotation, param_supported_types\n                ), f\"Parameters for Path, Query, Header and Cookies must be of type str, int, float or bool: {param}\"\n            add_param_to_fields(\n                param=param, dependant=dependant, default_schema=params.Query\n            )\n        elif lenient_issubclass(param.annotation, Request):\n            dependant.request_param_name = param_name\n        elif not isinstance(param.default, params.Depends):\n            add_param_to_body_fields(param=param, dependant=dependant)\n    return dependant\n\n\ndef add_param_to_fields(\n    *,\n    param: inspect.Parameter,\n    dependant: Dependant,\n    default_schema: Type[Schema] = params.Param,\n    force_type: params.ParamTypes = None,\n) -> None:\n    default_value = Required\n    if not param.default == param.empty:\n        default_value = param.default\n    if isinstance(default_value, params.Param):\n        schema = default_value\n        default_value = schema.default\n        if getattr(schema, \"in_\", None) is None:\n            schema.in_ = default_schema.in_\n        if force_type:\n            schema.in_ = force_type\n    else:\n        schema = default_schema(default_value)\n    required = default_value == Required\n    annotation: Any = Any\n    if not param.annotation == param.empty:\n        annotation = param.annotation\n    annotation = get_annotation_from_schema(annotation, schema)\n    if not schema.alias and getattr(schema, \"convert_underscores\", None):\n        alias = param.name.replace(\"_\", \"-\")\n    else:\n        alias = schema.alias or param.name\n    field = Field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=alias,\n        required=required,\n        model_config=BaseConfig(),\n        class_validators=[],\n        schema=schema,\n    )\n    if schema.in_ == params.ParamTypes.path:\n        dependant.path_params.append(field)\n    elif schema.in_ == params.ParamTypes.query:\n        dependant.query_params.append(field)\n    elif schema.in_ == params.ParamTypes.header:\n        dependant.header_params.append(field)\n    else:\n        assert (\n            schema.in_ == params.ParamTypes.cookie\n        ), f\"non-body parameters must be in path, query, header or cookie: {param.name}\"\n        dependant.cookie_params.append(field)\n\n\ndef add_param_to_body_fields(*, param: inspect.Parameter, dependant: Dependant) -> None:\n    default_value = Required\n    if not param.default == param.empty:\n        default_value = param.default\n    if isinstance(default_value, Schema):\n        schema = default_value\n        default_value = schema.default\n    else:\n        schema = Schema(default_value)\n    required = default_value == Required\n    annotation = get_annotation_from_schema(param.annotation, schema)\n    field = Field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=schema.alias or param.name,\n        required=required,\n        model_config=BaseConfig,\n        class_validators=[],\n        schema=schema,\n    )\n    dependant.body_params.append(field)\n\n\ndef is_coroutine_callable(call: Callable = None) -> bool:\n    if not call:\n        return False\n    if inspect.isfunction(call):\n        return asyncio.iscoroutinefunction(call)\n    if inspect.isclass(call):\n        return False\n    call = getattr(call, \"__call__\", None)\n    if not call:\n        return False\n    return asyncio.iscoroutinefunction(call)\n\n\nasync def solve_dependencies(\n    *, request: Request, dependant: Dependant, body: Dict[str, Any] = None\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values: Dict[str, Any] = {}\n    errors: List[ErrorWrapper] = []\n    for sub_dependant in dependant.dependencies:\n        sub_values, sub_errors = await solve_dependencies(\n            request=request, dependant=sub_dependant, body=body\n        )\n        if sub_errors:\n            return {}, errors\n        assert sub_dependant.call is not None, \"sub_dependant.call must be a function\"\n        if is_coroutine_callable(sub_dependant.call):\n            solved = await sub_dependant.call(**sub_values)\n        else:\n            solved = await run_in_threadpool(sub_dependant.call, **sub_values)\n        assert sub_dependant.name is not None, \"Subdependants always have a name\"\n        values[sub_dependant.name] = solved\n    path_values, path_errors = request_params_to_args(\n        dependant.path_params, request.path_params\n    )\n    query_values, query_errors = request_params_to_args(\n        dependant.query_params, request.query_params\n    )\n    header_values, header_errors = request_params_to_args(\n        dependant.header_params, request.headers\n    )\n    cookie_values, cookie_errors = request_params_to_args(\n        dependant.cookie_params, request.cookies\n    )\n    values.update(path_values)\n    values.update(query_values)\n    values.update(header_values)\n    values.update(cookie_values)\n    errors = path_errors + query_errors + header_errors + cookie_errors\n    if dependant.body_params:\n        body_values, body_errors = await request_body_to_args(  # type: ignore # body_params checked above\n            dependant.body_params, body\n        )\n        values.update(body_values)\n        errors.extend(body_errors)\n    if dependant.request_param_name:\n        values[dependant.request_param_name] = request\n    return values, errors\n\n\ndef request_params_to_args(\n    required_params: Sequence[Field], received_params: Mapping[str, Any]\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    for field in required_params:\n        value = received_params.get(field.alias)\n        if value is None:\n            if field.required:\n                errors.append(\n                    ErrorWrapper(MissingError(), loc=field.alias, config=BaseConfig)\n                )\n            else:\n                values[field.name] = deepcopy(field.default)\n            continue\n        schema: params.Param = field.schema\n        assert isinstance(schema, params.Param), \"Params must be subclasses of Param\"\n        v_, errors_ = field.validate(value, values, loc=(schema.in_.value, field.alias))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        else:\n            values[field.name] = v_\n    return values, errors\n\n\nasync def request_body_to_args(\n    required_params: List[Field], received_body: Dict[str, Any]\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    if required_params:\n        field = required_params[0]\n        embed = getattr(field.schema, \"embed\", None)\n        if len(required_params) == 1 and not embed:\n            received_body = {field.alias: received_body}\n        for field in required_params:\n            value = received_body.get(field.alias)\n            if value is None:\n                if field.required:\n                    errors.append(\n                        ErrorWrapper(\n                            MissingError(), loc=(\"body\", field.alias), config=BaseConfig\n                        )\n                    )\n                else:\n                    values[field.name] = deepcopy(field.default)\n                continue\n            v_, errors_ = field.validate(value, values, loc=(\"body\", field.alias))\n            if isinstance(errors_, ErrorWrapper):\n                errors.append(errors_)\n            elif isinstance(errors_, list):\n                errors.extend(errors_)\n            else:\n                values[field.name] = v_\n    return values, errors\n\n\ndef get_body_field(*, dependant: Dependant, name: str) -> Field:\n    flat_dependant = get_flat_dependant(dependant)\n    if not flat_dependant.body_params:\n        return None\n    first_param = flat_dependant.body_params[0]\n    embed = getattr(first_param.schema, \"embed\", None)\n    if len(flat_dependant.body_params) == 1 and not embed:\n        return first_param\n    model_name = \"Body_\" + name\n    BodyModel = create_model(model_name)\n    for f in flat_dependant.body_params:\n        BodyModel.__fields__[f.name] = f\n    required = any(True for f in flat_dependant.body_params if f.required)\n    if any(isinstance(f.schema, params.File) for f in flat_dependant.body_params):\n        BodySchema: Type[params.Body] = params.File\n    elif any(isinstance(f.schema, params.Form) for f in flat_dependant.body_params):\n        BodySchema = params.Form\n    else:\n        BodySchema = params.Body\n\n    field = Field(\n        name=\"body\",\n        type_=BodyModel,\n        default=None,\n        required=required,\n        model_config=BaseConfig,\n        class_validators=[],\n        alias=\"body\",\n        schema=BodySchema(None),\n    )\n    return field\n", "fix_code": "import asyncio\nimport inspect\nfrom copy import deepcopy\nfrom typing import Any, Callable, Dict, List, Mapping, Sequence, Tuple, Type\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant, SecurityRequirement\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.utils import get_path_param_names\nfrom pydantic import BaseConfig, Schema, create_model\nfrom pydantic.error_wrappers import ErrorWrapper\nfrom pydantic.errors import MissingError\nfrom pydantic.fields import Field, Required\nfrom pydantic.schema import get_annotation_from_schema\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.requests import Request\n\nparam_supported_types = (str, int, float, bool)\n\n\ndef get_sub_dependant(*, param: inspect.Parameter, path: str) -> Dependant:\n    depends: params.Depends = param.default\n    if depends.dependency:\n        dependency = depends.dependency\n    else:\n        dependency = param.annotation\n    sub_dependant = get_dependant(path=path, call=dependency, name=param.name)\n    if isinstance(depends, params.Security) and isinstance(dependency, SecurityBase):\n        security_requirement = SecurityRequirement(\n            security_scheme=dependency, scopes=depends.scopes\n        )\n        sub_dependant.security_requirements.append(security_requirement)\n    return sub_dependant\n\n\ndef get_flat_dependant(dependant: Dependant) -> Dependant:\n    flat_dependant = Dependant(\n        path_params=dependant.path_params.copy(),\n        query_params=dependant.query_params.copy(),\n        header_params=dependant.header_params.copy(),\n        cookie_params=dependant.cookie_params.copy(),\n        body_params=dependant.body_params.copy(),\n        security_schemes=dependant.security_requirements.copy(),\n    )\n    for sub_dependant in dependant.dependencies:\n        if sub_dependant is dependant:\n            raise ValueError(\"recursion\", dependant.dependencies)\n        flat_sub = get_flat_dependant(sub_dependant)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant\n\n\ndef get_dependant(*, path: str, call: Callable, name: str = None) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = inspect.signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name)\n    for param_name in signature_params:\n        param = signature_params[param_name]\n        if isinstance(param.default, params.Depends):\n            sub_dependant = get_sub_dependant(param=param, path=path)\n            dependant.dependencies.append(sub_dependant)\n    for param_name in signature_params:\n        param = signature_params[param_name]\n        if (\n            (param.default == param.empty) or isinstance(param.default, params.Path)\n        ) and (param_name in path_param_names):\n            assert (\n                lenient_issubclass(param.annotation, param_supported_types)\n                or param.annotation == param.empty\n            ), f\"Path params must be of type str, int, float or boot: {param}\"\n            param = signature_params[param_name]\n            add_param_to_fields(\n                param=param,\n                dependant=dependant,\n                default_schema=params.Path,\n                force_type=params.ParamTypes.path,\n            )\n        elif (\n            param.default == param.empty\n            or param.default is None\n            or type(param.default) in param_supported_types\n        ) and (\n            param.annotation == param.empty\n            or lenient_issubclass(param.annotation, param_supported_types)\n        ):\n            add_param_to_fields(\n                param=param, dependant=dependant, default_schema=params.Query\n            )\n        elif isinstance(param.default, params.Param):\n            if param.annotation != param.empty:\n                assert lenient_issubclass(\n                    param.annotation, param_supported_types\n                ), f\"Parameters for Path, Query, Header and Cookies must be of type str, int, float or bool: {param}\"\n            add_param_to_fields(\n                param=param, dependant=dependant, default_schema=params.Query\n            )\n        elif lenient_issubclass(param.annotation, Request):\n            dependant.request_param_name = param_name\n        elif not isinstance(param.default, params.Depends):\n            add_param_to_body_fields(param=param, dependant=dependant)\n    return dependant\n\n\ndef add_param_to_fields(\n    *,\n    param: inspect.Parameter,\n    dependant: Dependant,\n    default_schema: Type[Schema] = params.Param,\n    force_type: params.ParamTypes = None,\n) -> None:\n    default_value = Required\n    if not param.default == param.empty:\n        default_value = param.default\n    if isinstance(default_value, params.Param):\n        schema = default_value\n        default_value = schema.default\n        if getattr(schema, \"in_\", None) is None:\n            schema.in_ = default_schema.in_\n        if force_type:\n            schema.in_ = force_type\n    else:\n        schema = default_schema(default_value)\n    required = default_value == Required\n    annotation: Any = Any\n    if not param.annotation == param.empty:\n        annotation = param.annotation\n    annotation = get_annotation_from_schema(annotation, schema)\n    if not schema.alias and getattr(schema, \"convert_underscores\", None):\n        alias = param.name.replace(\"_\", \"-\")\n    else:\n        alias = schema.alias or param.name\n    field = Field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=alias,\n        required=required,\n        model_config=BaseConfig(),\n        class_validators=[],\n        schema=schema,\n    )\n    if schema.in_ == params.ParamTypes.path:\n        dependant.path_params.append(field)\n    elif schema.in_ == params.ParamTypes.query:\n        dependant.query_params.append(field)\n    elif schema.in_ == params.ParamTypes.header:\n        dependant.header_params.append(field)\n    else:\n        assert (\n            schema.in_ == params.ParamTypes.cookie\n        ), f\"non-body parameters must be in path, query, header or cookie: {param.name}\"\n        dependant.cookie_params.append(field)\n\n\ndef add_param_to_body_fields(*, param: inspect.Parameter, dependant: Dependant) -> None:\n    default_value = Required\n    if not param.default == param.empty:\n        default_value = param.default\n    if isinstance(default_value, Schema):\n        schema = default_value\n        default_value = schema.default\n    else:\n        schema = Schema(default_value)\n    required = default_value == Required\n    annotation = get_annotation_from_schema(param.annotation, schema)\n    field = Field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=schema.alias or param.name,\n        required=required,\n        model_config=BaseConfig,\n        class_validators=[],\n        schema=schema,\n    )\n    dependant.body_params.append(field)\n\n\ndef is_coroutine_callable(call: Callable = None) -> bool:\n    if not call:\n        return False\n    if inspect.isfunction(call):\n        return asyncio.iscoroutinefunction(call)\n    if inspect.isclass(call):\n        return False\n    call = getattr(call, \"__call__\", None)\n    if not call:\n        return False\n    return asyncio.iscoroutinefunction(call)\n\n\nasync def solve_dependencies(\n    *, request: Request, dependant: Dependant, body: Dict[str, Any] = None\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values: Dict[str, Any] = {}\n    errors: List[ErrorWrapper] = []\n    for sub_dependant in dependant.dependencies:\n        sub_values, sub_errors = await solve_dependencies(\n            request=request, dependant=sub_dependant, body=body\n        )\n        if sub_errors:\n            return {}, errors\n        assert sub_dependant.call is not None, \"sub_dependant.call must be a function\"\n        if is_coroutine_callable(sub_dependant.call):\n            solved = await sub_dependant.call(**sub_values)\n        else:\n            solved = await run_in_threadpool(sub_dependant.call, **sub_values)\n        assert sub_dependant.name is not None, \"Subdependants always have a name\"\n        values[sub_dependant.name] = solved\n    path_values, path_errors = request_params_to_args(\n        dependant.path_params, request.path_params\n    )\n    query_values, query_errors = request_params_to_args(\n        dependant.query_params, request.query_params\n    )\n    header_values, header_errors = request_params_to_args(\n        dependant.header_params, request.headers\n    )\n    cookie_values, cookie_errors = request_params_to_args(\n        dependant.cookie_params, request.cookies\n    )\n    values.update(path_values)\n    values.update(query_values)\n    values.update(header_values)\n    values.update(cookie_values)\n    errors = path_errors + query_errors + header_errors + cookie_errors\n    if dependant.body_params:\n        body_values, body_errors = await request_body_to_args(  # type: ignore # body_params checked above\n            dependant.body_params, body\n        )\n        values.update(body_values)\n        errors.extend(body_errors)\n    if dependant.request_param_name:\n        values[dependant.request_param_name] = request\n    return values, errors\n\n\ndef request_params_to_args(\n    required_params: Sequence[Field], received_params: Mapping[str, Any]\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    for field in required_params:\n        value = received_params.get(field.alias)\n        schema: params.Param = field.schema\n        assert isinstance(schema, params.Param), \"Params must be subclasses of Param\"\n        if value is None:\n            if field.required:\n                errors.append(\n                    ErrorWrapper(MissingError(), loc=(schema.in_.value, field.alias), config=BaseConfig)\n                )\n            else:\n                values[field.name] = deepcopy(field.default)\n            continue\n        v_, errors_ = field.validate(value, values, loc=(schema.in_.value, field.alias))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        else:\n            values[field.name] = v_\n    return values, errors\n\n\nasync def request_body_to_args(\n    required_params: List[Field], received_body: Dict[str, Any]\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    if required_params:\n        field = required_params[0]\n        embed = getattr(field.schema, \"embed\", None)\n        if len(required_params) == 1 and not embed:\n            received_body = {field.alias: received_body}\n        for field in required_params:\n            value = received_body.get(field.alias)\n            if value is None:\n                if field.required:\n                    errors.append(\n                        ErrorWrapper(\n                            MissingError(), loc=(\"body\", field.alias), config=BaseConfig\n                        )\n                    )\n                else:\n                    values[field.name] = deepcopy(field.default)\n                continue\n            v_, errors_ = field.validate(value, values, loc=(\"body\", field.alias))\n            if isinstance(errors_, ErrorWrapper):\n                errors.append(errors_)\n            elif isinstance(errors_, list):\n                errors.extend(errors_)\n            else:\n                values[field.name] = v_\n    return values, errors\n\n\ndef get_body_field(*, dependant: Dependant, name: str) -> Field:\n    flat_dependant = get_flat_dependant(dependant)\n    if not flat_dependant.body_params:\n        return None\n    first_param = flat_dependant.body_params[0]\n    embed = getattr(first_param.schema, \"embed\", None)\n    if len(flat_dependant.body_params) == 1 and not embed:\n        return first_param\n    model_name = \"Body_\" + name\n    BodyModel = create_model(model_name)\n    for f in flat_dependant.body_params:\n        BodyModel.__fields__[f.name] = f\n    required = any(True for f in flat_dependant.body_params if f.required)\n    if any(isinstance(f.schema, params.File) for f in flat_dependant.body_params):\n        BodySchema: Type[params.Body] = params.File\n    elif any(isinstance(f.schema, params.Form) for f in flat_dependant.body_params):\n        BodySchema = params.Form\n    else:\n        BodySchema = params.Body\n\n    field = Field(\n        name=\"body\",\n        type_=BodyModel,\n        default=None,\n        required=required,\n        model_config=BaseConfig,\n        class_validators=[],\n        alias=\"body\",\n        schema=BodySchema(None),\n    )\n    return field\n", "diff": "@@ -249,16 +249,16 @@ def request_params_to_args(\n     errors = []\n     for field in required_params:\n         value = received_params.get(field.alias)\n+        schema: params.Param = field.schema\n+        assert isinstance(schema, params.Param), \"Params must be subclasses of Param\"\n         if value is None:\n             if field.required:\n                 errors.append(\n-                    ErrorWrapper(MissingError(), loc=field.alias, config=BaseConfig)\n+                    ErrorWrapper(MissingError(), loc=(schema.in_.value, field.alias), config=BaseConfig)\n                 )\n             else:\n                 values[field.name] = deepcopy(field.default)\n             continue\n-        schema: params.Param = field.schema\n-        assert isinstance(schema, params.Param), \"Params must be subclasses of Param\"\n         v_, errors_ = field.validate(value, values, loc=(schema.in_.value, field.alias))\n         if isinstance(errors_, ErrorWrapper):\n             errors.append(errors_)\n"}
{"commit_hash": "d5e782074f8036ebab58dfded913f67c873044df", "issue_description": ":bug: Fix email_validator error, generated by autoflake", "code_before": "import logging\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom pydantic import BaseModel, Schema as PSchema\nfrom pydantic.types import UrlStr\n\ntry:\n    from pydantic.types import EmailStr  # type: ignore\nexcept ImportError:  # pragma: no cover\n    logging.warning(\n        \"email-validator not installed, email fields will be treated as str.\\n\"\n        + \"To install, run: pip install email-validator\"\n    )\n\n    class EmailStr(str):  # type: ignore\n        pass\n\n\nclass Contact(BaseModel):\n    name: Optional[str] = None\n    url: Optional[UrlStr] = None\n    email: Optional[EmailStr] = None\n\n\nclass License(BaseModel):\n    name: str\n    url: Optional[UrlStr] = None\n\n\nclass Info(BaseModel):\n    title: str\n    description: Optional[str] = None\n    termsOfService: Optional[str] = None\n    contact: Optional[Contact] = None\n    license: Optional[License] = None\n    version: str\n\n\nclass ServerVariable(BaseModel):\n    enum: Optional[List[str]] = None\n    default: str\n    description: Optional[str] = None\n\n\nclass Server(BaseModel):\n    url: UrlStr\n    description: Optional[str] = None\n    variables: Optional[Dict[str, ServerVariable]] = None\n\n\nclass Reference(BaseModel):\n    ref: str = PSchema(..., alias=\"$ref\")  # type: ignore\n\n\nclass Discriminator(BaseModel):\n    propertyName: str\n    mapping: Optional[Dict[str, str]] = None\n\n\nclass XML(BaseModel):\n    name: Optional[str] = None\n    namespace: Optional[str] = None\n    prefix: Optional[str] = None\n    attribute: Optional[bool] = None\n    wrapped: Optional[bool] = None\n\n\nclass ExternalDocumentation(BaseModel):\n    description: Optional[str] = None\n    url: UrlStr\n\n\nclass SchemaBase(BaseModel):\n    ref: Optional[str] = PSchema(None, alias=\"$ref\")  # type: ignore\n    title: Optional[str] = None\n    multipleOf: Optional[float] = None\n    maximum: Optional[float] = None\n    exclusiveMaximum: Optional[float] = None\n    minimum: Optional[float] = None\n    exclusiveMinimum: Optional[float] = None\n    maxLength: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    minLength: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    pattern: Optional[str] = None\n    maxItems: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    minItems: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    uniqueItems: Optional[bool] = None\n    maxProperties: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    minProperties: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    required: Optional[List[str]] = None\n    enum: Optional[List[str]] = None\n    type: Optional[str] = None\n    allOf: Optional[List[Any]] = None\n    oneOf: Optional[List[Any]] = None\n    anyOf: Optional[List[Any]] = None\n    not_: Optional[List[Any]] = PSchema(None, alias=\"not\")  # type: ignore\n    items: Optional[Any] = None\n    properties: Optional[Dict[str, Any]] = None\n    additionalProperties: Optional[Union[bool, Any]] = None\n    description: Optional[str] = None\n    format: Optional[str] = None\n    default: Optional[Any] = None\n    nullable: Optional[bool] = None\n    discriminator: Optional[Discriminator] = None\n    readOnly: Optional[bool] = None\n    writeOnly: Optional[bool] = None\n    xml: Optional[XML] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    example: Optional[Any] = None\n    deprecated: Optional[bool] = None\n\n\nclass Schema(SchemaBase):\n    allOf: Optional[List[SchemaBase]] = None\n    oneOf: Optional[List[SchemaBase]] = None\n    anyOf: Optional[List[SchemaBase]] = None\n    not_: Optional[List[SchemaBase]] = PSchema(None, alias=\"not\")  # type: ignore\n    items: Optional[SchemaBase] = None\n    properties: Optional[Dict[str, SchemaBase]] = None\n    additionalProperties: Optional[Union[bool, SchemaBase]] = None\n\n\nclass Example(BaseModel):\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    value: Optional[Any] = None\n    externalValue: Optional[UrlStr] = None\n\n\nclass ParameterInType(Enum):\n    query = \"query\"\n    header = \"header\"\n    path = \"path\"\n    cookie = \"cookie\"\n\n\nclass Encoding(BaseModel):\n    contentType: Optional[str] = None\n    # Workaround OpenAPI recursive reference, using Any\n    headers: Optional[Dict[str, Union[Any, Reference]]] = None\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n\n\nclass MediaType(BaseModel):\n    schema_: Optional[Union[Schema, Reference]] = PSchema(\n        None, alias=\"schema\"\n    )  # type: ignore\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    encoding: Optional[Dict[str, Encoding]] = None\n\n\nclass ParameterBase(BaseModel):\n    description: Optional[str] = None\n    required: Optional[bool] = None\n    deprecated: Optional[bool] = None\n    # Serialization rules for simple scenarios\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n    schema_: Optional[Union[Schema, Reference]] = PSchema(\n        None, alias=\"schema\"\n    )  # type: ignore\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    # Serialization rules for more complex scenarios\n    content: Optional[Dict[str, MediaType]] = None\n\n\nclass Parameter(ParameterBase):\n    name: str\n    in_: ParameterInType = PSchema(..., alias=\"in\")  # type: ignore\n\n\nclass Header(ParameterBase):\n    pass\n\n\n# Workaround OpenAPI recursive reference\nclass EncodingWithHeaders(Encoding):\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n\n\nclass RequestBody(BaseModel):\n    description: Optional[str] = None\n    content: Dict[str, MediaType]\n    required: Optional[bool] = None\n\n\nclass Link(BaseModel):\n    operationRef: Optional[str] = None\n    operationId: Optional[str] = None\n    parameters: Optional[Dict[str, Union[Any, str]]] = None\n    requestBody: Optional[Union[Any, str]] = None\n    description: Optional[str] = None\n    server: Optional[Server] = None\n\n\nclass Response(BaseModel):\n    description: str\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    content: Optional[Dict[str, MediaType]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n\n\nclass Responses(BaseModel):\n    default: Response\n\n\nclass Operation(BaseModel):\n    tags: Optional[List[str]] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    operationId: Optional[str] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n    requestBody: Optional[Union[RequestBody, Reference]] = None\n    responses: Union[Responses, Dict[Union[str], Response]]\n    # Workaround OpenAPI recursive reference\n    callbacks: Optional[Dict[str, Union[Dict[str, Any], Reference]]] = None\n    deprecated: Optional[bool] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    servers: Optional[List[Server]] = None\n\n\nclass PathItem(BaseModel):\n    ref: Optional[str] = PSchema(None, alias=\"$ref\")  # type: ignore\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    get: Optional[Operation] = None\n    put: Optional[Operation] = None\n    post: Optional[Operation] = None\n    delete: Optional[Operation] = None\n    options: Optional[Operation] = None\n    head: Optional[Operation] = None\n    patch: Optional[Operation] = None\n    trace: Optional[Operation] = None\n    servers: Optional[List[Server]] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n\n\n# Workaround OpenAPI recursive reference\nclass OperationWithCallbacks(BaseModel):\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference]]] = None\n\n\nclass SecuritySchemeType(Enum):\n    apiKey = \"apiKey\"\n    http = \"http\"\n    oauth2 = \"oauth2\"\n    openIdConnect = \"openIdConnect\"\n\n\nclass SecurityBase(BaseModel):\n    type_: SecuritySchemeType = PSchema(..., alias=\"type\")  # type: ignore\n    description: Optional[str] = None\n\n\nclass APIKeyIn(Enum):\n    query = \"query\"\n    header = \"header\"\n    cookie = \"cookie\"\n\n\nclass APIKey(SecurityBase):\n    type_ = PSchema(SecuritySchemeType.apiKey, alias=\"type\")  # type: ignore\n    in_: APIKeyIn = PSchema(..., alias=\"in\")  # type: ignore\n    name: str\n\n\nclass HTTPBase(SecurityBase):\n    type_ = PSchema(SecuritySchemeType.http, alias=\"type\")  # type: ignore\n    scheme: str\n\n\nclass HTTPBearer(HTTPBase):\n    scheme = \"bearer\"\n    bearerFormat: Optional[str] = None\n\n\nclass OAuthFlow(BaseModel):\n    refreshUrl: Optional[str] = None\n    scopes: Dict[str, str] = {}\n\n\nclass OAuthFlowImplicit(OAuthFlow):\n    authorizationUrl: str\n\n\nclass OAuthFlowPassword(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowClientCredentials(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowAuthorizationCode(OAuthFlow):\n    authorizationUrl: str\n    tokenUrl: str\n\n\nclass OAuthFlows(BaseModel):\n    implicit: Optional[OAuthFlowImplicit] = None\n    password: Optional[OAuthFlowPassword] = None\n    clientCredentials: Optional[OAuthFlowClientCredentials] = None\n    authorizationCode: Optional[OAuthFlowAuthorizationCode] = None\n\n\nclass OAuth2(SecurityBase):\n    type_ = PSchema(SecuritySchemeType.oauth2, alias=\"type\")  # type: ignore\n    flows: OAuthFlows\n\n\nclass OpenIdConnect(SecurityBase):\n    type_ = PSchema(SecuritySchemeType.openIdConnect, alias=\"type\")  # type: ignore\n    openIdConnectUrl: str\n\n\nSecurityScheme = Union[APIKey, HTTPBase, HTTPBearer, OAuth2, OpenIdConnect]\n\n\nclass Components(BaseModel):\n    schemas: Optional[Dict[str, Union[Schema, Reference]]] = None\n    responses: Optional[Dict[str, Union[Response, Reference]]] = None\n    parameters: Optional[Dict[str, Union[Parameter, Reference]]] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    requestBodies: Optional[Dict[str, Union[RequestBody, Reference]]] = None\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    securitySchemes: Optional[Dict[str, Union[SecurityScheme, Reference]]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference]]] = None\n\n\nclass Tag(BaseModel):\n    name: str\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n\n\nclass OpenAPI(BaseModel):\n    openapi: str\n    info: Info\n    servers: Optional[List[Server]] = None\n    paths: Dict[str, PathItem]\n    components: Optional[Components] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    tags: Optional[List[Tag]] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n", "fix_code": "import logging\nfrom enum import Enum\nfrom typing import Any, Dict, List, Optional, Union\n\nfrom pydantic import BaseModel, Schema as PSchema\nfrom pydantic.types import UrlStr\n\ntry:\n    import email_validator\n\n    assert email_validator  # make autoflake ignore the unused import\n    from pydantic.types import EmailStr  # type: ignore\nexcept ImportError:  # pragma: no cover\n    logging.warning(\n        \"email-validator not installed, email fields will be treated as str.\\n\"\n        + \"To install, run: pip install email-validator\"\n    )\n\n    class EmailStr(str):  # type: ignore\n        pass\n\n\nclass Contact(BaseModel):\n    name: Optional[str] = None\n    url: Optional[UrlStr] = None\n    email: Optional[EmailStr] = None\n\n\nclass License(BaseModel):\n    name: str\n    url: Optional[UrlStr] = None\n\n\nclass Info(BaseModel):\n    title: str\n    description: Optional[str] = None\n    termsOfService: Optional[str] = None\n    contact: Optional[Contact] = None\n    license: Optional[License] = None\n    version: str\n\n\nclass ServerVariable(BaseModel):\n    enum: Optional[List[str]] = None\n    default: str\n    description: Optional[str] = None\n\n\nclass Server(BaseModel):\n    url: UrlStr\n    description: Optional[str] = None\n    variables: Optional[Dict[str, ServerVariable]] = None\n\n\nclass Reference(BaseModel):\n    ref: str = PSchema(..., alias=\"$ref\")  # type: ignore\n\n\nclass Discriminator(BaseModel):\n    propertyName: str\n    mapping: Optional[Dict[str, str]] = None\n\n\nclass XML(BaseModel):\n    name: Optional[str] = None\n    namespace: Optional[str] = None\n    prefix: Optional[str] = None\n    attribute: Optional[bool] = None\n    wrapped: Optional[bool] = None\n\n\nclass ExternalDocumentation(BaseModel):\n    description: Optional[str] = None\n    url: UrlStr\n\n\nclass SchemaBase(BaseModel):\n    ref: Optional[str] = PSchema(None, alias=\"$ref\")  # type: ignore\n    title: Optional[str] = None\n    multipleOf: Optional[float] = None\n    maximum: Optional[float] = None\n    exclusiveMaximum: Optional[float] = None\n    minimum: Optional[float] = None\n    exclusiveMinimum: Optional[float] = None\n    maxLength: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    minLength: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    pattern: Optional[str] = None\n    maxItems: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    minItems: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    uniqueItems: Optional[bool] = None\n    maxProperties: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    minProperties: Optional[int] = PSchema(None, gte=0)  # type: ignore\n    required: Optional[List[str]] = None\n    enum: Optional[List[str]] = None\n    type: Optional[str] = None\n    allOf: Optional[List[Any]] = None\n    oneOf: Optional[List[Any]] = None\n    anyOf: Optional[List[Any]] = None\n    not_: Optional[List[Any]] = PSchema(None, alias=\"not\")  # type: ignore\n    items: Optional[Any] = None\n    properties: Optional[Dict[str, Any]] = None\n    additionalProperties: Optional[Union[bool, Any]] = None\n    description: Optional[str] = None\n    format: Optional[str] = None\n    default: Optional[Any] = None\n    nullable: Optional[bool] = None\n    discriminator: Optional[Discriminator] = None\n    readOnly: Optional[bool] = None\n    writeOnly: Optional[bool] = None\n    xml: Optional[XML] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    example: Optional[Any] = None\n    deprecated: Optional[bool] = None\n\n\nclass Schema(SchemaBase):\n    allOf: Optional[List[SchemaBase]] = None\n    oneOf: Optional[List[SchemaBase]] = None\n    anyOf: Optional[List[SchemaBase]] = None\n    not_: Optional[List[SchemaBase]] = PSchema(None, alias=\"not\")  # type: ignore\n    items: Optional[SchemaBase] = None\n    properties: Optional[Dict[str, SchemaBase]] = None\n    additionalProperties: Optional[Union[bool, SchemaBase]] = None\n\n\nclass Example(BaseModel):\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    value: Optional[Any] = None\n    externalValue: Optional[UrlStr] = None\n\n\nclass ParameterInType(Enum):\n    query = \"query\"\n    header = \"header\"\n    path = \"path\"\n    cookie = \"cookie\"\n\n\nclass Encoding(BaseModel):\n    contentType: Optional[str] = None\n    # Workaround OpenAPI recursive reference, using Any\n    headers: Optional[Dict[str, Union[Any, Reference]]] = None\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n\n\nclass MediaType(BaseModel):\n    schema_: Optional[Union[Schema, Reference]] = PSchema(\n        None, alias=\"schema\"\n    )  # type: ignore\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    encoding: Optional[Dict[str, Encoding]] = None\n\n\nclass ParameterBase(BaseModel):\n    description: Optional[str] = None\n    required: Optional[bool] = None\n    deprecated: Optional[bool] = None\n    # Serialization rules for simple scenarios\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n    schema_: Optional[Union[Schema, Reference]] = PSchema(\n        None, alias=\"schema\"\n    )  # type: ignore\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    # Serialization rules for more complex scenarios\n    content: Optional[Dict[str, MediaType]] = None\n\n\nclass Parameter(ParameterBase):\n    name: str\n    in_: ParameterInType = PSchema(..., alias=\"in\")  # type: ignore\n\n\nclass Header(ParameterBase):\n    pass\n\n\n# Workaround OpenAPI recursive reference\nclass EncodingWithHeaders(Encoding):\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n\n\nclass RequestBody(BaseModel):\n    description: Optional[str] = None\n    content: Dict[str, MediaType]\n    required: Optional[bool] = None\n\n\nclass Link(BaseModel):\n    operationRef: Optional[str] = None\n    operationId: Optional[str] = None\n    parameters: Optional[Dict[str, Union[Any, str]]] = None\n    requestBody: Optional[Union[Any, str]] = None\n    description: Optional[str] = None\n    server: Optional[Server] = None\n\n\nclass Response(BaseModel):\n    description: str\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    content: Optional[Dict[str, MediaType]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n\n\nclass Responses(BaseModel):\n    default: Response\n\n\nclass Operation(BaseModel):\n    tags: Optional[List[str]] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    operationId: Optional[str] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n    requestBody: Optional[Union[RequestBody, Reference]] = None\n    responses: Union[Responses, Dict[Union[str], Response]]\n    # Workaround OpenAPI recursive reference\n    callbacks: Optional[Dict[str, Union[Dict[str, Any], Reference]]] = None\n    deprecated: Optional[bool] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    servers: Optional[List[Server]] = None\n\n\nclass PathItem(BaseModel):\n    ref: Optional[str] = PSchema(None, alias=\"$ref\")  # type: ignore\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    get: Optional[Operation] = None\n    put: Optional[Operation] = None\n    post: Optional[Operation] = None\n    delete: Optional[Operation] = None\n    options: Optional[Operation] = None\n    head: Optional[Operation] = None\n    patch: Optional[Operation] = None\n    trace: Optional[Operation] = None\n    servers: Optional[List[Server]] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n\n\n# Workaround OpenAPI recursive reference\nclass OperationWithCallbacks(BaseModel):\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference]]] = None\n\n\nclass SecuritySchemeType(Enum):\n    apiKey = \"apiKey\"\n    http = \"http\"\n    oauth2 = \"oauth2\"\n    openIdConnect = \"openIdConnect\"\n\n\nclass SecurityBase(BaseModel):\n    type_: SecuritySchemeType = PSchema(..., alias=\"type\")  # type: ignore\n    description: Optional[str] = None\n\n\nclass APIKeyIn(Enum):\n    query = \"query\"\n    header = \"header\"\n    cookie = \"cookie\"\n\n\nclass APIKey(SecurityBase):\n    type_ = PSchema(SecuritySchemeType.apiKey, alias=\"type\")  # type: ignore\n    in_: APIKeyIn = PSchema(..., alias=\"in\")  # type: ignore\n    name: str\n\n\nclass HTTPBase(SecurityBase):\n    type_ = PSchema(SecuritySchemeType.http, alias=\"type\")  # type: ignore\n    scheme: str\n\n\nclass HTTPBearer(HTTPBase):\n    scheme = \"bearer\"\n    bearerFormat: Optional[str] = None\n\n\nclass OAuthFlow(BaseModel):\n    refreshUrl: Optional[str] = None\n    scopes: Dict[str, str] = {}\n\n\nclass OAuthFlowImplicit(OAuthFlow):\n    authorizationUrl: str\n\n\nclass OAuthFlowPassword(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowClientCredentials(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowAuthorizationCode(OAuthFlow):\n    authorizationUrl: str\n    tokenUrl: str\n\n\nclass OAuthFlows(BaseModel):\n    implicit: Optional[OAuthFlowImplicit] = None\n    password: Optional[OAuthFlowPassword] = None\n    clientCredentials: Optional[OAuthFlowClientCredentials] = None\n    authorizationCode: Optional[OAuthFlowAuthorizationCode] = None\n\n\nclass OAuth2(SecurityBase):\n    type_ = PSchema(SecuritySchemeType.oauth2, alias=\"type\")  # type: ignore\n    flows: OAuthFlows\n\n\nclass OpenIdConnect(SecurityBase):\n    type_ = PSchema(SecuritySchemeType.openIdConnect, alias=\"type\")  # type: ignore\n    openIdConnectUrl: str\n\n\nSecurityScheme = Union[APIKey, HTTPBase, HTTPBearer, OAuth2, OpenIdConnect]\n\n\nclass Components(BaseModel):\n    schemas: Optional[Dict[str, Union[Schema, Reference]]] = None\n    responses: Optional[Dict[str, Union[Response, Reference]]] = None\n    parameters: Optional[Dict[str, Union[Parameter, Reference]]] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    requestBodies: Optional[Dict[str, Union[RequestBody, Reference]]] = None\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    securitySchemes: Optional[Dict[str, Union[SecurityScheme, Reference]]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference]]] = None\n\n\nclass Tag(BaseModel):\n    name: str\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n\n\nclass OpenAPI(BaseModel):\n    openapi: str\n    info: Info\n    servers: Optional[List[Server]] = None\n    paths: Dict[str, PathItem]\n    components: Optional[Components] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    tags: Optional[List[Tag]] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n", "diff": "@@ -6,6 +6,9 @@ from pydantic import BaseModel, Schema as PSchema\n from pydantic.types import UrlStr\n \n try:\n+    import email_validator\n+\n+    assert email_validator  # make autoflake ignore the unused import\n     from pydantic.types import EmailStr  # type: ignore\n except ImportError:  # pragma: no cover\n     logging.warning(\n"}
{"commit_hash": "b097a538ab4da1812ac73fe2d7f63fab6b351e5c", "issue_description": ":bookmark: Bump version, after fix for email_validator and docs", "code_before": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.11\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "fix_code": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.12\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "diff": "@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.1.11\"\n+__version__ = \"0.1.12\"\n \n from .applications import FastAPI\n from .routing import APIRouter\n"}
{"commit_hash": "75407b92952d4a5fabe9b2d7084fddce5725dcbd", "issue_description": ":rotating_light: Fix mypy type errors", "code_before": "import asyncio\nimport inspect\nimport logging\nfrom typing import Any, Callable, List, Optional, Type\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import get_body_field, get_dependant, solve_dependencies\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseConfig, BaseModel, Schema\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import Field\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.formparsers import UploadFile\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import get_name, request_response\nfrom starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n\n\ndef serialize_response(*, field: Field = None, response: Response) -> Any:\n    if field:\n        errors = []\n        value, errors_ = field.validate(response, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors)\n        return jsonable_encoder(value)\n    else:\n        return jsonable_encoder(response)\n\n\ndef get_app(\n    dependant: Dependant,\n    body_field: Field = None,\n    status_code: int = 200,\n    content_type: Type[Response] = JSONResponse,\n    response_field: Field = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must me a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    raw_body = await request.form()\n                    body = {}\n                    for field, value in raw_body.items():\n                        if isinstance(value, UploadFile):\n                            body[field] = await value.read()\n                        else:\n                            body[field] = value\n                    if not body:\n                        body = None\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logging.error(\"Error getting request body\", e)\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            )\n        values, errors = await solve_dependencies(\n            request=request, dependant=dependant, body=body\n        )\n        if errors:\n            errors_out = ValidationError(errors)\n            raise HTTPException(\n                status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=errors_out.errors()\n            )\n        else:\n            assert dependant.call is not None, \"dependant.call must me a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                return raw_response\n            if isinstance(raw_response, BaseModel):\n                return content_type(\n                    content=serialize_response(\n                        field=response_field, response=raw_response\n                    ),\n                    status_code=status_code,\n                )\n            errors = []\n            try:\n                return content_type(\n                    content=serialize_response(\n                        field=response_field, response=raw_response\n                    ),\n                    status_code=status_code,\n                )\n            except Exception as e:\n                errors.append(e)\n            try:\n                response = dict(raw_response)\n                return content_type(\n                    content=serialize_response(field=response_field, response=response),\n                    status_code=status_code,\n                )\n            except Exception as e:\n                errors.append(e)\n            try:\n                response = vars(raw_response)\n                return content_type(\n                    content=serialize_response(field=response_field, response=response),\n                    status_code=status_code,\n                )\n            except Exception as e:\n                errors.append(e)\n                raise ValueError(errors)\n\n    return app\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        name: str = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must always start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.response_model = response_model\n        if self.response_model:\n            assert lenient_issubclass(\n                content_type, JSONResponse\n            ), \"To declare a type the response must be a JSON response\"\n            response_name = \"Response_\" + self.name\n            self.response_field: Optional[Field] = Field(\n                name=response_name,\n                type_=self.response_model,\n                class_validators=[],\n                default=None,\n                required=False,\n                model_config=BaseConfig(),\n                schema=Schema(None),\n            )\n        else:\n            self.response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        self.summary = summary\n        self.description = description or self.endpoint.__doc__\n        self.response_description = response_description\n        self.deprecated = deprecated\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = methods\n        self.operation_id = operation_id\n        self.include_in_schema = include_in_schema\n        self.content_type = content_type\n\n        self.path_regex, self.path_format, self.param_convertors = self.compile_path(\n            path\n        )\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.body_field = get_body_field(dependant=self.dependant, name=self.name)\n        self.app = request_response(\n            get_app(\n                dependant=self.dependant,\n                body_field=self.body_field,\n                status_code=self.status_code,\n                content_type=self.content_type,\n                response_field=self.response_field,\n            )\n        )\n\n\nclass APIRouter(routing.Router):\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> None:\n        route = APIRoute(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                include_in_schema=include_in_schema,\n                content_type=content_type,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def include_router(self, router: \"APIRouter\", *, prefix: str = \"\") -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=route.tags or [],\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    include_in_schema=route.include_in_schema,\n                    content_type=route.content_type,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=route.methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n", "fix_code": "import asyncio\nimport inspect\nimport logging\nfrom typing import Any, Callable, List, Optional, Type\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import get_body_field, get_dependant, solve_dependencies\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseConfig, BaseModel, Schema\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import Field\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.formparsers import UploadFile\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import get_name, request_response\nfrom starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n\n\ndef serialize_response(*, field: Field = None, response: Response) -> Any:\n    if field:\n        errors = []\n        value, errors_ = field.validate(response, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors)\n        return jsonable_encoder(value)\n    else:\n        return jsonable_encoder(response)\n\n\ndef get_app(\n    dependant: Dependant,\n    body_field: Field = None,\n    status_code: int = 200,\n    content_type: Type[Response] = JSONResponse,\n    response_field: Field = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must me a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    raw_body = await request.form()\n                    form_fields = {}\n                    for field, value in raw_body.items():\n                        if isinstance(value, UploadFile):\n                            form_fields[field] = await value.read()\n                        else:\n                            form_fields[field] = value\n                    if form_fields:\n                        body = form_fields\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logging.error(\"Error getting request body\", e)\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            )\n        values, errors = await solve_dependencies(\n            request=request, dependant=dependant, body=body\n        )\n        if errors:\n            errors_out = ValidationError(errors)\n            raise HTTPException(\n                status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=errors_out.errors()\n            )\n        else:\n            assert dependant.call is not None, \"dependant.call must me a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                return raw_response\n            if isinstance(raw_response, BaseModel):\n                return content_type(\n                    content=serialize_response(\n                        field=response_field, response=raw_response\n                    ),\n                    status_code=status_code,\n                )\n            errors = []\n            try:\n                return content_type(\n                    content=serialize_response(\n                        field=response_field, response=raw_response\n                    ),\n                    status_code=status_code,\n                )\n            except Exception as e:\n                errors.append(e)\n            try:\n                response = dict(raw_response)\n                return content_type(\n                    content=serialize_response(field=response_field, response=response),\n                    status_code=status_code,\n                )\n            except Exception as e:\n                errors.append(e)\n            try:\n                response = vars(raw_response)\n                return content_type(\n                    content=serialize_response(field=response_field, response=response),\n                    status_code=status_code,\n                )\n            except Exception as e:\n                errors.append(e)\n                raise ValueError(errors)\n\n    return app\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        name: str = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must always start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.response_model = response_model\n        if self.response_model:\n            assert lenient_issubclass(\n                content_type, JSONResponse\n            ), \"To declare a type the response must be a JSON response\"\n            response_name = \"Response_\" + self.name\n            self.response_field: Optional[Field] = Field(\n                name=response_name,\n                type_=self.response_model,\n                class_validators=[],\n                default=None,\n                required=False,\n                model_config=BaseConfig(),\n                schema=Schema(None),\n            )\n        else:\n            self.response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        self.summary = summary\n        self.description = description or self.endpoint.__doc__\n        self.response_description = response_description\n        self.deprecated = deprecated\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = methods\n        self.operation_id = operation_id\n        self.include_in_schema = include_in_schema\n        self.content_type = content_type\n\n        self.path_regex, self.path_format, self.param_convertors = self.compile_path(\n            path\n        )\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.body_field = get_body_field(dependant=self.dependant, name=self.name)\n        self.app = request_response(\n            get_app(\n                dependant=self.dependant,\n                body_field=self.body_field,\n                status_code=self.status_code,\n                content_type=self.content_type,\n                response_field=self.response_field,\n            )\n        )\n\n\nclass APIRouter(routing.Router):\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> None:\n        route = APIRoute(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                include_in_schema=include_in_schema,\n                content_type=content_type,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def include_router(self, router: \"APIRouter\", *, prefix: str = \"\") -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=route.tags or [],\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    include_in_schema=route.include_in_schema,\n                    content_type=route.content_type,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=route.methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        content_type: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            content_type=content_type,\n            name=name,\n        )\n", "diff": "@@ -53,14 +53,14 @@ def get_app(\n             if body_field:\n                 if is_body_form:\n                     raw_body = await request.form()\n-                    body = {}\n+                    form_fields = {}\n                     for field, value in raw_body.items():\n                         if isinstance(value, UploadFile):\n-                            body[field] = await value.read()\n+                            form_fields[field] = await value.read()\n                         else:\n-                            body[field] = value\n-                    if not body:\n-                        body = None\n+                            form_fields[field] = value\n+                    if form_fields:\n+                        body = form_fields\n                 else:\n                     body_bytes = await request.body()\n                     if body_bytes:\n"}
{"commit_hash": "cfb65d0e15899f381474686464539c83c5511023", "issue_description": ":bug: Fix utility OAuth2PasswordRequestForm to use forms\n\nand be used as a dependency", "code_before": "from typing import List, Optional\n\nfrom fastapi.openapi.models import OAuth2 as OAuth2Model, OAuthFlows as OAuthFlowsModel\nfrom fastapi.security.base import SecurityBase\nfrom pydantic import BaseModel, Schema\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.status import HTTP_403_FORBIDDEN\n\n\nclass OAuth2PasswordRequestData(BaseModel):\n    grant_type: str = \"password\"\n    username: str\n    password: str\n    scope: Optional[List[str]] = None\n    # Client ID and secret might come from headers\n    client_id: Optional[str] = None\n    client_secret: Optional[str] = None\n\n\nclass OAuth2PasswordRequestForm(BaseModel):\n    \"\"\"\n    This is not a \"Security\" model. Use it as request Body. As in:\n\n        @app.post(\"/login\")\n        def login(form_data: Oauth2PasswordRequestForm):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scope:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n    \n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        Nevertheless, this model is permissive and allows not passing it. If you want to enforce it,\n        use instead the OAuth2PasswordRequestFormStrict model.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \n\n    It has the method parse() that returns a model with all the same data and the scopes extracted as a list of strings.\n    \"\"\"\n\n    grant_type: str = Schema(None, regex=\"password\")\n    username: str\n    password: str\n    scope: str = \"\"\n    # Client ID and secret might come from headers\n    client_id: Optional[str] = None\n    client_secret: Optional[str] = None\n\n    def parse(self) -> OAuth2PasswordRequestData:\n        return OAuth2PasswordRequestData(\n            grant_type=self.grant_type,\n            username=self.username,\n            password=self.password,\n            scope=self.scope.split(),\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n        )\n\n\nclass OAuth2PasswordRequestFormStrict(OAuth2PasswordRequestForm):\n    # The OAuth2 spec says it MUST have the value \"password\"\n    grant_type: str = Schema(..., regex=\"password\")\n\n\nclass OAuth2(SecurityBase):\n    def __init__(\n        self, *, flows: OAuthFlowsModel = OAuthFlowsModel(), scheme_name: str = None\n    ):\n        self.model = OAuth2Model(flows=flows)\n        self.scheme_name = scheme_name or self.__class__.__name__\n\n    async def __call__(self, request: Request) -> str:\n        return request.headers.get(\"Authorization\")\n\n\nclass OAuth2PasswordBearer(OAuth2):\n    def __init__(self, tokenUrl: str, scheme_name: str = None, scopes: dict = None):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(password={\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        super().__init__(flows=flows, scheme_name=scheme_name)\n\n    async def __call__(self, request: Request) -> str:\n        authorization: str = request.headers.get(\"Authorization\")\n        if not authorization or \"Bearer \" not in authorization:\n            raise HTTPException(\n                status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n            )\n        token = authorization.replace(\"Bearer \", \"\")\n        return token\n", "fix_code": "from typing import List, Optional\n\nfrom fastapi.openapi.models import OAuth2 as OAuth2Model, OAuthFlows as OAuthFlowsModel\nfrom fastapi.params import Form\nfrom fastapi.security.base import SecurityBase\nfrom pydantic import BaseModel, Schema\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.status import HTTP_403_FORBIDDEN\n\n\nclass OAuth2PasswordRequestData(BaseModel):\n    grant_type: str = \"password\"\n    username: str\n    password: str\n    scope: Optional[List[str]] = None\n    # Client ID and secret might come from headers\n    client_id: Optional[str] = None\n    client_secret: Optional[str] = None\n\n\nclass OAuth2PasswordRequestForm:\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: Oauth2PasswordRequestForm = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scope:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n    \n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        Nevertheless, this model is permissive and allows not passing it. If you want to enforce it,\n        use instead the OAuth2PasswordRequestFormStrict model.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \n\n    It has the method parse() that returns a model with all the same data and the scopes extracted as a list of strings.\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(None, regex=\"password\"),\n        username: str = Form(...),\n        password: str = Form(...),\n        scope: str = Form(\"\"),\n        client_id: Optional[str] = Form(None),\n        client_secret: Optional[str] = Form(None),\n    ):\n        self.grant_type = grant_type\n        self.username = username\n        self.password = password\n        self.scope = scope\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n    def parse(self) -> OAuth2PasswordRequestData:\n        return OAuth2PasswordRequestData(\n            grant_type=self.grant_type,\n            username=self.username,\n            password=self.password,\n            scope=self.scope.split(),\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n        )\n\n\nclass OAuth2PasswordRequestFormStrict(OAuth2PasswordRequestForm):\n    # The OAuth2 spec says it MUST have the value \"password\"\n    grant_type: str = Schema(..., regex=\"password\")\n\n\nclass OAuth2(SecurityBase):\n    def __init__(\n        self, *, flows: OAuthFlowsModel = OAuthFlowsModel(), scheme_name: str = None\n    ):\n        self.model = OAuth2Model(flows=flows)\n        self.scheme_name = scheme_name or self.__class__.__name__\n\n    async def __call__(self, request: Request) -> str:\n        return request.headers.get(\"Authorization\")\n\n\nclass OAuth2PasswordBearer(OAuth2):\n    def __init__(self, tokenUrl: str, scheme_name: str = None, scopes: dict = None):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(password={\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        super().__init__(flows=flows, scheme_name=scheme_name)\n\n    async def __call__(self, request: Request) -> str:\n        authorization: str = request.headers.get(\"Authorization\")\n        if not authorization or \"Bearer \" not in authorization:\n            raise HTTPException(\n                status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n            )\n        token = authorization.replace(\"Bearer \", \"\")\n        return token\n", "diff": "@@ -1,6 +1,7 @@\n from typing import List, Optional\n \n from fastapi.openapi.models import OAuth2 as OAuth2Model, OAuthFlows as OAuthFlowsModel\n+from fastapi.params import Form\n from fastapi.security.base import SecurityBase\n from pydantic import BaseModel, Schema\n from starlette.exceptions import HTTPException\n@@ -18,12 +19,12 @@ class OAuth2PasswordRequestData(BaseModel):\n     client_secret: Optional[str] = None\n \n \n-class OAuth2PasswordRequestForm(BaseModel):\n+class OAuth2PasswordRequestForm:\n     \"\"\"\n-    This is not a \"Security\" model. Use it as request Body. As in:\n+    This is a dependency class, use it like:\n \n         @app.post(\"/login\")\n-        def login(form_data: Oauth2PasswordRequestForm):\n+        def login(form_data: Oauth2PasswordRequestForm = Depends()):\n             data = form_data.parse()\n             print(data.username)\n             print(data.password)\n@@ -54,13 +55,21 @@ class OAuth2PasswordRequestForm(BaseModel):\n     It has the method parse() that returns a model with all the same data and the scopes extracted as a list of strings.\n     \"\"\"\n \n-    grant_type: str = Schema(None, regex=\"password\")\n-    username: str\n-    password: str\n-    scope: str = \"\"\n-    # Client ID and secret might come from headers\n-    client_id: Optional[str] = None\n-    client_secret: Optional[str] = None\n+    def __init__(\n+        self,\n+        grant_type: str = Form(None, regex=\"password\"),\n+        username: str = Form(...),\n+        password: str = Form(...),\n+        scope: str = Form(\"\"),\n+        client_id: Optional[str] = Form(None),\n+        client_secret: Optional[str] = Form(None),\n+    ):\n+        self.grant_type = grant_type\n+        self.username = username\n+        self.password = password\n+        self.scope = scope\n+        self.client_id = client_id\n+        self.client_secret = client_secret\n \n     def parse(self) -> OAuth2PasswordRequestData:\n         return OAuth2PasswordRequestData(\n"}
{"commit_hash": "bc3e7f2bbc9acfcf8b6fd57854b68e1ac8a9c560", "issue_description": ":bookmark: Version bump, fixing several issues, lots of docs and tests", "code_before": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.12\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "fix_code": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.13\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "diff": "@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.1.12\"\n+__version__ = \"0.1.13\"\n \n from .applications import FastAPI\n from .routing import APIRouter\n"}
{"commit_hash": "5278314f2fbf95d711e94e14e2a5c8becde7e841", "issue_description": ":bookmark: Bump version, new security features and bug fixes", "code_before": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.14\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "fix_code": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.15\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "diff": "@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.1.14\"\n+__version__ = \"0.1.15\"\n \n from .applications import FastAPI\n from .routing import APIRouter\n"}
{"commit_hash": "ca0652aebf3a1e0b67def32c7c76624cca442c74", "issue_description": ":bug: Fix type checks for Python 3.7", "code_before": "import asyncio\nimport inspect\nfrom copy import deepcopy\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal\nfrom typing import Any, Callable, Dict, List, Mapping, Sequence, Tuple, Type, Union\nfrom uuid import UUID\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant, SecurityRequirement\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.utils import get_path_param_names\nfrom pydantic import BaseConfig, Schema, create_model\nfrom pydantic.error_wrappers import ErrorWrapper\nfrom pydantic.errors import MissingError\nfrom pydantic.fields import Field, Required, Shape\nfrom pydantic.schema import get_annotation_from_schema\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.requests import Headers, QueryParams, Request\n\nparam_supported_types = (\n    str,\n    int,\n    float,\n    bool,\n    UUID,\n    date,\n    datetime,\n    time,\n    timedelta,\n    Decimal,\n)\n\n\ndef get_sub_dependant(*, param: inspect.Parameter, path: str) -> Dependant:\n    depends: params.Depends = param.default\n    if depends.dependency:\n        dependency = depends.dependency\n    else:\n        dependency = param.annotation\n    sub_dependant = get_dependant(path=path, call=dependency, name=param.name)\n    if isinstance(depends, params.Security) and isinstance(dependency, SecurityBase):\n        security_requirement = SecurityRequirement(\n            security_scheme=dependency, scopes=depends.scopes\n        )\n        sub_dependant.security_requirements.append(security_requirement)\n    return sub_dependant\n\n\ndef get_flat_dependant(dependant: Dependant) -> Dependant:\n    flat_dependant = Dependant(\n        path_params=dependant.path_params.copy(),\n        query_params=dependant.query_params.copy(),\n        header_params=dependant.header_params.copy(),\n        cookie_params=dependant.cookie_params.copy(),\n        body_params=dependant.body_params.copy(),\n        security_schemes=dependant.security_requirements.copy(),\n    )\n    for sub_dependant in dependant.dependencies:\n        flat_sub = get_flat_dependant(sub_dependant)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant\n\n\ndef get_dependant(*, path: str, call: Callable, name: str = None) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = inspect.signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name)\n    for param_name in signature_params:\n        param = signature_params[param_name]\n        if isinstance(param.default, params.Depends):\n            sub_dependant = get_sub_dependant(param=param, path=path)\n            dependant.dependencies.append(sub_dependant)\n    for param_name in signature_params:\n        param = signature_params[param_name]\n        if (\n            (param.default == param.empty) or isinstance(param.default, params.Path)\n        ) and (param_name in path_param_names):\n            assert (\n                lenient_issubclass(param.annotation, param_supported_types)\n                or param.annotation == param.empty\n            ), f\"Path params must be of one of the supported types\"\n            param = signature_params[param_name]\n            add_param_to_fields(\n                param=param,\n                dependant=dependant,\n                default_schema=params.Path,\n                force_type=params.ParamTypes.path,\n            )\n        elif (\n            param.default == param.empty\n            or param.default is None\n            or isinstance(param.default, param_supported_types)\n        ) and (\n            param.annotation == param.empty\n            or lenient_issubclass(param.annotation, param_supported_types)\n        ):\n            add_param_to_fields(\n                param=param, dependant=dependant, default_schema=params.Query\n            )\n        elif isinstance(param.default, params.Param):\n            if param.annotation != param.empty:\n                assert lenient_issubclass(\n                    param.annotation, param_supported_types + (list, tuple, set)\n                ), f\"Parameters for Path, Query, Header and Cookies must be of type str, int, float, bool, list, tuple or set: {param}\"\n            add_param_to_fields(\n                param=param, dependant=dependant, default_schema=params.Query\n            )\n        elif lenient_issubclass(param.annotation, Request):\n            dependant.request_param_name = param_name\n        elif not isinstance(param.default, params.Depends):\n            add_param_to_body_fields(param=param, dependant=dependant)\n    return dependant\n\n\ndef add_param_to_fields(\n    *,\n    param: inspect.Parameter,\n    dependant: Dependant,\n    default_schema: Type[Schema] = params.Param,\n    force_type: params.ParamTypes = None,\n) -> None:\n    default_value = Required\n    if not param.default == param.empty:\n        default_value = param.default\n    if isinstance(default_value, params.Param):\n        schema = default_value\n        default_value = schema.default\n        if getattr(schema, \"in_\", None) is None:\n            schema.in_ = default_schema.in_\n        if force_type:\n            schema.in_ = force_type\n    else:\n        schema = default_schema(default_value)\n    required = default_value == Required\n    annotation: Any = Any\n    if not param.annotation == param.empty:\n        annotation = param.annotation\n    annotation = get_annotation_from_schema(annotation, schema)\n    if not schema.alias and getattr(schema, \"convert_underscores\", None):\n        alias = param.name.replace(\"_\", \"-\")\n    else:\n        alias = schema.alias or param.name\n    field = Field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=alias,\n        required=required,\n        model_config=BaseConfig(),\n        class_validators=[],\n        schema=schema,\n    )\n    if schema.in_ == params.ParamTypes.path:\n        dependant.path_params.append(field)\n    elif schema.in_ == params.ParamTypes.query:\n        dependant.query_params.append(field)\n    elif schema.in_ == params.ParamTypes.header:\n        dependant.header_params.append(field)\n    else:\n        assert (\n            schema.in_ == params.ParamTypes.cookie\n        ), f\"non-body parameters must be in path, query, header or cookie: {param.name}\"\n        dependant.cookie_params.append(field)\n\n\ndef add_param_to_body_fields(*, param: inspect.Parameter, dependant: Dependant) -> None:\n    default_value = Required\n    if not param.default == param.empty:\n        default_value = param.default\n    if isinstance(default_value, Schema):\n        schema = default_value\n        default_value = schema.default\n    else:\n        schema = Schema(default_value)\n    required = default_value == Required\n    annotation = get_annotation_from_schema(param.annotation, schema)\n    field = Field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=schema.alias or param.name,\n        required=required,\n        model_config=BaseConfig,\n        class_validators=[],\n        schema=schema,\n    )\n    dependant.body_params.append(field)\n\n\ndef is_coroutine_callable(call: Callable) -> bool:\n    if inspect.isfunction(call):\n        return asyncio.iscoroutinefunction(call)\n    if inspect.isclass(call):\n        return False\n    call = getattr(call, \"__call__\", None)\n    return asyncio.iscoroutinefunction(call)\n\n\nasync def solve_dependencies(\n    *, request: Request, dependant: Dependant, body: Dict[str, Any] = None\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values: Dict[str, Any] = {}\n    errors: List[ErrorWrapper] = []\n    for sub_dependant in dependant.dependencies:\n        sub_values, sub_errors = await solve_dependencies(\n            request=request, dependant=sub_dependant, body=body\n        )\n        if sub_errors:\n            errors.extend(sub_errors)\n            continue\n        assert sub_dependant.call is not None, \"sub_dependant.call must be a function\"\n        if is_coroutine_callable(sub_dependant.call):\n            solved = await sub_dependant.call(**sub_values)\n        else:\n            solved = await run_in_threadpool(sub_dependant.call, **sub_values)\n        assert sub_dependant.name is not None, \"Subdependants always have a name\"\n        values[sub_dependant.name] = solved\n    path_values, path_errors = request_params_to_args(\n        dependant.path_params, request.path_params\n    )\n    query_values, query_errors = request_params_to_args(\n        dependant.query_params, request.query_params\n    )\n    header_values, header_errors = request_params_to_args(\n        dependant.header_params, request.headers\n    )\n    cookie_values, cookie_errors = request_params_to_args(\n        dependant.cookie_params, request.cookies\n    )\n    values.update(path_values)\n    values.update(query_values)\n    values.update(header_values)\n    values.update(cookie_values)\n    errors += path_errors + query_errors + header_errors + cookie_errors\n    if dependant.body_params:\n        body_values, body_errors = await request_body_to_args(  # type: ignore # body_params checked above\n            dependant.body_params, body\n        )\n        values.update(body_values)\n        errors.extend(body_errors)\n    if dependant.request_param_name:\n        values[dependant.request_param_name] = request\n    return values, errors\n\n\ndef request_params_to_args(\n    required_params: Sequence[Field],\n    received_params: Union[Mapping[str, Any], QueryParams, Headers],\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    for field in required_params:\n        if field.shape in {Shape.LIST, Shape.SET, Shape.TUPLE} and isinstance(\n            received_params, (QueryParams, Headers)\n        ):\n            value = received_params.getlist(field.alias)\n        else:\n            value = received_params.get(field.alias)\n        schema: params.Param = field.schema\n        assert isinstance(schema, params.Param), \"Params must be subclasses of Param\"\n        if value is None:\n            if field.required:\n                errors.append(\n                    ErrorWrapper(\n                        MissingError(),\n                        loc=(schema.in_.value, field.alias),\n                        config=BaseConfig,\n                    )\n                )\n            else:\n                values[field.name] = deepcopy(field.default)\n            continue\n        v_, errors_ = field.validate(value, values, loc=(schema.in_.value, field.alias))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        else:\n            values[field.name] = v_\n    return values, errors\n\n\nasync def request_body_to_args(\n    required_params: List[Field], received_body: Dict[str, Any]\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    if required_params:\n        field = required_params[0]\n        embed = getattr(field.schema, \"embed\", None)\n        if len(required_params) == 1 and not embed:\n            received_body = {field.alias: received_body}\n        elif received_body is None:\n            received_body = {}\n        for field in required_params:\n            value = received_body.get(field.alias)\n            if value is None or (isinstance(field.schema, params.Form) and value == \"\"):\n                if field.required:\n                    errors.append(\n                        ErrorWrapper(\n                            MissingError(), loc=(\"body\", field.alias), config=BaseConfig\n                        )\n                    )\n                else:\n                    values[field.name] = deepcopy(field.default)\n                continue\n            v_, errors_ = field.validate(value, values, loc=(\"body\", field.alias))\n            if isinstance(errors_, ErrorWrapper):\n                errors.append(errors_)\n            elif isinstance(errors_, list):\n                errors.extend(errors_)\n            else:\n                values[field.name] = v_\n    return values, errors\n\n\ndef get_body_field(*, dependant: Dependant, name: str) -> Field:\n    flat_dependant = get_flat_dependant(dependant)\n    if not flat_dependant.body_params:\n        return None\n    first_param = flat_dependant.body_params[0]\n    embed = getattr(first_param.schema, \"embed\", None)\n    if len(flat_dependant.body_params) == 1 and not embed:\n        return first_param\n    model_name = \"Body_\" + name\n    BodyModel = create_model(model_name)\n    for f in flat_dependant.body_params:\n        BodyModel.__fields__[f.name] = f\n    required = any(True for f in flat_dependant.body_params if f.required)\n    if any(isinstance(f.schema, params.File) for f in flat_dependant.body_params):\n        BodySchema: Type[params.Body] = params.File\n    elif any(isinstance(f.schema, params.Form) for f in flat_dependant.body_params):\n        BodySchema = params.Form\n    else:\n        BodySchema = params.Body\n\n    field = Field(\n        name=\"body\",\n        type_=BodyModel,\n        default=None,\n        required=required,\n        model_config=BaseConfig,\n        class_validators=[],\n        alias=\"body\",\n        schema=BodySchema(None),\n    )\n    return field\n", "fix_code": "import asyncio\nimport inspect\nfrom copy import deepcopy\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal\nfrom typing import Any, Callable, Dict, List, Mapping, Sequence, Set, Tuple, Type, Union\nfrom uuid import UUID\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant, SecurityRequirement\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.utils import get_path_param_names\nfrom pydantic import BaseConfig, Schema, create_model\nfrom pydantic.error_wrappers import ErrorWrapper\nfrom pydantic.errors import MissingError\nfrom pydantic.fields import Field, Required, Shape\nfrom pydantic.schema import get_annotation_from_schema\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.requests import Headers, QueryParams, Request\n\nparam_supported_types = (\n    str,\n    int,\n    float,\n    bool,\n    UUID,\n    date,\n    datetime,\n    time,\n    timedelta,\n    Decimal,\n)\n\n\ndef get_sub_dependant(*, param: inspect.Parameter, path: str) -> Dependant:\n    depends: params.Depends = param.default\n    if depends.dependency:\n        dependency = depends.dependency\n    else:\n        dependency = param.annotation\n    sub_dependant = get_dependant(path=path, call=dependency, name=param.name)\n    if isinstance(depends, params.Security) and isinstance(dependency, SecurityBase):\n        security_requirement = SecurityRequirement(\n            security_scheme=dependency, scopes=depends.scopes\n        )\n        sub_dependant.security_requirements.append(security_requirement)\n    return sub_dependant\n\n\ndef get_flat_dependant(dependant: Dependant) -> Dependant:\n    flat_dependant = Dependant(\n        path_params=dependant.path_params.copy(),\n        query_params=dependant.query_params.copy(),\n        header_params=dependant.header_params.copy(),\n        cookie_params=dependant.cookie_params.copy(),\n        body_params=dependant.body_params.copy(),\n        security_schemes=dependant.security_requirements.copy(),\n    )\n    for sub_dependant in dependant.dependencies:\n        flat_sub = get_flat_dependant(sub_dependant)\n        flat_dependant.path_params.extend(flat_sub.path_params)\n        flat_dependant.query_params.extend(flat_sub.query_params)\n        flat_dependant.header_params.extend(flat_sub.header_params)\n        flat_dependant.cookie_params.extend(flat_sub.cookie_params)\n        flat_dependant.body_params.extend(flat_sub.body_params)\n        flat_dependant.security_requirements.extend(flat_sub.security_requirements)\n    return flat_dependant\n\n\ndef get_dependant(*, path: str, call: Callable, name: str = None) -> Dependant:\n    path_param_names = get_path_param_names(path)\n    endpoint_signature = inspect.signature(call)\n    signature_params = endpoint_signature.parameters\n    dependant = Dependant(call=call, name=name)\n    for param_name in signature_params:\n        param = signature_params[param_name]\n        if isinstance(param.default, params.Depends):\n            sub_dependant = get_sub_dependant(param=param, path=path)\n            dependant.dependencies.append(sub_dependant)\n    for param_name in signature_params:\n        param = signature_params[param_name]\n        if (\n            (param.default == param.empty) or isinstance(param.default, params.Path)\n        ) and (param_name in path_param_names):\n            assert (\n                lenient_issubclass(param.annotation, param_supported_types)\n                or param.annotation == param.empty\n            ), f\"Path params must be of one of the supported types\"\n            param = signature_params[param_name]\n            add_param_to_fields(\n                param=param,\n                dependant=dependant,\n                default_schema=params.Path,\n                force_type=params.ParamTypes.path,\n            )\n        elif (\n            param.default == param.empty\n            or param.default is None\n            or isinstance(param.default, param_supported_types)\n        ) and (\n            param.annotation == param.empty\n            or lenient_issubclass(param.annotation, param_supported_types)\n        ):\n            add_param_to_fields(\n                param=param, dependant=dependant, default_schema=params.Query\n            )\n        elif isinstance(param.default, params.Param):\n            if param.annotation != param.empty:\n                assert lenient_issubclass(\n                    param.annotation,\n                    param_supported_types + (List, Tuple, Set, list, tuple, set),\n                ), f\"Parameters for Path, Query, Header and Cookies must be of type str, int, float, bool, list, tuple or set: {param}\"\n            add_param_to_fields(\n                param=param, dependant=dependant, default_schema=params.Query\n            )\n        elif lenient_issubclass(param.annotation, Request):\n            dependant.request_param_name = param_name\n        elif not isinstance(param.default, params.Depends):\n            add_param_to_body_fields(param=param, dependant=dependant)\n    return dependant\n\n\ndef add_param_to_fields(\n    *,\n    param: inspect.Parameter,\n    dependant: Dependant,\n    default_schema: Type[Schema] = params.Param,\n    force_type: params.ParamTypes = None,\n) -> None:\n    default_value = Required\n    if not param.default == param.empty:\n        default_value = param.default\n    if isinstance(default_value, params.Param):\n        schema = default_value\n        default_value = schema.default\n        if getattr(schema, \"in_\", None) is None:\n            schema.in_ = default_schema.in_\n        if force_type:\n            schema.in_ = force_type\n    else:\n        schema = default_schema(default_value)\n    required = default_value == Required\n    annotation: Any = Any\n    if not param.annotation == param.empty:\n        annotation = param.annotation\n    annotation = get_annotation_from_schema(annotation, schema)\n    if not schema.alias and getattr(schema, \"convert_underscores\", None):\n        alias = param.name.replace(\"_\", \"-\")\n    else:\n        alias = schema.alias or param.name\n    field = Field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=alias,\n        required=required,\n        model_config=BaseConfig(),\n        class_validators=[],\n        schema=schema,\n    )\n    if schema.in_ == params.ParamTypes.path:\n        dependant.path_params.append(field)\n    elif schema.in_ == params.ParamTypes.query:\n        dependant.query_params.append(field)\n    elif schema.in_ == params.ParamTypes.header:\n        dependant.header_params.append(field)\n    else:\n        assert (\n            schema.in_ == params.ParamTypes.cookie\n        ), f\"non-body parameters must be in path, query, header or cookie: {param.name}\"\n        dependant.cookie_params.append(field)\n\n\ndef add_param_to_body_fields(*, param: inspect.Parameter, dependant: Dependant) -> None:\n    default_value = Required\n    if not param.default == param.empty:\n        default_value = param.default\n    if isinstance(default_value, Schema):\n        schema = default_value\n        default_value = schema.default\n    else:\n        schema = Schema(default_value)\n    required = default_value == Required\n    annotation = get_annotation_from_schema(param.annotation, schema)\n    field = Field(\n        name=param.name,\n        type_=annotation,\n        default=None if required else default_value,\n        alias=schema.alias or param.name,\n        required=required,\n        model_config=BaseConfig,\n        class_validators=[],\n        schema=schema,\n    )\n    dependant.body_params.append(field)\n\n\ndef is_coroutine_callable(call: Callable) -> bool:\n    if inspect.isfunction(call):\n        return asyncio.iscoroutinefunction(call)\n    if inspect.isclass(call):\n        return False\n    call = getattr(call, \"__call__\", None)\n    return asyncio.iscoroutinefunction(call)\n\n\nasync def solve_dependencies(\n    *, request: Request, dependant: Dependant, body: Dict[str, Any] = None\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values: Dict[str, Any] = {}\n    errors: List[ErrorWrapper] = []\n    for sub_dependant in dependant.dependencies:\n        sub_values, sub_errors = await solve_dependencies(\n            request=request, dependant=sub_dependant, body=body\n        )\n        if sub_errors:\n            errors.extend(sub_errors)\n            continue\n        assert sub_dependant.call is not None, \"sub_dependant.call must be a function\"\n        if is_coroutine_callable(sub_dependant.call):\n            solved = await sub_dependant.call(**sub_values)\n        else:\n            solved = await run_in_threadpool(sub_dependant.call, **sub_values)\n        assert sub_dependant.name is not None, \"Subdependants always have a name\"\n        values[sub_dependant.name] = solved\n    path_values, path_errors = request_params_to_args(\n        dependant.path_params, request.path_params\n    )\n    query_values, query_errors = request_params_to_args(\n        dependant.query_params, request.query_params\n    )\n    header_values, header_errors = request_params_to_args(\n        dependant.header_params, request.headers\n    )\n    cookie_values, cookie_errors = request_params_to_args(\n        dependant.cookie_params, request.cookies\n    )\n    values.update(path_values)\n    values.update(query_values)\n    values.update(header_values)\n    values.update(cookie_values)\n    errors += path_errors + query_errors + header_errors + cookie_errors\n    if dependant.body_params:\n        body_values, body_errors = await request_body_to_args(  # type: ignore # body_params checked above\n            dependant.body_params, body\n        )\n        values.update(body_values)\n        errors.extend(body_errors)\n    if dependant.request_param_name:\n        values[dependant.request_param_name] = request\n    return values, errors\n\n\ndef request_params_to_args(\n    required_params: Sequence[Field],\n    received_params: Union[Mapping[str, Any], QueryParams, Headers],\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    for field in required_params:\n        if field.shape in {Shape.LIST, Shape.SET, Shape.TUPLE} and isinstance(\n            received_params, (QueryParams, Headers)\n        ):\n            value = received_params.getlist(field.alias)\n        else:\n            value = received_params.get(field.alias)\n        schema: params.Param = field.schema\n        assert isinstance(schema, params.Param), \"Params must be subclasses of Param\"\n        if value is None:\n            if field.required:\n                errors.append(\n                    ErrorWrapper(\n                        MissingError(),\n                        loc=(schema.in_.value, field.alias),\n                        config=BaseConfig,\n                    )\n                )\n            else:\n                values[field.name] = deepcopy(field.default)\n            continue\n        v_, errors_ = field.validate(value, values, loc=(schema.in_.value, field.alias))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        else:\n            values[field.name] = v_\n    return values, errors\n\n\nasync def request_body_to_args(\n    required_params: List[Field], received_body: Dict[str, Any]\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    values = {}\n    errors = []\n    if required_params:\n        field = required_params[0]\n        embed = getattr(field.schema, \"embed\", None)\n        if len(required_params) == 1 and not embed:\n            received_body = {field.alias: received_body}\n        elif received_body is None:\n            received_body = {}\n        for field in required_params:\n            value = received_body.get(field.alias)\n            if value is None or (isinstance(field.schema, params.Form) and value == \"\"):\n                if field.required:\n                    errors.append(\n                        ErrorWrapper(\n                            MissingError(), loc=(\"body\", field.alias), config=BaseConfig\n                        )\n                    )\n                else:\n                    values[field.name] = deepcopy(field.default)\n                continue\n            v_, errors_ = field.validate(value, values, loc=(\"body\", field.alias))\n            if isinstance(errors_, ErrorWrapper):\n                errors.append(errors_)\n            elif isinstance(errors_, list):\n                errors.extend(errors_)\n            else:\n                values[field.name] = v_\n    return values, errors\n\n\ndef get_body_field(*, dependant: Dependant, name: str) -> Field:\n    flat_dependant = get_flat_dependant(dependant)\n    if not flat_dependant.body_params:\n        return None\n    first_param = flat_dependant.body_params[0]\n    embed = getattr(first_param.schema, \"embed\", None)\n    if len(flat_dependant.body_params) == 1 and not embed:\n        return first_param\n    model_name = \"Body_\" + name\n    BodyModel = create_model(model_name)\n    for f in flat_dependant.body_params:\n        BodyModel.__fields__[f.name] = f\n    required = any(True for f in flat_dependant.body_params if f.required)\n    if any(isinstance(f.schema, params.File) for f in flat_dependant.body_params):\n        BodySchema: Type[params.Body] = params.File\n    elif any(isinstance(f.schema, params.Form) for f in flat_dependant.body_params):\n        BodySchema = params.Form\n    else:\n        BodySchema = params.Body\n\n    field = Field(\n        name=\"body\",\n        type_=BodyModel,\n        default=None,\n        required=required,\n        model_config=BaseConfig,\n        class_validators=[],\n        alias=\"body\",\n        schema=BodySchema(None),\n    )\n    return field\n", "diff": "@@ -3,7 +3,7 @@ import inspect\n from copy import deepcopy\n from datetime import date, datetime, time, timedelta\n from decimal import Decimal\n-from typing import Any, Callable, Dict, List, Mapping, Sequence, Tuple, Type, Union\n+from typing import Any, Callable, Dict, List, Mapping, Sequence, Set, Tuple, Type, Union\n from uuid import UUID\n \n from fastapi import params\n@@ -108,7 +108,8 @@ def get_dependant(*, path: str, call: Callable, name: str = None) -> Dependant:\n         elif isinstance(param.default, params.Param):\n             if param.annotation != param.empty:\n                 assert lenient_issubclass(\n-                    param.annotation, param_supported_types + (list, tuple, set)\n+                    param.annotation,\n+                    param_supported_types + (List, Tuple, Set, list, tuple, set),\n                 ), f\"Parameters for Path, Query, Header and Cookies must be of type str, int, float, bool, list, tuple or set: {param}\"\n             add_param_to_fields(\n                 param=param, dependant=dependant, default_schema=params.Query\n"}
{"commit_hash": "3c08b05ea6b58b3e5564c026f071cbb0979a6797", "issue_description": ":bookmark: Bump version, after query and header as lists\n\nand bug fixes for Python 3.7", "code_before": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.15\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "fix_code": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.16\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "diff": "@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.1.15\"\n+__version__ = \"0.1.16\"\n \n from .applications import FastAPI\n from .routing import APIRouter\n"}
{"commit_hash": "e5b341c7ddbd085e7203276398bdf10a1d86446b", "issue_description": ":bookmark: Bump version after fix for constrained bytes", "code_before": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.16\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "fix_code": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.1.17\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "diff": "@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.1.16\"\n+__version__ = \"0.1.17\"\n \n from .applications import FastAPI\n from .routing import APIRouter\n"}
{"commit_hash": "acbcbba94f444e714fac8a522d7190904d6e3544", "issue_description": ":bookmark: Release 0.4.0 with openapi_prefix, #26", "code_before": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.3.0\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "fix_code": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.4.0\"\n\nfrom .applications import FastAPI\nfrom .routing import APIRouter\nfrom .params import Body, Path, Query, Header, Cookie, Form, File, Security, Depends\n", "diff": "@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.3.0\"\n+__version__ = \"0.4.0\"\n \n from .applications import FastAPI\n from .routing import APIRouter\n"}
{"commit_hash": "5a6e47bd495b7ee0bb2f4eb6dce570686c21c554", "issue_description": ":bookmark: Release 0.10.0: BackgroundTasks and websockets fix", "code_before": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.9.1\"\n\nfrom starlette.background import BackgroundTasks\n\nfrom .applications import FastAPI\nfrom .datastructures import UploadFile\nfrom .exceptions import HTTPException\nfrom .params import Body, Cookie, Depends, File, Form, Header, Path, Query, Security\nfrom .routing import APIRouter\n", "fix_code": "\"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n\n__version__ = \"0.10.0\"\n\nfrom starlette.background import BackgroundTasks\n\nfrom .applications import FastAPI\nfrom .datastructures import UploadFile\nfrom .exceptions import HTTPException\nfrom .params import Body, Cookie, Depends, File, Form, Header, Path, Query, Security\nfrom .routing import APIRouter\n", "diff": "@@ -1,6 +1,6 @@\n \"\"\"FastAPI framework, high performance, easy to learn, fast to code, ready for production\"\"\"\n \n-__version__ = \"0.9.1\"\n+__version__ = \"0.10.0\"\n \n from starlette.background import BackgroundTasks\n \n"}
{"commit_hash": "3ce2920fef29058507868798cc27404cd1bc555b", "issue_description": ":bug: fix name of shutdown_event in docs (#105)\n\nFix name copy/paste name error in docs source for startup/shutdown events.", "code_before": "from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.on_event(\"shutdown\")\ndef startup_event():\n    with open(\"log.txt\", mode=\"a\") as log:\n        log.write(\"Application shutdown\")\n\n\n@app.get(\"/items/\")\nasync def read_items():\n    return [{\"name\": \"Foo\"}]\n", "fix_code": "from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.on_event(\"shutdown\")\ndef shutdown_event():\n    with open(\"log.txt\", mode=\"a\") as log:\n        log.write(\"Application shutdown\")\n\n\n@app.get(\"/items/\")\nasync def read_items():\n    return [{\"name\": \"Foo\"}]\n", "diff": "@@ -4,7 +4,7 @@ app = FastAPI()\n \n \n @app.on_event(\"shutdown\")\n-def startup_event():\n+def shutdown_event():\n     with open(\"log.txt\", mode=\"a\") as log:\n         log.write(\"Application shutdown\")\n \n"}
{"commit_hash": "4a1648b04e74b5943f3ffadf92737f7d9c8201af", "issue_description": ":pencil2: Minor spelling fix in routing (#221)", "code_before": "import asyncio\nimport inspect\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Type, Union\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import get_body_field, get_dependant, solve_dependencies\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseConfig, BaseModel, Schema\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import Field\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import compile_path, get_name, request_response\nfrom starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n\n\ndef serialize_response(*, field: Field = None, response: Response) -> Any:\n    encoded = jsonable_encoder(response)\n    if field:\n        errors = []\n        value, errors_ = field.validate(encoded, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors)\n        return jsonable_encoder(value)\n    else:\n        return encoded\n\n\ndef get_app(\n    dependant: Dependant,\n    body_field: Field = None,\n    status_code: int = 200,\n    response_class: Type[Response] = JSONResponse,\n    response_field: Field = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must me a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logging.error(f\"Error getting request body: {e}\")\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            )\n        values, errors, background_tasks = await solve_dependencies(\n            request=request, dependant=dependant, body=body\n        )\n        if errors:\n            errors_out = ValidationError(errors)\n            raise HTTPException(\n                status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=errors_out.errors()\n            )\n        else:\n            assert dependant.call is not None, \"dependant.call must me a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = serialize_response(\n                field=response_field, response=raw_response\n            )\n            return response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,\n            )\n\n    return app\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        name: str = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must always start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.response_model = response_model\n        if self.response_model:\n            assert lenient_issubclass(\n                response_class, JSONResponse\n            ), \"To declare a type the response must be a JSON response\"\n            response_name = \"Response_\" + self.name\n            self.response_field: Optional[Field] = Field(\n                name=response_name,\n                type_=self.response_model,\n                class_validators={},\n                default=None,\n                required=False,\n                model_config=BaseConfig,\n                schema=Schema(None),\n            )\n        else:\n            self.response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert lenient_issubclass(\n                    model, BaseModel\n                ), \"A response model must be a Pydantic model\"\n                response_name = f\"Response_{additional_status_code}_{self.name}\"\n                response_field = Field(\n                    name=response_name,\n                    type_=model,\n                    class_validators=None,\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    schema=Schema(None),\n                )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], Field] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = methods\n        self.operation_id = operation_id\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.body_field = get_body_field(dependant=self.dependant, name=self.name)\n        self.app = request_response(\n            get_app(\n                dependant=self.dependant,\n                body_field=self.body_field,\n                status_code=self.status_code,\n                response_class=self.response_class,\n                response_field=self.response_field,\n            )\n        )\n\n\nclass APIRouter(routing.Router):\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> None:\n        route = APIRoute(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=(route.tags or []) + (tags or []),\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    include_in_schema=route.include_in_schema,\n                    response_class=route.response_class,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=route.methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n", "fix_code": "import asyncio\nimport inspect\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Type, Union\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import get_body_field, get_dependant, solve_dependencies\nfrom fastapi.encoders import jsonable_encoder\nfrom pydantic import BaseConfig, BaseModel, Schema\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import Field\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import compile_path, get_name, request_response\nfrom starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n\n\ndef serialize_response(*, field: Field = None, response: Response) -> Any:\n    encoded = jsonable_encoder(response)\n    if field:\n        errors = []\n        value, errors_ = field.validate(encoded, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors)\n        return jsonable_encoder(value)\n    else:\n        return encoded\n\n\ndef get_app(\n    dependant: Dependant,\n    body_field: Field = None,\n    status_code: int = 200,\n    response_class: Type[Response] = JSONResponse,\n    response_field: Field = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logging.error(f\"Error getting request body: {e}\")\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            )\n        values, errors, background_tasks = await solve_dependencies(\n            request=request, dependant=dependant, body=body\n        )\n        if errors:\n            errors_out = ValidationError(errors)\n            raise HTTPException(\n                status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=errors_out.errors()\n            )\n        else:\n            assert dependant.call is not None, \"dependant.call must be a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = serialize_response(\n                field=response_field, response=raw_response\n            )\n            return response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,\n            )\n\n    return app\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        name: str = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must always start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.response_model = response_model\n        if self.response_model:\n            assert lenient_issubclass(\n                response_class, JSONResponse\n            ), \"To declare a type the response must be a JSON response\"\n            response_name = \"Response_\" + self.name\n            self.response_field: Optional[Field] = Field(\n                name=response_name,\n                type_=self.response_model,\n                class_validators={},\n                default=None,\n                required=False,\n                model_config=BaseConfig,\n                schema=Schema(None),\n            )\n        else:\n            self.response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert lenient_issubclass(\n                    model, BaseModel\n                ), \"A response model must be a Pydantic model\"\n                response_name = f\"Response_{additional_status_code}_{self.name}\"\n                response_field = Field(\n                    name=response_name,\n                    type_=model,\n                    class_validators=None,\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    schema=Schema(None),\n                )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], Field] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = methods\n        self.operation_id = operation_id\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.body_field = get_body_field(dependant=self.dependant, name=self.name)\n        self.app = request_response(\n            get_app(\n                dependant=self.dependant,\n                body_field=self.body_field,\n                status_code=self.status_code,\n                response_class=self.response_class,\n                response_field=self.response_field,\n            )\n        )\n\n\nclass APIRouter(routing.Router):\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> None:\n        route = APIRoute(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=(route.tags or []) + (tags or []),\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    include_in_schema=route.include_in_schema,\n                    response_class=route.response_class,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=route.methods,\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[BaseModel] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n", "diff": "@@ -43,7 +43,7 @@ def get_app(\n     response_class: Type[Response] = JSONResponse,\n     response_field: Field = None,\n ) -> Callable:\n-    assert dependant.call is not None, \"dependant.call must me a function\"\n+    assert dependant.call is not None, \"dependant.call must be a function\"\n     is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n     is_body_form = body_field and isinstance(body_field.schema, params.Form)\n \n@@ -71,7 +71,7 @@ def get_app(\n                 status_code=HTTP_422_UNPROCESSABLE_ENTITY, detail=errors_out.errors()\n             )\n         else:\n-            assert dependant.call is not None, \"dependant.call must me a function\"\n+            assert dependant.call is not None, \"dependant.call must be a function\"\n             if is_coroutine:\n                 raw_response = await dependant.call(**values)\n             else:\n"}
{"commit_hash": "3ed112e8a93d1b6fdcdf3f9fe9e8df986114cc1c", "issue_description": ":bug: Fix type declaration of HTTPException (#279)", "code_before": "from pydantic import ValidationError\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\n\nclass HTTPException(StarletteHTTPException):\n    def __init__(\n        self, status_code: int, detail: str = None, headers: dict = None\n    ) -> None:\n        super().__init__(status_code=status_code, detail=detail)\n        self.headers = headers\n\n\nclass RequestValidationError(ValidationError):\n    pass\n\n\nclass WebSocketRequestValidationError(ValidationError):\n    pass\n", "fix_code": "from typing import Any\n\nfrom pydantic import ValidationError\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\n\nclass HTTPException(StarletteHTTPException):\n    def __init__(\n        self, status_code: int, detail: Any = None, headers: dict = None\n    ) -> None:\n        super().__init__(status_code=status_code, detail=detail)\n        self.headers = headers\n\n\nclass RequestValidationError(ValidationError):\n    pass\n\n\nclass WebSocketRequestValidationError(ValidationError):\n    pass\n", "diff": "@@ -1,10 +1,12 @@\n+from typing import Any\n+\n from pydantic import ValidationError\n from starlette.exceptions import HTTPException as StarletteHTTPException\n \n \n class HTTPException(StarletteHTTPException):\n     def __init__(\n-        self, status_code: int, detail: str = None, headers: dict = None\n+        self, status_code: int, detail: Any = None, headers: dict = None\n     ) -> None:\n         super().__init__(status_code=status_code, detail=detail)\n         self.headers = headers\n"}
{"commit_hash": "508f9ce9547972dc4feb997f53ce332716afee88", "issue_description": ":bug: Fix regression, Swagger UI with deep linking (#350)", "code_before": "from typing import Optional\n\nfrom starlette.responses import HTMLResponse\n\n\ndef get_swagger_ui_html(\n    *,\n    openapi_url: str,\n    title: str,\n    swagger_js_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui-bundle.js\",\n    swagger_css_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui.css\",\n    swagger_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Optional[str] = None,\n) -> HTMLResponse:\n\n    html = f\"\"\"\n    <! doctype html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n        dom_id: '#swagger-ui',\n        presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n        layout: \"BaseLayout\"\n    })\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_redoc_html(\n    *,\n    openapi_url: str,\n    title: str,\n    redoc_js_url: str = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n) -> HTMLResponse:\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    html = \"\"\"\n    <!doctype html>\n    <html lang=\"en-US\">\n    <body onload=\"run()\">\n    </body>\n    </html>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1);\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\")\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';})\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value)\n                    }\n            ) : {}\n\n            isValid = qp.state === sentState\n\n            if ((\n            oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n            oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n    </script>\n        \"\"\"\n    return HTMLResponse(content=html)\n", "fix_code": "from typing import Optional\n\nfrom starlette.responses import HTMLResponse\n\n\ndef get_swagger_ui_html(\n    *,\n    openapi_url: str,\n    title: str,\n    swagger_js_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui-bundle.js\",\n    swagger_css_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui.css\",\n    swagger_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Optional[str] = None,\n) -> HTMLResponse:\n\n    html = f\"\"\"\n    <! doctype html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n        dom_id: '#swagger-ui',\n        presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n        layout: \"BaseLayout\",\n        deepLinking: true\n    })\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_redoc_html(\n    *,\n    openapi_url: str,\n    title: str,\n    redoc_js_url: str = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n) -> HTMLResponse:\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    html = \"\"\"\n    <!doctype html>\n    <html lang=\"en-US\">\n    <body onload=\"run()\">\n    </body>\n    </html>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1);\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\")\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';})\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value)\n                    }\n            ) : {}\n\n            isValid = qp.state === sentState\n\n            if ((\n            oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n            oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n    </script>\n        \"\"\"\n    return HTMLResponse(content=html)\n", "diff": "@@ -40,7 +40,8 @@ def get_swagger_ui_html(\n         SwaggerUIBundle.presets.apis,\n         SwaggerUIBundle.SwaggerUIStandalonePreset\n         ],\n-        layout: \"BaseLayout\"\n+        layout: \"BaseLayout\",\n+        deepLinking: true\n     })\n     </script>\n     </body>\n"}
{"commit_hash": "0c5555332862a6927427ff3b4d51148ce3cc3ce9", "issue_description": ":pencil2: Fix typo in assert statement (#419)", "code_before": "import asyncio\nimport inspect\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Set, Type, Union\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    get_body_field,\n    get_dependant,\n    get_parameterless_sub_dependant,\n    solve_dependencies,\n)\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.utils import create_cloned_field, generate_operation_id_for_path\nfrom pydantic import BaseConfig, BaseModel, Schema\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import Field\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import (\n    compile_path,\n    get_name,\n    request_response,\n    websocket_session,\n)\nfrom starlette.status import WS_1008_POLICY_VIOLATION\nfrom starlette.types import ASGIApp\nfrom starlette.websockets import WebSocket\n\n\ndef serialize_response(\n    *,\n    field: Field = None,\n    response: Response,\n    include: Set[str] = None,\n    exclude: Set[str] = set(),\n    by_alias: bool = True,\n    skip_defaults: bool = False,\n) -> Any:\n    if field:\n        errors = []\n        value, errors_ = field.validate(response, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors)\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            skip_defaults=skip_defaults,\n        )\n    else:\n        return jsonable_encoder(response)\n\n\ndef get_app(\n    dependant: Dependant,\n    body_field: Field = None,\n    status_code: int = 200,\n    response_class: Type[Response] = JSONResponse,\n    response_field: Field = None,\n    response_model_include: Set[str] = None,\n    response_model_exclude: Set[str] = set(),\n    response_model_by_alias: bool = True,\n    response_model_skip_defaults: bool = False,\n    dependency_overrides_provider: Any = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logging.error(f\"Error getting request body: {e}\")\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors)\n        else:\n            assert dependant.call is not None, \"dependant.call must be a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = serialize_response(\n                field=response_field,\n                response=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                skip_defaults=response_model_skip_defaults,\n            )\n            response = response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,\n            )\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Any = None\n) -> Callable:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must me a function\"\n        await dependant.call(**values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        name: str = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n        )\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        name: str = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must always start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = set([method.upper() for method in methods])\n        self.unique_id = generate_operation_id_for_path(\n            name=self.name, path=self.path_format, method=list(methods)[0]\n        )\n        self.response_model = response_model\n        if self.response_model:\n            assert lenient_issubclass(\n                response_class, JSONResponse\n            ), \"To declare a type the response must be a JSON response\"\n            response_name = \"Response_\" + self.unique_id\n            self.response_field: Optional[Field] = Field(\n                name=response_name,\n                type_=self.response_model,\n                class_validators={},\n                default=None,\n                required=False,\n                model_config=BaseConfig,\n                schema=Schema(None),\n            )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will be always created.\n            self.secure_cloned_response_field: Optional[Field] = create_cloned_field(\n                self.response_field\n            )\n        else:\n            self.response_field = None\n            self.secure_cloned_response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        if dependencies:\n            self.dependencies = list(dependencies)\n        else:\n            self.dependencies = []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert lenient_issubclass(\n                    model, BaseModel\n                ), \"A response model must be a Pydantic model\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                response_field = Field(\n                    name=response_name,\n                    type_=model,\n                    class_validators=None,\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    schema=Schema(None),\n                )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], Field] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_skip_defaults = response_model_skip_defaults\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.app = request_response(\n            get_app(\n                dependant=self.dependant,\n                body_field=self.body_field,\n                status_code=self.status_code,\n                response_class=self.response_class,\n                response_field=self.secure_cloned_response_field,\n                response_model_include=self.response_model_include,\n                response_model_exclude=self.response_model_exclude,\n                response_model_by_alias=self.response_model_by_alias,\n                response_model_skip_defaults=self.response_model_skip_defaults,\n                dependency_overrides_provider=self.dependency_overrides_provider,\n            )\n        )\n\n\nclass APIRouter(routing.Router):\n    def __init__(\n        self,\n        routes: List[routing.BaseRoute] = None,\n        redirect_slashes: bool = True,\n        default: ASGIApp = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        super().__init__(\n            routes=routes, redirect_slashes=redirect_slashes, default=default\n        )\n        self.dependency_overrides_provider = dependency_overrides_provider\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> None:\n        route = APIRoute(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_skip_defaults=response_model_skip_defaults,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        route = APIWebSocketRoute(path, endpoint=endpoint, name=name)\n        self.routes.append(route)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=(route.tags or []) + (tags or []),\n                    dependencies=list(dependencies or [])\n                    + list(route.dependencies or []),\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_skip_defaults=route.response_model_skip_defaults,\n                    include_in_schema=route.include_in_schema,\n                    response_class=route.response_class,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=list(route.methods or []),\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n", "fix_code": "import asyncio\nimport inspect\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Set, Type, Union\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    get_body_field,\n    get_dependant,\n    get_parameterless_sub_dependant,\n    solve_dependencies,\n)\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.utils import create_cloned_field, generate_operation_id_for_path\nfrom pydantic import BaseConfig, BaseModel, Schema\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import Field\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import (\n    compile_path,\n    get_name,\n    request_response,\n    websocket_session,\n)\nfrom starlette.status import WS_1008_POLICY_VIOLATION\nfrom starlette.types import ASGIApp\nfrom starlette.websockets import WebSocket\n\n\ndef serialize_response(\n    *,\n    field: Field = None,\n    response: Response,\n    include: Set[str] = None,\n    exclude: Set[str] = set(),\n    by_alias: bool = True,\n    skip_defaults: bool = False,\n) -> Any:\n    if field:\n        errors = []\n        value, errors_ = field.validate(response, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors)\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            skip_defaults=skip_defaults,\n        )\n    else:\n        return jsonable_encoder(response)\n\n\ndef get_app(\n    dependant: Dependant,\n    body_field: Field = None,\n    status_code: int = 200,\n    response_class: Type[Response] = JSONResponse,\n    response_field: Field = None,\n    response_model_include: Set[str] = None,\n    response_model_exclude: Set[str] = set(),\n    response_model_by_alias: bool = True,\n    response_model_skip_defaults: bool = False,\n    dependency_overrides_provider: Any = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logging.error(f\"Error getting request body: {e}\")\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors)\n        else:\n            assert dependant.call is not None, \"dependant.call must be a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = serialize_response(\n                field=response_field,\n                response=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                skip_defaults=response_model_skip_defaults,\n            )\n            response = response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,\n            )\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Any = None\n) -> Callable:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        name: str = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n        )\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        name: str = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        assert path.startswith(\"/\"), \"Routed paths must always start with '/'\"\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = set([method.upper() for method in methods])\n        self.unique_id = generate_operation_id_for_path(\n            name=self.name, path=self.path_format, method=list(methods)[0]\n        )\n        self.response_model = response_model\n        if self.response_model:\n            assert lenient_issubclass(\n                response_class, JSONResponse\n            ), \"To declare a type the response must be a JSON response\"\n            response_name = \"Response_\" + self.unique_id\n            self.response_field: Optional[Field] = Field(\n                name=response_name,\n                type_=self.response_model,\n                class_validators={},\n                default=None,\n                required=False,\n                model_config=BaseConfig,\n                schema=Schema(None),\n            )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will be always created.\n            self.secure_cloned_response_field: Optional[Field] = create_cloned_field(\n                self.response_field\n            )\n        else:\n            self.response_field = None\n            self.secure_cloned_response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        if dependencies:\n            self.dependencies = list(dependencies)\n        else:\n            self.dependencies = []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert lenient_issubclass(\n                    model, BaseModel\n                ), \"A response model must be a Pydantic model\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                response_field = Field(\n                    name=response_name,\n                    type_=model,\n                    class_validators=None,\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    schema=Schema(None),\n                )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], Field] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_skip_defaults = response_model_skip_defaults\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.app = request_response(\n            get_app(\n                dependant=self.dependant,\n                body_field=self.body_field,\n                status_code=self.status_code,\n                response_class=self.response_class,\n                response_field=self.secure_cloned_response_field,\n                response_model_include=self.response_model_include,\n                response_model_exclude=self.response_model_exclude,\n                response_model_by_alias=self.response_model_by_alias,\n                response_model_skip_defaults=self.response_model_skip_defaults,\n                dependency_overrides_provider=self.dependency_overrides_provider,\n            )\n        )\n\n\nclass APIRouter(routing.Router):\n    def __init__(\n        self,\n        routes: List[routing.BaseRoute] = None,\n        redirect_slashes: bool = True,\n        default: ASGIApp = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        super().__init__(\n            routes=routes, redirect_slashes=redirect_slashes, default=default\n        )\n        self.dependency_overrides_provider = dependency_overrides_provider\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> None:\n        route = APIRoute(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_skip_defaults=response_model_skip_defaults,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        route = APIWebSocketRoute(path, endpoint=endpoint, name=name)\n        self.routes.append(route)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=(route.tags or []) + (tags or []),\n                    dependencies=list(dependencies or [])\n                    + list(route.dependencies or []),\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_skip_defaults=route.response_model_skip_defaults,\n                    include_in_schema=route.include_in_schema,\n                    response_class=route.response_class,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=list(route.methods or []),\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n", "diff": "@@ -147,7 +147,7 @@ def get_websocket_app(\n         if errors:\n             await websocket.close(code=WS_1008_POLICY_VIOLATION)\n             raise WebSocketRequestValidationError(errors)\n-        assert dependant.call is not None, \"dependant.call must me a function\"\n+        assert dependant.call is not None, \"dependant.call must be a function\"\n         await dependant.call(**values)\n \n     return app\n"}
{"commit_hash": "e71636e381a297d1825b37f71362ecd36f2fb3fb", "issue_description": ":bug: Fix mypy route errors after merging #415 (#462)", "code_before": "import asyncio\nimport inspect\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Set, Type, Union\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    get_body_field,\n    get_dependant,\n    get_parameterless_sub_dependant,\n    solve_dependencies,\n)\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.utils import create_cloned_field, generate_operation_id_for_path\nfrom pydantic import BaseConfig, BaseModel, Schema\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import Field\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import (\n    compile_path,\n    get_name,\n    request_response,\n    websocket_session,\n)\nfrom starlette.status import WS_1008_POLICY_VIOLATION\nfrom starlette.types import ASGIApp\nfrom starlette.websockets import WebSocket\n\n\ndef serialize_response(\n    *,\n    field: Field = None,\n    response: Response,\n    include: Set[str] = None,\n    exclude: Set[str] = set(),\n    by_alias: bool = True,\n    skip_defaults: bool = False,\n) -> Any:\n    if field:\n        errors = []\n        value, errors_ = field.validate(response, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors)\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            skip_defaults=skip_defaults,\n        )\n    else:\n        return jsonable_encoder(response)\n\n\ndef get_app(\n    dependant: Dependant,\n    body_field: Field = None,\n    status_code: int = 200,\n    response_class: Type[Response] = JSONResponse,\n    response_field: Field = None,\n    response_model_include: Set[str] = None,\n    response_model_exclude: Set[str] = set(),\n    response_model_by_alias: bool = True,\n    response_model_skip_defaults: bool = False,\n    dependency_overrides_provider: Any = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logging.error(f\"Error getting request body: {e}\")\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors)\n        else:\n            assert dependant.call is not None, \"dependant.call must be a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = serialize_response(\n                field=response_field,\n                response=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                skip_defaults=response_model_skip_defaults,\n            )\n            response = response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,\n            )\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Any = None\n) -> Callable:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        name: str = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n        )\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        name: str = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = set([method.upper() for method in methods])\n        self.unique_id = generate_operation_id_for_path(\n            name=self.name, path=self.path_format, method=list(methods)[0]\n        )\n        self.response_model = response_model\n        if self.response_model:\n            assert lenient_issubclass(\n                response_class, JSONResponse\n            ), \"To declare a type the response must be a JSON response\"\n            response_name = \"Response_\" + self.unique_id\n            self.response_field: Optional[Field] = Field(\n                name=response_name,\n                type_=self.response_model,\n                class_validators={},\n                default=None,\n                required=False,\n                model_config=BaseConfig,\n                schema=Schema(None),\n            )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will be always created.\n            self.secure_cloned_response_field: Optional[Field] = create_cloned_field(\n                self.response_field\n            )\n        else:\n            self.response_field = None\n            self.secure_cloned_response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        if dependencies:\n            self.dependencies = list(dependencies)\n        else:\n            self.dependencies = []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert lenient_issubclass(\n                    model, BaseModel\n                ), \"A response model must be a Pydantic model\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                response_field = Field(\n                    name=response_name,\n                    type_=model,\n                    class_validators=None,\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    schema=Schema(None),\n                )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], Field] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_skip_defaults = response_model_skip_defaults\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.app = request_response(\n            get_app(\n                dependant=self.dependant,\n                body_field=self.body_field,\n                status_code=self.status_code,\n                response_class=self.response_class,\n                response_field=self.secure_cloned_response_field,\n                response_model_include=self.response_model_include,\n                response_model_exclude=self.response_model_exclude,\n                response_model_by_alias=self.response_model_by_alias,\n                response_model_skip_defaults=self.response_model_skip_defaults,\n                dependency_overrides_provider=self.dependency_overrides_provider,\n            )\n        )\n\n\nclass APIRouter(routing.Router):\n    def __init__(\n        self,\n        routes: List[routing.BaseRoute] = None,\n        redirect_slashes: bool = True,\n        default: ASGIApp = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        super().__init__(\n            routes=routes, redirect_slashes=redirect_slashes, default=default\n        )\n        self.dependency_overrides_provider = dependency_overrides_provider\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> None:\n        route = APIRoute(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_skip_defaults=response_model_skip_defaults,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        route = APIWebSocketRoute(path, endpoint=endpoint, name=name)\n        self.routes.append(route)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                if not r.path:\n                    raise Exception(\n                        f\"Prefix and path cannot be both empty (operation: {r.name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=(route.tags or []) + (tags or []),\n                    dependencies=list(dependencies or [])\n                    + list(route.dependencies or []),\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_skip_defaults=route.response_model_skip_defaults,\n                    include_in_schema=route.include_in_schema,\n                    response_class=route.response_class,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=list(route.methods or []),\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n", "fix_code": "import asyncio\nimport inspect\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Set, Type, Union\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    get_body_field,\n    get_dependant,\n    get_parameterless_sub_dependant,\n    solve_dependencies,\n)\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.utils import create_cloned_field, generate_operation_id_for_path\nfrom pydantic import BaseConfig, BaseModel, Schema\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.fields import Field\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import (\n    compile_path,\n    get_name,\n    request_response,\n    websocket_session,\n)\nfrom starlette.status import WS_1008_POLICY_VIOLATION\nfrom starlette.types import ASGIApp\nfrom starlette.websockets import WebSocket\n\n\ndef serialize_response(\n    *,\n    field: Field = None,\n    response: Response,\n    include: Set[str] = None,\n    exclude: Set[str] = set(),\n    by_alias: bool = True,\n    skip_defaults: bool = False,\n) -> Any:\n    if field:\n        errors = []\n        value, errors_ = field.validate(response, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors)\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            skip_defaults=skip_defaults,\n        )\n    else:\n        return jsonable_encoder(response)\n\n\ndef get_app(\n    dependant: Dependant,\n    body_field: Field = None,\n    status_code: int = 200,\n    response_class: Type[Response] = JSONResponse,\n    response_field: Field = None,\n    response_model_include: Set[str] = None,\n    response_model_exclude: Set[str] = set(),\n    response_model_by_alias: bool = True,\n    response_model_skip_defaults: bool = False,\n    dependency_overrides_provider: Any = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(body_field.schema, params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logging.error(f\"Error getting request body: {e}\")\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors)\n        else:\n            assert dependant.call is not None, \"dependant.call must be a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = serialize_response(\n                field=response_field,\n                response=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                skip_defaults=response_model_skip_defaults,\n            )\n            response = response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,\n            )\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Any = None\n) -> Callable:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        name: str = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n        )\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        name: str = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = set([method.upper() for method in methods])\n        self.unique_id = generate_operation_id_for_path(\n            name=self.name, path=self.path_format, method=list(methods)[0]\n        )\n        self.response_model = response_model\n        if self.response_model:\n            assert lenient_issubclass(\n                response_class, JSONResponse\n            ), \"To declare a type the response must be a JSON response\"\n            response_name = \"Response_\" + self.unique_id\n            self.response_field: Optional[Field] = Field(\n                name=response_name,\n                type_=self.response_model,\n                class_validators={},\n                default=None,\n                required=False,\n                model_config=BaseConfig,\n                schema=Schema(None),\n            )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will be always created.\n            self.secure_cloned_response_field: Optional[Field] = create_cloned_field(\n                self.response_field\n            )\n        else:\n            self.response_field = None\n            self.secure_cloned_response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        if dependencies:\n            self.dependencies = list(dependencies)\n        else:\n            self.dependencies = []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert lenient_issubclass(\n                    model, BaseModel\n                ), \"A response model must be a Pydantic model\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                response_field = Field(\n                    name=response_name,\n                    type_=model,\n                    class_validators=None,\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    schema=Schema(None),\n                )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], Field] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_skip_defaults = response_model_skip_defaults\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.app = request_response(\n            get_app(\n                dependant=self.dependant,\n                body_field=self.body_field,\n                status_code=self.status_code,\n                response_class=self.response_class,\n                response_field=self.secure_cloned_response_field,\n                response_model_include=self.response_model_include,\n                response_model_exclude=self.response_model_exclude,\n                response_model_by_alias=self.response_model_by_alias,\n                response_model_skip_defaults=self.response_model_skip_defaults,\n                dependency_overrides_provider=self.dependency_overrides_provider,\n            )\n        )\n\n\nclass APIRouter(routing.Router):\n    def __init__(\n        self,\n        routes: List[routing.BaseRoute] = None,\n        redirect_slashes: bool = True,\n        default: ASGIApp = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        super().__init__(\n            routes=routes, redirect_slashes=redirect_slashes, default=default\n        )\n        self.dependency_overrides_provider = dependency_overrides_provider\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> None:\n        route = APIRoute(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_skip_defaults=response_model_skip_defaults,\n                include_in_schema=include_in_schema,\n                response_class=response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        route = APIWebSocketRoute(path, endpoint=endpoint, name=name)\n        self.routes.append(route)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise Exception(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=(route.tags or []) + (tags or []),\n                    dependencies=list(dependencies or [])\n                    + list(route.dependencies or []),\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_skip_defaults=route.response_model_skip_defaults,\n                    include_in_schema=route.include_in_schema,\n                    response_class=route.response_class,\n                    name=route.name,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=list(route.methods or []),\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Set[str] = None,\n        response_model_exclude: Set[str] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = JSONResponse,\n        name: str = None,\n    ) -> Callable:\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_skip_defaults=response_model_skip_defaults,\n            include_in_schema=include_in_schema,\n            response_class=response_class,\n            name=name,\n        )\n", "diff": "@@ -449,9 +449,11 @@ class APIRouter(routing.Router):\n             ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n         else:\n             for r in router.routes:\n-                if not r.path:\n+                path = getattr(r, \"path\")\n+                name = getattr(r, \"name\", \"unknown\")\n+                if path is not None and not path:\n                     raise Exception(\n-                        f\"Prefix and path cannot be both empty (operation: {r.name})\"\n+                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                     )\n         if responses is None:\n             responses = {}\n"}
{"commit_hash": "4642f63a1ebde30da9c9169229bb37a4932cce63", "issue_description": ":bug: Use proper import for Request -- fixes #492 (#493)", "code_before": "from typing import Any, Sequence\n\nfrom pydantic import ValidationError\nfrom pydantic.error_wrappers import ErrorList\nfrom requests import Request\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom starlette.websockets import WebSocket\n\n\nclass HTTPException(StarletteHTTPException):\n    def __init__(\n        self, status_code: int, detail: Any = None, headers: dict = None\n    ) -> None:\n        super().__init__(status_code=status_code, detail=detail)\n        self.headers = headers\n\n\nclass RequestValidationError(ValidationError):\n    def __init__(self, errors: Sequence[ErrorList]) -> None:\n        super().__init__(errors, Request)\n\n\nclass WebSocketRequestValidationError(ValidationError):\n    def __init__(self, errors: Sequence[ErrorList]) -> None:\n        super().__init__(errors, WebSocket)\n", "fix_code": "from typing import Any, Sequence\n\nfrom pydantic import ValidationError\nfrom pydantic.error_wrappers import ErrorList\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom starlette.requests import Request\nfrom starlette.websockets import WebSocket\n\n\nclass HTTPException(StarletteHTTPException):\n    def __init__(\n        self, status_code: int, detail: Any = None, headers: dict = None\n    ) -> None:\n        super().__init__(status_code=status_code, detail=detail)\n        self.headers = headers\n\n\nclass RequestValidationError(ValidationError):\n    def __init__(self, errors: Sequence[ErrorList]) -> None:\n        super().__init__(errors, Request)\n\n\nclass WebSocketRequestValidationError(ValidationError):\n    def __init__(self, errors: Sequence[ErrorList]) -> None:\n        super().__init__(errors, WebSocket)\n", "diff": "@@ -2,8 +2,8 @@ from typing import Any, Sequence\n \n from pydantic import ValidationError\n from pydantic.error_wrappers import ErrorList\n-from requests import Request\n from starlette.exceptions import HTTPException as StarletteHTTPException\n+from starlette.requests import Request\n from starlette.websockets import WebSocket\n \n \n"}
{"commit_hash": "3dbbecdd16ec43b4f4037e336acb04a7b27bf8df", "issue_description": ":bug: Fix setting 4XX overriding default 422 validation errors(#517)", "code_before": "import http.client\nfrom typing import Any, Dict, List, Optional, Sequence, Tuple, Type, cast\n\nfrom fastapi import routing\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import get_flat_dependant\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.openapi.constants import METHODS_WITH_BODY, REF_PREFIX\nfrom fastapi.openapi.models import OpenAPI\nfrom fastapi.params import Body, Param\nfrom fastapi.utils import (\n    generate_operation_id_for_path,\n    get_flat_models_from_routes,\n    get_model_definitions,\n)\nfrom pydantic.fields import Field\nfrom pydantic.schema import field_schema, get_model_name_map\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import BaseRoute\nfrom starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n\nvalidation_error_definition = {\n    \"title\": \"ValidationError\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"loc\": {\"title\": \"Location\", \"type\": \"array\", \"items\": {\"type\": \"string\"}},\n        \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n        \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n    },\n    \"required\": [\"loc\", \"msg\", \"type\"],\n}\n\nvalidation_error_response_definition = {\n    \"title\": \"HTTPValidationError\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"detail\": {\n            \"title\": \"Detail\",\n            \"type\": \"array\",\n            \"items\": {\"$ref\": REF_PREFIX + \"ValidationError\"},\n        }\n    },\n}\n\nstatus_code_ranges: Dict[str, str] = {\n    \"1XX\": \"Information\",\n    \"2XX\": \"Success\",\n    \"3XX\": \"Redirection\",\n    \"4XX\": \"Client Error\",\n    \"5XX\": \"Server Error\",\n    \"DEFAULT\": \"Default Response\",\n}\n\n\ndef get_openapi_params(dependant: Dependant) -> List[Field]:\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    return (\n        flat_dependant.path_params\n        + flat_dependant.query_params\n        + flat_dependant.header_params\n        + flat_dependant.cookie_params\n    )\n\n\ndef get_openapi_security_definitions(flat_dependant: Dependant) -> Tuple[Dict, List]:\n    security_definitions = {}\n    operation_security = []\n    for security_requirement in flat_dependant.security_requirements:\n        security_definition = jsonable_encoder(\n            security_requirement.security_scheme.model,\n            by_alias=True,\n            include_none=False,\n        )\n        security_name = security_requirement.security_scheme.scheme_name\n        security_definitions[security_name] = security_definition\n        operation_security.append({security_name: security_requirement.scopes})\n    return security_definitions, operation_security\n\n\ndef get_openapi_operation_parameters(\n    all_route_params: Sequence[Field]\n) -> List[Dict[str, Any]]:\n    parameters = []\n    for param in all_route_params:\n        schema = param.schema\n        schema = cast(Param, schema)\n        parameter = {\n            \"name\": param.alias,\n            \"in\": schema.in_.value,\n            \"required\": param.required,\n            \"schema\": field_schema(param, model_name_map={})[0],\n        }\n        if schema.description:\n            parameter[\"description\"] = schema.description\n        if schema.deprecated:\n            parameter[\"deprecated\"] = schema.deprecated\n        parameters.append(parameter)\n    return parameters\n\n\ndef get_openapi_operation_request_body(\n    *, body_field: Optional[Field], model_name_map: Dict[Type, str]\n) -> Optional[Dict]:\n    if not body_field:\n        return None\n    assert isinstance(body_field, Field)\n    body_schema, _, _ = field_schema(\n        body_field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n    )\n    body_field.schema = cast(Body, body_field.schema)\n    request_media_type = body_field.schema.media_type\n    required = body_field.required\n    request_body_oai: Dict[str, Any] = {}\n    if required:\n        request_body_oai[\"required\"] = required\n    request_body_oai[\"content\"] = {request_media_type: {\"schema\": body_schema}}\n    return request_body_oai\n\n\ndef generate_operation_id(*, route: routing.APIRoute, method: str) -> str:\n    if route.operation_id:\n        return route.operation_id\n    path: str = route.path_format\n    return generate_operation_id_for_path(name=route.name, path=path, method=method)\n\n\ndef generate_operation_summary(*, route: routing.APIRoute, method: str) -> str:\n    if route.summary:\n        return route.summary\n    return route.name.replace(\"_\", \" \").title()\n\n\ndef get_openapi_operation_metadata(*, route: routing.APIRoute, method: str) -> Dict:\n    operation: Dict[str, Any] = {}\n    if route.tags:\n        operation[\"tags\"] = route.tags\n    operation[\"summary\"] = generate_operation_summary(route=route, method=method)\n    if route.description:\n        operation[\"description\"] = route.description\n    operation[\"operationId\"] = generate_operation_id(route=route, method=method)\n    if route.deprecated:\n        operation[\"deprecated\"] = route.deprecated\n    return operation\n\n\ndef get_openapi_path(\n    *, route: routing.APIRoute, model_name_map: Dict[Type, str]\n) -> Tuple[Dict, Dict, Dict]:\n    path = {}\n    security_schemes: Dict[str, Any] = {}\n    definitions: Dict[str, Any] = {}\n    assert route.methods is not None, \"Methods must be a list\"\n    assert (\n        route.response_class and route.response_class.media_type\n    ), \"A response class with media_type is needed to generate OpenAPI\"\n    route_response_media_type: str = route.response_class.media_type\n    if route.include_in_schema:\n        for method in route.methods:\n            operation = get_openapi_operation_metadata(route=route, method=method)\n            parameters: List[Dict] = []\n            flat_dependant = get_flat_dependant(route.dependant, skip_repeats=True)\n            security_definitions, operation_security = get_openapi_security_definitions(\n                flat_dependant=flat_dependant\n            )\n            if operation_security:\n                operation.setdefault(\"security\", []).extend(operation_security)\n            if security_definitions:\n                security_schemes.update(security_definitions)\n            all_route_params = get_openapi_params(route.dependant)\n            operation_parameters = get_openapi_operation_parameters(all_route_params)\n            parameters.extend(operation_parameters)\n            if parameters:\n                operation[\"parameters\"] = parameters\n            if method in METHODS_WITH_BODY:\n                request_body_oai = get_openapi_operation_request_body(\n                    body_field=route.body_field, model_name_map=model_name_map\n                )\n                if request_body_oai:\n                    operation[\"requestBody\"] = request_body_oai\n            if route.responses:\n                for (additional_status_code, response) in route.responses.items():\n                    assert isinstance(\n                        response, dict\n                    ), \"An additional response must be a dict\"\n                    field = route.response_fields.get(additional_status_code)\n                    if field:\n                        response_schema, _, _ = field_schema(\n                            field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n                        )\n                        response.setdefault(\"content\", {}).setdefault(\n                            route_response_media_type, {}\n                        )[\"schema\"] = response_schema\n                    status_text: Optional[str] = status_code_ranges.get(\n                        str(additional_status_code).upper()\n                    ) or http.client.responses.get(int(additional_status_code))\n                    response.setdefault(\n                        \"description\", status_text or \"Additional Response\"\n                    )\n                    status_code_key = str(additional_status_code).upper()\n                    if status_code_key == \"DEFAULT\":\n                        status_code_key = \"default\"\n                    operation.setdefault(\"responses\", {})[status_code_key] = response\n            status_code = str(route.status_code)\n            response_schema = {\"type\": \"string\"}\n            if lenient_issubclass(route.response_class, JSONResponse):\n                if route.response_field:\n                    response_schema, _, _ = field_schema(\n                        route.response_field,\n                        model_name_map=model_name_map,\n                        ref_prefix=REF_PREFIX,\n                    )\n                else:\n                    response_schema = {}\n            operation.setdefault(\"responses\", {}).setdefault(status_code, {})[\n                \"description\"\n            ] = route.response_description\n            operation.setdefault(\"responses\", {}).setdefault(\n                status_code, {}\n            ).setdefault(\"content\", {}).setdefault(route_response_media_type, {})[\n                \"schema\"\n            ] = response_schema\n\n            http422 = str(HTTP_422_UNPROCESSABLE_ENTITY)\n            if (all_route_params or route.body_field) and not any(\n                [\n                    status in operation[\"responses\"]\n                    for status in [http422, \"4xx\", \"default\"]\n                ]\n            ):\n                operation[\"responses\"][http422] = {\n                    \"description\": \"Validation Error\",\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": REF_PREFIX + \"HTTPValidationError\"}\n                        }\n                    },\n                }\n                if \"ValidationError\" not in definitions:\n                    definitions.update(\n                        {\n                            \"ValidationError\": validation_error_definition,\n                            \"HTTPValidationError\": validation_error_response_definition,\n                        }\n                    )\n            path[method.lower()] = operation\n    return path, security_schemes, definitions\n\n\ndef get_openapi(\n    *,\n    title: str,\n    version: str,\n    openapi_version: str = \"3.0.2\",\n    description: str = None,\n    routes: Sequence[BaseRoute],\n    openapi_prefix: str = \"\"\n) -> Dict:\n    info = {\"title\": title, \"version\": version}\n    if description:\n        info[\"description\"] = description\n    output = {\"openapi\": openapi_version, \"info\": info}\n    components: Dict[str, Dict] = {}\n    paths: Dict[str, Dict] = {}\n    flat_models = get_flat_models_from_routes(routes)\n    model_name_map = get_model_name_map(flat_models)\n    definitions = get_model_definitions(\n        flat_models=flat_models, model_name_map=model_name_map\n    )\n    for route in routes:\n        if isinstance(route, routing.APIRoute):\n            result = get_openapi_path(route=route, model_name_map=model_name_map)\n            if result:\n                path, security_schemes, path_definitions = result\n                if path:\n                    paths.setdefault(openapi_prefix + route.path_format, {}).update(\n                        path\n                    )\n                if security_schemes:\n                    components.setdefault(\"securitySchemes\", {}).update(\n                        security_schemes\n                    )\n                if path_definitions:\n                    definitions.update(path_definitions)\n    if definitions:\n        components.setdefault(\"schemas\", {}).update(definitions)\n    if components:\n        output[\"components\"] = components\n    output[\"paths\"] = paths\n    return jsonable_encoder(OpenAPI(**output), by_alias=True, include_none=False)\n", "fix_code": "import http.client\nfrom typing import Any, Dict, List, Optional, Sequence, Tuple, Type, cast\n\nfrom fastapi import routing\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import get_flat_dependant\nfrom fastapi.encoders import jsonable_encoder\nfrom fastapi.openapi.constants import METHODS_WITH_BODY, REF_PREFIX\nfrom fastapi.openapi.models import OpenAPI\nfrom fastapi.params import Body, Param\nfrom fastapi.utils import (\n    generate_operation_id_for_path,\n    get_flat_models_from_routes,\n    get_model_definitions,\n)\nfrom pydantic.fields import Field\nfrom pydantic.schema import field_schema, get_model_name_map\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import BaseRoute\nfrom starlette.status import HTTP_422_UNPROCESSABLE_ENTITY\n\nvalidation_error_definition = {\n    \"title\": \"ValidationError\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"loc\": {\"title\": \"Location\", \"type\": \"array\", \"items\": {\"type\": \"string\"}},\n        \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n        \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n    },\n    \"required\": [\"loc\", \"msg\", \"type\"],\n}\n\nvalidation_error_response_definition = {\n    \"title\": \"HTTPValidationError\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"detail\": {\n            \"title\": \"Detail\",\n            \"type\": \"array\",\n            \"items\": {\"$ref\": REF_PREFIX + \"ValidationError\"},\n        }\n    },\n}\n\nstatus_code_ranges: Dict[str, str] = {\n    \"1XX\": \"Information\",\n    \"2XX\": \"Success\",\n    \"3XX\": \"Redirection\",\n    \"4XX\": \"Client Error\",\n    \"5XX\": \"Server Error\",\n    \"DEFAULT\": \"Default Response\",\n}\n\n\ndef get_openapi_params(dependant: Dependant) -> List[Field]:\n    flat_dependant = get_flat_dependant(dependant, skip_repeats=True)\n    return (\n        flat_dependant.path_params\n        + flat_dependant.query_params\n        + flat_dependant.header_params\n        + flat_dependant.cookie_params\n    )\n\n\ndef get_openapi_security_definitions(flat_dependant: Dependant) -> Tuple[Dict, List]:\n    security_definitions = {}\n    operation_security = []\n    for security_requirement in flat_dependant.security_requirements:\n        security_definition = jsonable_encoder(\n            security_requirement.security_scheme.model,\n            by_alias=True,\n            include_none=False,\n        )\n        security_name = security_requirement.security_scheme.scheme_name\n        security_definitions[security_name] = security_definition\n        operation_security.append({security_name: security_requirement.scopes})\n    return security_definitions, operation_security\n\n\ndef get_openapi_operation_parameters(\n    all_route_params: Sequence[Field]\n) -> List[Dict[str, Any]]:\n    parameters = []\n    for param in all_route_params:\n        schema = param.schema\n        schema = cast(Param, schema)\n        parameter = {\n            \"name\": param.alias,\n            \"in\": schema.in_.value,\n            \"required\": param.required,\n            \"schema\": field_schema(param, model_name_map={})[0],\n        }\n        if schema.description:\n            parameter[\"description\"] = schema.description\n        if schema.deprecated:\n            parameter[\"deprecated\"] = schema.deprecated\n        parameters.append(parameter)\n    return parameters\n\n\ndef get_openapi_operation_request_body(\n    *, body_field: Optional[Field], model_name_map: Dict[Type, str]\n) -> Optional[Dict]:\n    if not body_field:\n        return None\n    assert isinstance(body_field, Field)\n    body_schema, _, _ = field_schema(\n        body_field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n    )\n    body_field.schema = cast(Body, body_field.schema)\n    request_media_type = body_field.schema.media_type\n    required = body_field.required\n    request_body_oai: Dict[str, Any] = {}\n    if required:\n        request_body_oai[\"required\"] = required\n    request_body_oai[\"content\"] = {request_media_type: {\"schema\": body_schema}}\n    return request_body_oai\n\n\ndef generate_operation_id(*, route: routing.APIRoute, method: str) -> str:\n    if route.operation_id:\n        return route.operation_id\n    path: str = route.path_format\n    return generate_operation_id_for_path(name=route.name, path=path, method=method)\n\n\ndef generate_operation_summary(*, route: routing.APIRoute, method: str) -> str:\n    if route.summary:\n        return route.summary\n    return route.name.replace(\"_\", \" \").title()\n\n\ndef get_openapi_operation_metadata(*, route: routing.APIRoute, method: str) -> Dict:\n    operation: Dict[str, Any] = {}\n    if route.tags:\n        operation[\"tags\"] = route.tags\n    operation[\"summary\"] = generate_operation_summary(route=route, method=method)\n    if route.description:\n        operation[\"description\"] = route.description\n    operation[\"operationId\"] = generate_operation_id(route=route, method=method)\n    if route.deprecated:\n        operation[\"deprecated\"] = route.deprecated\n    return operation\n\n\ndef get_openapi_path(\n    *, route: routing.APIRoute, model_name_map: Dict[Type, str]\n) -> Tuple[Dict, Dict, Dict]:\n    path = {}\n    security_schemes: Dict[str, Any] = {}\n    definitions: Dict[str, Any] = {}\n    assert route.methods is not None, \"Methods must be a list\"\n    assert (\n        route.response_class and route.response_class.media_type\n    ), \"A response class with media_type is needed to generate OpenAPI\"\n    route_response_media_type: str = route.response_class.media_type\n    if route.include_in_schema:\n        for method in route.methods:\n            operation = get_openapi_operation_metadata(route=route, method=method)\n            parameters: List[Dict] = []\n            flat_dependant = get_flat_dependant(route.dependant, skip_repeats=True)\n            security_definitions, operation_security = get_openapi_security_definitions(\n                flat_dependant=flat_dependant\n            )\n            if operation_security:\n                operation.setdefault(\"security\", []).extend(operation_security)\n            if security_definitions:\n                security_schemes.update(security_definitions)\n            all_route_params = get_openapi_params(route.dependant)\n            operation_parameters = get_openapi_operation_parameters(all_route_params)\n            parameters.extend(operation_parameters)\n            if parameters:\n                operation[\"parameters\"] = parameters\n            if method in METHODS_WITH_BODY:\n                request_body_oai = get_openapi_operation_request_body(\n                    body_field=route.body_field, model_name_map=model_name_map\n                )\n                if request_body_oai:\n                    operation[\"requestBody\"] = request_body_oai\n            if route.responses:\n                for (additional_status_code, response) in route.responses.items():\n                    assert isinstance(\n                        response, dict\n                    ), \"An additional response must be a dict\"\n                    field = route.response_fields.get(additional_status_code)\n                    if field:\n                        response_schema, _, _ = field_schema(\n                            field, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n                        )\n                        response.setdefault(\"content\", {}).setdefault(\n                            route_response_media_type, {}\n                        )[\"schema\"] = response_schema\n                    status_text: Optional[str] = status_code_ranges.get(\n                        str(additional_status_code).upper()\n                    ) or http.client.responses.get(int(additional_status_code))\n                    response.setdefault(\n                        \"description\", status_text or \"Additional Response\"\n                    )\n                    status_code_key = str(additional_status_code).upper()\n                    if status_code_key == \"DEFAULT\":\n                        status_code_key = \"default\"\n                    operation.setdefault(\"responses\", {})[status_code_key] = response\n            status_code = str(route.status_code)\n            response_schema = {\"type\": \"string\"}\n            if lenient_issubclass(route.response_class, JSONResponse):\n                if route.response_field:\n                    response_schema, _, _ = field_schema(\n                        route.response_field,\n                        model_name_map=model_name_map,\n                        ref_prefix=REF_PREFIX,\n                    )\n                else:\n                    response_schema = {}\n            operation.setdefault(\"responses\", {}).setdefault(status_code, {})[\n                \"description\"\n            ] = route.response_description\n            operation.setdefault(\"responses\", {}).setdefault(\n                status_code, {}\n            ).setdefault(\"content\", {}).setdefault(route_response_media_type, {})[\n                \"schema\"\n            ] = response_schema\n\n            http422 = str(HTTP_422_UNPROCESSABLE_ENTITY)\n            if (all_route_params or route.body_field) and not any(\n                [\n                    status in operation[\"responses\"]\n                    for status in [http422, \"4XX\", \"default\"]\n                ]\n            ):\n                operation[\"responses\"][http422] = {\n                    \"description\": \"Validation Error\",\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": REF_PREFIX + \"HTTPValidationError\"}\n                        }\n                    },\n                }\n                if \"ValidationError\" not in definitions:\n                    definitions.update(\n                        {\n                            \"ValidationError\": validation_error_definition,\n                            \"HTTPValidationError\": validation_error_response_definition,\n                        }\n                    )\n            path[method.lower()] = operation\n    return path, security_schemes, definitions\n\n\ndef get_openapi(\n    *,\n    title: str,\n    version: str,\n    openapi_version: str = \"3.0.2\",\n    description: str = None,\n    routes: Sequence[BaseRoute],\n    openapi_prefix: str = \"\"\n) -> Dict:\n    info = {\"title\": title, \"version\": version}\n    if description:\n        info[\"description\"] = description\n    output = {\"openapi\": openapi_version, \"info\": info}\n    components: Dict[str, Dict] = {}\n    paths: Dict[str, Dict] = {}\n    flat_models = get_flat_models_from_routes(routes)\n    model_name_map = get_model_name_map(flat_models)\n    definitions = get_model_definitions(\n        flat_models=flat_models, model_name_map=model_name_map\n    )\n    for route in routes:\n        if isinstance(route, routing.APIRoute):\n            result = get_openapi_path(route=route, model_name_map=model_name_map)\n            if result:\n                path, security_schemes, path_definitions = result\n                if path:\n                    paths.setdefault(openapi_prefix + route.path_format, {}).update(\n                        path\n                    )\n                if security_schemes:\n                    components.setdefault(\"securitySchemes\", {}).update(\n                        security_schemes\n                    )\n                if path_definitions:\n                    definitions.update(path_definitions)\n    if definitions:\n        components.setdefault(\"schemas\", {}).update(definitions)\n    if components:\n        output[\"components\"] = components\n    output[\"paths\"] = paths\n    return jsonable_encoder(OpenAPI(**output), by_alias=True, include_none=False)\n", "diff": "@@ -225,7 +225,7 @@ def get_openapi_path(\n             if (all_route_params or route.body_field) and not any(\n                 [\n                     status in operation[\"responses\"]\n-                    for status in [http422, \"4xx\", \"default\"]\n+                    for status in [http422, \"4XX\", \"default\"]\n                 ]\n             ):\n                 operation[\"responses\"][http422] = {\n"}
{"commit_hash": "4cea311e6ef112edfa1e42fde2f63b6ab2d7e413", "issue_description": ":bug: Fix doctype in docs (#537)", "code_before": "import json\nfrom typing import Optional\n\nfrom fastapi.encoders import jsonable_encoder\nfrom starlette.responses import HTMLResponse\n\n\ndef get_swagger_ui_html(\n    *,\n    openapi_url: str,\n    title: str,\n    swagger_js_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui-bundle.js\",\n    swagger_css_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui.css\",\n    swagger_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Optional[str] = None,\n    init_oauth: Optional[dict] = None,\n) -> HTMLResponse:\n\n    html = f\"\"\"\n    <! doctype html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n        dom_id: '#swagger-ui',\n        presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n        layout: \"BaseLayout\",\n        deepLinking: true\n    })\"\"\"\n\n    if init_oauth:\n        html += f\"\"\"\n        ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})\n        \"\"\"\n\n    html += \"\"\"\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_redoc_html(\n    *,\n    openapi_url: str,\n    title: str,\n    redoc_js_url: str = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    with_google_fonts: bool = True,\n) -> HTMLResponse:\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    \"\"\"\n    if with_google_fonts:\n        html += \"\"\"\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    \"\"\"\n    html += f\"\"\"\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    html = \"\"\"\n    <!doctype html>\n    <html lang=\"en-US\">\n    <body onload=\"run()\">\n    </body>\n    </html>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1);\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\")\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';})\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value)\n                    }\n            ) : {}\n\n            isValid = qp.state === sentState\n\n            if ((\n            oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n            oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n    </script>\n        \"\"\"\n    return HTMLResponse(content=html)\n", "fix_code": "import json\nfrom typing import Optional\n\nfrom fastapi.encoders import jsonable_encoder\nfrom starlette.responses import HTMLResponse\n\n\ndef get_swagger_ui_html(\n    *,\n    openapi_url: str,\n    title: str,\n    swagger_js_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui-bundle.js\",\n    swagger_css_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3/swagger-ui.css\",\n    swagger_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Optional[str] = None,\n    init_oauth: Optional[dict] = None,\n) -> HTMLResponse:\n\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n        dom_id: '#swagger-ui',\n        presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n        layout: \"BaseLayout\",\n        deepLinking: true\n    })\"\"\"\n\n    if init_oauth:\n        html += f\"\"\"\n        ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})\n        \"\"\"\n\n    html += \"\"\"\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_redoc_html(\n    *,\n    openapi_url: str,\n    title: str,\n    redoc_js_url: str = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    with_google_fonts: bool = True,\n) -> HTMLResponse:\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    \"\"\"\n    if with_google_fonts:\n        html += \"\"\"\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    \"\"\"\n    html += f\"\"\"\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    html = \"\"\"\n    <!DOCTYPE html>\n    <html lang=\"en-US\">\n    <body onload=\"run()\">\n    </body>\n    </html>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1);\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\")\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';})\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value)\n                    }\n            ) : {}\n\n            isValid = qp.state === sentState\n\n            if ((\n            oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n            oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n    </script>\n        \"\"\"\n    return HTMLResponse(content=html)\n", "diff": "@@ -17,7 +17,7 @@ def get_swagger_ui_html(\n ) -> HTMLResponse:\n \n     html = f\"\"\"\n-    <! doctype html>\n+    <!DOCTYPE html>\n     <html>\n     <head>\n     <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n@@ -104,7 +104,7 @@ def get_redoc_html(\n \n def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n     html = \"\"\"\n-    <!doctype html>\n+    <!DOCTYPE html>\n     <html lang=\"en-US\">\n     <body onload=\"run()\">\n     </body>\n"}
{"commit_hash": "4e50f534591d2a9c286a33e7eef5463b1fd8a1fd", "issue_description": ":bug: Fixing validator-caused incorrect output key order (#637)", "code_before": "import re\nfrom dataclasses import is_dataclass\nfrom typing import Any, Dict, List, Sequence, Set, Type, cast\n\nfrom fastapi import routing\nfrom fastapi.openapi.constants import REF_PREFIX\nfrom pydantic import BaseConfig, BaseModel, Schema, create_model\nfrom pydantic.fields import Field\nfrom pydantic.schema import get_flat_models_from_fields, model_process_schema\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.routing import BaseRoute\n\n\ndef get_flat_models_from_routes(routes: Sequence[BaseRoute]) -> Set[Type[BaseModel]]:\n    body_fields_from_routes: List[Field] = []\n    responses_from_routes: List[Field] = []\n    for route in routes:\n        if getattr(route, \"include_in_schema\", None) and isinstance(\n            route, routing.APIRoute\n        ):\n            if route.body_field:\n                assert isinstance(\n                    route.body_field, Field\n                ), \"A request body must be a Pydantic Field\"\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n    flat_models = get_flat_models_from_fields(\n        body_fields_from_routes + responses_from_routes, known_models=set()\n    )\n    return flat_models\n\n\ndef get_model_definitions(\n    *, flat_models: Set[Type[BaseModel]], model_name_map: Dict[Type[BaseModel], str]\n) -> Dict[str, Any]:\n    definitions: Dict[str, Dict] = {}\n    for model in flat_models:\n        m_schema, m_definitions, m_nested_models = model_process_schema(\n            model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    return definitions\n\n\ndef get_path_param_names(path: str) -> Set[str]:\n    return {item.strip(\"{}\") for item in re.findall(\"{[^}]*}\", path)}\n\n\ndef create_cloned_field(field: Field) -> Field:\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, \"__pydantic_model__\"):\n        original_type = original_type.__pydantic_model__  # type: ignore\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = create_model(\n            original_type.__name__,\n            __config__=original_type.__config__,\n            __validators__=original_type.__validators__,  # type: ignore\n        )\n        for f in original_type.__fields__.values():\n            use_type.__fields__[f.name] = f\n    new_field = Field(\n        name=field.name,\n        type_=use_type,\n        class_validators={},\n        default=None,\n        required=False,\n        model_config=BaseConfig,\n        schema=Schema(None),\n    )\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.schema = field.schema\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [\n            create_cloned_field(sub_field) for sub_field in field.sub_fields\n        ]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field)\n    new_field.validators = field.validators\n    new_field.whole_pre_validators = field.whole_pre_validators\n    new_field.whole_post_validators = field.whole_post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field._populate_validators()\n    return new_field\n\n\ndef generate_operation_id_for_path(*, name: str, path: str, method: str) -> str:\n    operation_id = name + path\n    operation_id = operation_id.replace(\"{\", \"_\").replace(\"}\", \"_\").replace(\"/\", \"_\")\n    operation_id = operation_id + \"_\" + method.lower()\n    return operation_id\n", "fix_code": "import re\nfrom dataclasses import is_dataclass\nfrom typing import Any, Dict, List, Sequence, Set, Type, cast\n\nfrom fastapi import routing\nfrom fastapi.openapi.constants import REF_PREFIX\nfrom pydantic import BaseConfig, BaseModel, Schema, create_model\nfrom pydantic.fields import Field\nfrom pydantic.schema import get_flat_models_from_fields, model_process_schema\nfrom pydantic.utils import lenient_issubclass\nfrom starlette.routing import BaseRoute\n\n\ndef get_flat_models_from_routes(routes: Sequence[BaseRoute]) -> Set[Type[BaseModel]]:\n    body_fields_from_routes: List[Field] = []\n    responses_from_routes: List[Field] = []\n    for route in routes:\n        if getattr(route, \"include_in_schema\", None) and isinstance(\n            route, routing.APIRoute\n        ):\n            if route.body_field:\n                assert isinstance(\n                    route.body_field, Field\n                ), \"A request body must be a Pydantic Field\"\n                body_fields_from_routes.append(route.body_field)\n            if route.response_field:\n                responses_from_routes.append(route.response_field)\n            if route.response_fields:\n                responses_from_routes.extend(route.response_fields.values())\n    flat_models = get_flat_models_from_fields(\n        body_fields_from_routes + responses_from_routes, known_models=set()\n    )\n    return flat_models\n\n\ndef get_model_definitions(\n    *, flat_models: Set[Type[BaseModel]], model_name_map: Dict[Type[BaseModel], str]\n) -> Dict[str, Any]:\n    definitions: Dict[str, Dict] = {}\n    for model in flat_models:\n        m_schema, m_definitions, m_nested_models = model_process_schema(\n            model, model_name_map=model_name_map, ref_prefix=REF_PREFIX\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    return definitions\n\n\ndef get_path_param_names(path: str) -> Set[str]:\n    return {item.strip(\"{}\") for item in re.findall(\"{[^}]*}\", path)}\n\n\ndef create_cloned_field(field: Field) -> Field:\n    original_type = field.type_\n    if is_dataclass(original_type) and hasattr(original_type, \"__pydantic_model__\"):\n        original_type = original_type.__pydantic_model__  # type: ignore\n    use_type = original_type\n    if lenient_issubclass(original_type, BaseModel):\n        original_type = cast(Type[BaseModel], original_type)\n        use_type = create_model(\n            original_type.__name__, __config__=original_type.__config__\n        )\n        for f in original_type.__fields__.values():\n            use_type.__fields__[f.name] = f\n        use_type.__validators__ = original_type.__validators__\n    new_field = Field(\n        name=field.name,\n        type_=use_type,\n        class_validators={},\n        default=None,\n        required=False,\n        model_config=BaseConfig,\n        schema=Schema(None),\n    )\n    new_field.has_alias = field.has_alias\n    new_field.alias = field.alias\n    new_field.class_validators = field.class_validators\n    new_field.default = field.default\n    new_field.required = field.required\n    new_field.model_config = field.model_config\n    new_field.schema = field.schema\n    new_field.allow_none = field.allow_none\n    new_field.validate_always = field.validate_always\n    if field.sub_fields:\n        new_field.sub_fields = [\n            create_cloned_field(sub_field) for sub_field in field.sub_fields\n        ]\n    if field.key_field:\n        new_field.key_field = create_cloned_field(field.key_field)\n    new_field.validators = field.validators\n    new_field.whole_pre_validators = field.whole_pre_validators\n    new_field.whole_post_validators = field.whole_post_validators\n    new_field.parse_json = field.parse_json\n    new_field.shape = field.shape\n    new_field._populate_validators()\n    return new_field\n\n\ndef generate_operation_id_for_path(*, name: str, path: str, method: str) -> str:\n    operation_id = name + path\n    operation_id = operation_id.replace(\"{\", \"_\").replace(\"}\", \"_\").replace(\"/\", \"_\")\n    operation_id = operation_id + \"_\" + method.lower()\n    return operation_id\n", "diff": "@@ -59,12 +59,11 @@ def create_cloned_field(field: Field) -> Field:\n     if lenient_issubclass(original_type, BaseModel):\n         original_type = cast(Type[BaseModel], original_type)\n         use_type = create_model(\n-            original_type.__name__,\n-            __config__=original_type.__config__,\n-            __validators__=original_type.__validators__,  # type: ignore\n+            original_type.__name__, __config__=original_type.__config__\n         )\n         for f in original_type.__fields__.values():\n             use_type.__fields__[f.name] = f\n+        use_type.__validators__ = original_type.__validators__\n     new_field = Field(\n         name=field.name,\n         type_=use_type,\n"}
{"commit_hash": "7781cc0936a7128865ae8065c145ff6b6f377e42", "issue_description": ":pencil2: Fix protocol separator typo (#647)", "code_before": "from fastapi import FastAPI\nfrom starlette.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\norigins = [\n    \"http://localhost.tiangolo.com\",\n    \"https://localhost.tiangolo.com\",\n    \"http:localhost\",\n    \"http:localhost:8080\",\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n", "fix_code": "from fastapi import FastAPI\nfrom starlette.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\norigins = [\n    \"http://localhost.tiangolo.com\",\n    \"https://localhost.tiangolo.com\",\n    \"http://localhost\",\n    \"http://localhost:8080\",\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n", "diff": "@@ -6,8 +6,8 @@ app = FastAPI()\n origins = [\n     \"http://localhost.tiangolo.com\",\n     \"https://localhost.tiangolo.com\",\n-    \"http:localhost\",\n-    \"http:localhost:8080\",\n+    \"http://localhost\",\n+    \"http://localhost:8080\",\n ]\n \n app.add_middleware(\n"}
{"commit_hash": "4915cf0561bf792a89fd329af453eafb0158d8d4", "issue_description": ":bug: Fix XML example (#710)", "code_before": "from fastapi import FastAPI\nfrom starlette.responses import Response\n\napp = FastAPI()\n\n\n@app.get(\"/legacy/\")\ndef get_legacy_data():\n    data = \"\"\"\n    <?xml version=\"1.0\"?>\n    <shampoo>\n    <Header>\n        Apply shampoo here.\n    <Header>\n    <Body>\n        You'll have to use soap here.\n    </Body>\n    </shampoo>\n    \"\"\"\n    return Response(content=data, media_type=\"application/xml\")\n", "fix_code": "from fastapi import FastAPI\nfrom starlette.responses import Response\n\napp = FastAPI()\n\n\n@app.get(\"/legacy/\")\ndef get_legacy_data():\n    data = \"\"\"<?xml version=\"1.0\"?>\n    <shampoo>\n    <Header>\n        Apply shampoo here.\n    </Header>\n    <Body>\n        You'll have to use soap here.\n    </Body>\n    </shampoo>\n    \"\"\"\n    return Response(content=data, media_type=\"application/xml\")\n", "diff": "@@ -6,12 +6,11 @@ app = FastAPI()\n \n @app.get(\"/legacy/\")\n def get_legacy_data():\n-    data = \"\"\"\n-    <?xml version=\"1.0\"?>\n+    data = \"\"\"<?xml version=\"1.0\"?>\n     <shampoo>\n     <Header>\n         Apply shampoo here.\n-    <Header>\n+    </Header>\n     <Body>\n         You'll have to use soap here.\n     </Body>\n"}
{"commit_hash": "7cea84b74ca3106a7f861b774e9d215e5228728f", "issue_description": ":bug: Fix FastAPI serialization of Pydantic ORM mode blocking the event loop (#888)", "code_before": "import asyncio\nimport inspect\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Set, Type, Union\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    get_body_field,\n    get_dependant,\n    get_parameterless_sub_dependant,\n    solve_dependencies,\n)\nfrom fastapi.encoders import DictIntStrAny, SetIntStr, jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.logger import logger\nfrom fastapi.openapi.constants import STATUS_CODES_WITH_NO_BODY\nfrom fastapi.utils import (\n    PYDANTIC_1,\n    create_cloned_field,\n    generate_operation_id_for_path,\n    get_field_info,\n    warning_response_model_skip_defaults_deprecated,\n)\nfrom pydantic import BaseConfig, BaseModel\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import (\n    compile_path,\n    get_name,\n    request_response,\n    websocket_session,\n)\nfrom starlette.status import WS_1008_POLICY_VIOLATION\nfrom starlette.types import ASGIApp\nfrom starlette.websockets import WebSocket\n\ntry:\n    from pydantic.fields import FieldInfo, ModelField\nexcept ImportError:  # pragma: nocover\n    # TODO: remove when removing support for Pydantic < 1.0.0\n    from pydantic import Schema as FieldInfo  # type: ignore\n    from pydantic.fields import Field as ModelField  # type: ignore\n\n\ndef serialize_response(\n    *,\n    field: ModelField = None,\n    response: Response,\n    include: Union[SetIntStr, DictIntStrAny] = None,\n    exclude: Union[SetIntStr, DictIntStrAny] = set(),\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n) -> Any:\n    if field:\n        errors = []\n        if exclude_unset and isinstance(response, BaseModel):\n            if PYDANTIC_1:\n                response = response.dict(exclude_unset=exclude_unset)\n            else:\n                response = response.dict(skip_defaults=exclude_unset)  # pragma: nocover\n        value, errors_ = field.validate(response, {}, loc=(\"response\",))\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors, field.type_)\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n        )\n    else:\n        return jsonable_encoder(response)\n\n\ndef get_request_handler(\n    dependant: Dependant,\n    body_field: ModelField = None,\n    status_code: int = 200,\n    response_class: Type[Response] = JSONResponse,\n    response_field: ModelField = None,\n    response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n    response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n    response_model_by_alias: bool = True,\n    response_model_exclude_unset: bool = False,\n    dependency_overrides_provider: Any = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(get_field_info(body_field), params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logger.error(f\"Error getting request body: {e}\")\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors, body=body)\n        else:\n            assert dependant.call is not None, \"dependant.call must be a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = serialize_response(\n                field=response_field,\n                response=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                exclude_unset=response_model_exclude_unset,\n            )\n            response = response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,\n            )\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Any = None\n) -> Callable:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        name: str = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n        )\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        name: str = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Optional[Type[Response]] = None,\n        dependency_overrides_provider: Any = None,\n        callbacks: Optional[List[\"APIRoute\"]] = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = set([method.upper() for method in methods])\n        self.unique_id = generate_operation_id_for_path(\n            name=self.name, path=self.path_format, method=list(methods)[0]\n        )\n        self.response_model = response_model\n        if self.response_model:\n            assert (\n                status_code not in STATUS_CODES_WITH_NO_BODY\n            ), f\"Status code {status_code} must not have a response body\"\n            response_name = \"Response_\" + self.unique_id\n            if PYDANTIC_1:\n                self.response_field: Optional[ModelField] = ModelField(\n                    name=response_name,\n                    type_=self.response_model,\n                    class_validators={},\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    field_info=FieldInfo(None),\n                )\n            else:\n                self.response_field: Optional[ModelField] = ModelField(  # type: ignore  # pragma: nocover\n                    name=response_name,\n                    type_=self.response_model,\n                    class_validators={},\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    schema=FieldInfo(None),\n                )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will be always created.\n            self.secure_cloned_response_field: Optional[\n                ModelField\n            ] = create_cloned_field(self.response_field)\n        else:\n            self.response_field = None\n            self.secure_cloned_response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        if dependencies:\n            self.dependencies = list(dependencies)\n        else:\n            self.dependencies = []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        # if a \"form feed\" character (page break) is found in the description text,\n        # truncate description text to the content preceding the first \"form feed\"\n        self.description = self.description.split(\"\\f\")[0]\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert (\n                    additional_status_code not in STATUS_CODES_WITH_NO_BODY\n                ), f\"Status code {additional_status_code} must not have a response body\"\n                assert lenient_issubclass(\n                    model, BaseModel\n                ), \"A response model must be a Pydantic model\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                if PYDANTIC_1:\n                    response_field = ModelField(\n                        name=response_name,\n                        type_=model,\n                        class_validators=None,\n                        default=None,\n                        required=False,\n                        model_config=BaseConfig,\n                        field_info=FieldInfo(None),\n                    )\n                else:\n                    response_field = ModelField(  # type: ignore  # pragma: nocover\n                        name=response_name,\n                        type_=model,\n                        class_validators=None,\n                        default=None,\n                        required=False,\n                        model_config=BaseConfig,\n                        schema=FieldInfo(None),\n                    )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], ModelField] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_exclude_unset = response_model_exclude_unset\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.callbacks = callbacks\n        self.app = request_response(self.get_route_handler())\n\n    def get_route_handler(self) -> Callable:\n        return get_request_handler(\n            dependant=self.dependant,\n            body_field=self.body_field,\n            status_code=self.status_code,\n            response_class=self.response_class or JSONResponse,\n            response_field=self.secure_cloned_response_field,\n            response_model_include=self.response_model_include,\n            response_model_exclude=self.response_model_exclude,\n            response_model_by_alias=self.response_model_by_alias,\n            response_model_exclude_unset=self.response_model_exclude_unset,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n\n\nclass APIRouter(routing.Router):\n    def __init__(\n        self,\n        routes: List[routing.BaseRoute] = None,\n        redirect_slashes: bool = True,\n        default: ASGIApp = None,\n        dependency_overrides_provider: Any = None,\n        route_class: Type[APIRoute] = APIRoute,\n        default_response_class: Type[Response] = None,\n    ) -> None:\n        super().__init__(\n            routes=routes, redirect_slashes=redirect_slashes, default=default\n        )\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.route_class = route_class\n        self.default_response_class = default_response_class\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        route_class_override: Optional[Type[APIRoute]] = None,\n        callbacks: List[APIRoute] = None,\n    ) -> None:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        route_class = route_class_override or self.route_class\n        route = route_class(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            callbacks=callbacks,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=bool(\n                    response_model_exclude_unset or response_model_skip_defaults\n                ),\n                include_in_schema=include_in_schema,\n                response_class=response_class or self.default_response_class,\n                name=name,\n                callbacks=callbacks,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        route = APIWebSocketRoute(path, endpoint=endpoint, name=name)\n        self.routes.append(route)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        default_response_class: Optional[Type[Response]] = None,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise Exception(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=(route.tags or []) + (tags or []),\n                    dependencies=list(dependencies or [])\n                    + list(route.dependencies or []),\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_exclude_unset=route.response_model_exclude_unset,\n                    include_in_schema=route.include_in_schema,\n                    response_class=route.response_class or default_response_class,\n                    name=route.name,\n                    route_class_override=type(route),\n                    callbacks=route.callbacks,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=list(route.methods or []),\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n", "fix_code": "import asyncio\nimport inspect\nfrom typing import Any, Callable, Dict, List, Optional, Sequence, Set, Type, Union\n\nfrom fastapi import params\nfrom fastapi.dependencies.models import Dependant\nfrom fastapi.dependencies.utils import (\n    get_body_field,\n    get_dependant,\n    get_parameterless_sub_dependant,\n    solve_dependencies,\n)\nfrom fastapi.encoders import DictIntStrAny, SetIntStr, jsonable_encoder\nfrom fastapi.exceptions import RequestValidationError, WebSocketRequestValidationError\nfrom fastapi.logger import logger\nfrom fastapi.openapi.constants import STATUS_CODES_WITH_NO_BODY\nfrom fastapi.utils import (\n    PYDANTIC_1,\n    create_cloned_field,\n    generate_operation_id_for_path,\n    get_field_info,\n    warning_response_model_skip_defaults_deprecated,\n)\nfrom pydantic import BaseConfig, BaseModel\nfrom pydantic.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.utils import lenient_issubclass\nfrom starlette import routing\nfrom starlette.concurrency import run_in_threadpool\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, Response\nfrom starlette.routing import (\n    compile_path,\n    get_name,\n    request_response,\n    websocket_session,\n)\nfrom starlette.status import WS_1008_POLICY_VIOLATION\nfrom starlette.types import ASGIApp\nfrom starlette.websockets import WebSocket\n\ntry:\n    from pydantic.fields import FieldInfo, ModelField\nexcept ImportError:  # pragma: nocover\n    # TODO: remove when removing support for Pydantic < 1.0.0\n    from pydantic import Schema as FieldInfo  # type: ignore\n    from pydantic.fields import Field as ModelField  # type: ignore\n\n\nasync def serialize_response(\n    *,\n    field: ModelField = None,\n    response: Response,\n    include: Union[SetIntStr, DictIntStrAny] = None,\n    exclude: Union[SetIntStr, DictIntStrAny] = set(),\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n    is_coroutine: bool = True,\n) -> Any:\n    if field:\n        errors = []\n        if exclude_unset and isinstance(response, BaseModel):\n            if PYDANTIC_1:\n                response = response.dict(exclude_unset=exclude_unset)\n            else:\n                response = response.dict(skip_defaults=exclude_unset)  # pragma: nocover\n        if is_coroutine:\n            value, errors_ = field.validate(response, {}, loc=(\"response\",))\n        else:\n            value, errors_ = await run_in_threadpool(\n                field.validate, response, {}, loc=(\"response\",)\n            )\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        if errors:\n            raise ValidationError(errors, field.type_)\n        return jsonable_encoder(\n            value,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n        )\n    else:\n        return jsonable_encoder(response)\n\n\ndef get_request_handler(\n    dependant: Dependant,\n    body_field: ModelField = None,\n    status_code: int = 200,\n    response_class: Type[Response] = JSONResponse,\n    response_field: ModelField = None,\n    response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n    response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n    response_model_by_alias: bool = True,\n    response_model_exclude_unset: bool = False,\n    dependency_overrides_provider: Any = None,\n) -> Callable:\n    assert dependant.call is not None, \"dependant.call must be a function\"\n    is_coroutine = asyncio.iscoroutinefunction(dependant.call)\n    is_body_form = body_field and isinstance(get_field_info(body_field), params.Form)\n\n    async def app(request: Request) -> Response:\n        try:\n            body = None\n            if body_field:\n                if is_body_form:\n                    body = await request.form()\n                else:\n                    body_bytes = await request.body()\n                    if body_bytes:\n                        body = await request.json()\n        except Exception as e:\n            logger.error(f\"Error getting request body: {e}\")\n            raise HTTPException(\n                status_code=400, detail=\"There was an error parsing the body\"\n            ) from e\n        solved_result = await solve_dependencies(\n            request=request,\n            dependant=dependant,\n            body=body,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, background_tasks, sub_response, _ = solved_result\n        if errors:\n            raise RequestValidationError(errors, body=body)\n        else:\n            assert dependant.call is not None, \"dependant.call must be a function\"\n            if is_coroutine:\n                raw_response = await dependant.call(**values)\n            else:\n                raw_response = await run_in_threadpool(dependant.call, **values)\n            if isinstance(raw_response, Response):\n                if raw_response.background is None:\n                    raw_response.background = background_tasks\n                return raw_response\n            response_data = await serialize_response(\n                field=response_field,\n                response=raw_response,\n                include=response_model_include,\n                exclude=response_model_exclude,\n                by_alias=response_model_by_alias,\n                exclude_unset=response_model_exclude_unset,\n                is_coroutine=is_coroutine,\n            )\n            response = response_class(\n                content=response_data,\n                status_code=status_code,\n                background=background_tasks,\n            )\n            response.headers.raw.extend(sub_response.headers.raw)\n            if sub_response.status_code:\n                response.status_code = sub_response.status_code\n            return response\n\n    return app\n\n\ndef get_websocket_app(\n    dependant: Dependant, dependency_overrides_provider: Any = None\n) -> Callable:\n    async def app(websocket: WebSocket) -> None:\n        solved_result = await solve_dependencies(\n            request=websocket,\n            dependant=dependant,\n            dependency_overrides_provider=dependency_overrides_provider,\n        )\n        values, errors, _, _2, _3 = solved_result\n        if errors:\n            await websocket.close(code=WS_1008_POLICY_VIOLATION)\n            raise WebSocketRequestValidationError(errors)\n        assert dependant.call is not None, \"dependant.call must be a function\"\n        await dependant.call(**values)\n\n    return app\n\n\nclass APIWebSocketRoute(routing.WebSocketRoute):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        name: str = None,\n        dependency_overrides_provider: Any = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.dependant = get_dependant(path=path, call=self.endpoint)\n        self.app = websocket_session(\n            get_websocket_app(\n                dependant=self.dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n        )\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n\n\nclass APIRoute(routing.Route):\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        name: str = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Optional[Type[Response]] = None,\n        dependency_overrides_provider: Any = None,\n        callbacks: Optional[List[\"APIRoute\"]] = None,\n    ) -> None:\n        self.path = path\n        self.endpoint = endpoint\n        self.name = get_name(endpoint) if name is None else name\n        self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n        if methods is None:\n            methods = [\"GET\"]\n        self.methods = set([method.upper() for method in methods])\n        self.unique_id = generate_operation_id_for_path(\n            name=self.name, path=self.path_format, method=list(methods)[0]\n        )\n        self.response_model = response_model\n        if self.response_model:\n            assert (\n                status_code not in STATUS_CODES_WITH_NO_BODY\n            ), f\"Status code {status_code} must not have a response body\"\n            response_name = \"Response_\" + self.unique_id\n            if PYDANTIC_1:\n                self.response_field: Optional[ModelField] = ModelField(\n                    name=response_name,\n                    type_=self.response_model,\n                    class_validators={},\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    field_info=FieldInfo(None),\n                )\n            else:\n                self.response_field: Optional[ModelField] = ModelField(  # type: ignore  # pragma: nocover\n                    name=response_name,\n                    type_=self.response_model,\n                    class_validators={},\n                    default=None,\n                    required=False,\n                    model_config=BaseConfig,\n                    schema=FieldInfo(None),\n                )\n            # Create a clone of the field, so that a Pydantic submodel is not returned\n            # as is just because it's an instance of a subclass of a more limited class\n            # e.g. UserInDB (containing hashed_password) could be a subclass of User\n            # that doesn't have the hashed_password. But because it's a subclass, it\n            # would pass the validation and be returned as is.\n            # By being a new field, no inheritance will be passed as is. A new model\n            # will be always created.\n            self.secure_cloned_response_field: Optional[\n                ModelField\n            ] = create_cloned_field(self.response_field)\n        else:\n            self.response_field = None\n            self.secure_cloned_response_field = None\n        self.status_code = status_code\n        self.tags = tags or []\n        if dependencies:\n            self.dependencies = list(dependencies)\n        else:\n            self.dependencies = []\n        self.summary = summary\n        self.description = description or inspect.cleandoc(self.endpoint.__doc__ or \"\")\n        # if a \"form feed\" character (page break) is found in the description text,\n        # truncate description text to the content preceding the first \"form feed\"\n        self.description = self.description.split(\"\\f\")[0]\n        self.response_description = response_description\n        self.responses = responses or {}\n        response_fields = {}\n        for additional_status_code, response in self.responses.items():\n            assert isinstance(response, dict), \"An additional response must be a dict\"\n            model = response.get(\"model\")\n            if model:\n                assert (\n                    additional_status_code not in STATUS_CODES_WITH_NO_BODY\n                ), f\"Status code {additional_status_code} must not have a response body\"\n                assert lenient_issubclass(\n                    model, BaseModel\n                ), \"A response model must be a Pydantic model\"\n                response_name = f\"Response_{additional_status_code}_{self.unique_id}\"\n                if PYDANTIC_1:\n                    response_field = ModelField(\n                        name=response_name,\n                        type_=model,\n                        class_validators=None,\n                        default=None,\n                        required=False,\n                        model_config=BaseConfig,\n                        field_info=FieldInfo(None),\n                    )\n                else:\n                    response_field = ModelField(  # type: ignore  # pragma: nocover\n                        name=response_name,\n                        type_=model,\n                        class_validators=None,\n                        default=None,\n                        required=False,\n                        model_config=BaseConfig,\n                        schema=FieldInfo(None),\n                    )\n                response_fields[additional_status_code] = response_field\n        if response_fields:\n            self.response_fields: Dict[Union[int, str], ModelField] = response_fields\n        else:\n            self.response_fields = {}\n        self.deprecated = deprecated\n        self.operation_id = operation_id\n        self.response_model_include = response_model_include\n        self.response_model_exclude = response_model_exclude\n        self.response_model_by_alias = response_model_by_alias\n        self.response_model_exclude_unset = response_model_exclude_unset\n        self.include_in_schema = include_in_schema\n        self.response_class = response_class\n\n        assert inspect.isfunction(endpoint) or inspect.ismethod(\n            endpoint\n        ), f\"An endpoint must be a function or method\"\n        self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\n        for depends in self.dependencies[::-1]:\n            self.dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=self.path_format),\n            )\n        self.body_field = get_body_field(dependant=self.dependant, name=self.unique_id)\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.callbacks = callbacks\n        self.app = request_response(self.get_route_handler())\n\n    def get_route_handler(self) -> Callable:\n        return get_request_handler(\n            dependant=self.dependant,\n            body_field=self.body_field,\n            status_code=self.status_code,\n            response_class=self.response_class or JSONResponse,\n            response_field=self.secure_cloned_response_field,\n            response_model_include=self.response_model_include,\n            response_model_exclude=self.response_model_exclude,\n            response_model_by_alias=self.response_model_by_alias,\n            response_model_exclude_unset=self.response_model_exclude_unset,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n        )\n\n\nclass APIRouter(routing.Router):\n    def __init__(\n        self,\n        routes: List[routing.BaseRoute] = None,\n        redirect_slashes: bool = True,\n        default: ASGIApp = None,\n        dependency_overrides_provider: Any = None,\n        route_class: Type[APIRoute] = APIRoute,\n        default_response_class: Type[Response] = None,\n    ) -> None:\n        super().__init__(\n            routes=routes, redirect_slashes=redirect_slashes, default=default\n        )\n        self.dependency_overrides_provider = dependency_overrides_provider\n        self.route_class = route_class\n        self.default_response_class = default_response_class\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: Optional[Union[Set[str], List[str]]] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        route_class_override: Optional[Type[APIRoute]] = None,\n        callbacks: List[APIRoute] = None,\n    ) -> None:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        route_class = route_class_override or self.route_class\n        route = route_class(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            callbacks=callbacks,\n        )\n        self.routes.append(route)\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n\n        def decorator(func: Callable) -> Callable:\n            self.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=bool(\n                    response_model_exclude_unset or response_model_skip_defaults\n                ),\n                include_in_schema=include_in_schema,\n                response_class=response_class or self.default_response_class,\n                name=name,\n                callbacks=callbacks,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        route = APIWebSocketRoute(path, endpoint=endpoint, name=name)\n        self.routes.append(route)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        default_response_class: Optional[Type[Response]] = None,\n    ) -> None:\n        if prefix:\n            assert prefix.startswith(\"/\"), \"A path prefix must start with '/'\"\n            assert not prefix.endswith(\n                \"/\"\n            ), \"A path prefix must not end with '/', as the routes will start with '/'\"\n        else:\n            for r in router.routes:\n                path = getattr(r, \"path\")\n                name = getattr(r, \"name\", \"unknown\")\n                if path is not None and not path:\n                    raise Exception(\n                        f\"Prefix and path cannot be both empty (path operation: {name})\"\n                    )\n        if responses is None:\n            responses = {}\n        for route in router.routes:\n            if isinstance(route, APIRoute):\n                combined_responses = {**responses, **route.responses}\n                self.add_api_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    response_model=route.response_model,\n                    status_code=route.status_code,\n                    tags=(route.tags or []) + (tags or []),\n                    dependencies=list(dependencies or [])\n                    + list(route.dependencies or []),\n                    summary=route.summary,\n                    description=route.description,\n                    response_description=route.response_description,\n                    responses=combined_responses,\n                    deprecated=route.deprecated,\n                    methods=route.methods,\n                    operation_id=route.operation_id,\n                    response_model_include=route.response_model_include,\n                    response_model_exclude=route.response_model_exclude,\n                    response_model_by_alias=route.response_model_by_alias,\n                    response_model_exclude_unset=route.response_model_exclude_unset,\n                    include_in_schema=route.include_in_schema,\n                    response_class=route.response_class or default_response_class,\n                    name=route.name,\n                    route_class_override=type(route),\n                    callbacks=route.callbacks,\n                )\n            elif isinstance(route, routing.Route):\n                self.add_route(\n                    prefix + route.path,\n                    route.endpoint,\n                    methods=list(route.methods or []),\n                    include_in_schema=route.include_in_schema,\n                    name=route.name,\n                )\n            elif isinstance(route, APIWebSocketRoute):\n                self.add_api_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n            elif isinstance(route, routing.WebSocketRoute):\n                self.add_websocket_route(\n                    prefix + route.path, route.endpoint, name=route.name\n                )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"GET\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PUT\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"POST\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"DELETE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"OPTIONS\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"HEAD\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"PATCH\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[params.Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.api_route(\n            path=path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=[\"TRACE\"],\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n", "diff": "@@ -47,7 +47,7 @@ except ImportError:  # pragma: nocover\n     from pydantic.fields import Field as ModelField  # type: ignore\n \n \n-def serialize_response(\n+async def serialize_response(\n     *,\n     field: ModelField = None,\n     response: Response,\n@@ -55,6 +55,7 @@ def serialize_response(\n     exclude: Union[SetIntStr, DictIntStrAny] = set(),\n     by_alias: bool = True,\n     exclude_unset: bool = False,\n+    is_coroutine: bool = True,\n ) -> Any:\n     if field:\n         errors = []\n@@ -63,7 +64,12 @@ def serialize_response(\n                 response = response.dict(exclude_unset=exclude_unset)\n             else:\n                 response = response.dict(skip_defaults=exclude_unset)  # pragma: nocover\n-        value, errors_ = field.validate(response, {}, loc=(\"response\",))\n+        if is_coroutine:\n+            value, errors_ = field.validate(response, {}, loc=(\"response\",))\n+        else:\n+            value, errors_ = await run_in_threadpool(\n+                field.validate, response, {}, loc=(\"response\",)\n+            )\n         if isinstance(errors_, ErrorWrapper):\n             errors.append(errors_)\n         elif isinstance(errors_, list):\n@@ -131,13 +137,14 @@ def get_request_handler(\n                 if raw_response.background is None:\n                     raw_response.background = background_tasks\n                 return raw_response\n-            response_data = serialize_response(\n+            response_data = await serialize_response(\n                 field=response_field,\n                 response=raw_response,\n                 include=response_model_include,\n                 exclude=response_model_exclude,\n                 by_alias=response_model_by_alias,\n                 exclude_unset=response_model_exclude_unset,\n+                is_coroutine=is_coroutine,\n             )\n             response = response_class(\n                 content=response_data,\n"}
{"commit_hash": "530fc8ff3f3c788473304b15f600b75ac553b978", "issue_description": "\ud83d\udc1b Fix JSON Schema \"not\" keyword (#1548)", "code_before": "from enum import Enum\nfrom typing import Any, Callable, Dict, Iterable, List, Optional, Union\n\nfrom fastapi.logger import logger\nfrom pydantic import BaseModel\n\ntry:\n    from pydantic import AnyUrl, Field\nexcept ImportError:  # pragma: nocover\n    # TODO: remove when removing support for Pydantic < 1.0.0\n    from pydantic import Schema as Field  # type: ignore\n    from pydantic import UrlStr as AnyUrl  # type: ignore\n\ntry:\n    import email_validator\n\n    assert email_validator  # make autoflake ignore the unused import\n    try:\n        from pydantic import EmailStr\n    except ImportError:  # pragma: nocover\n        # TODO: remove when removing support for Pydantic < 1.0.0\n        from pydantic.types import EmailStr  # type: ignore\nexcept ImportError:  # pragma: no cover\n\n    class EmailStr(str):  # type: ignore\n        @classmethod\n        def __get_validators__(cls) -> Iterable[Callable]:\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, v: Any) -> str:\n            logger.warning(\n                \"email-validator not installed, email fields will be treated as str.\\n\"\n                \"To install, run: pip install email-validator\"\n            )\n            return str(v)\n\n\nclass Contact(BaseModel):\n    name: Optional[str] = None\n    url: Optional[AnyUrl] = None\n    email: Optional[EmailStr] = None\n\n\nclass License(BaseModel):\n    name: str\n    url: Optional[AnyUrl] = None\n\n\nclass Info(BaseModel):\n    title: str\n    description: Optional[str] = None\n    termsOfService: Optional[str] = None\n    contact: Optional[Contact] = None\n    license: Optional[License] = None\n    version: str\n\n\nclass ServerVariable(BaseModel):\n    enum: Optional[List[str]] = None\n    default: str\n    description: Optional[str] = None\n\n\nclass Server(BaseModel):\n    url: Union[AnyUrl, str]\n    description: Optional[str] = None\n    variables: Optional[Dict[str, ServerVariable]] = None\n\n\nclass Reference(BaseModel):\n    ref: str = Field(..., alias=\"$ref\")\n\n\nclass Discriminator(BaseModel):\n    propertyName: str\n    mapping: Optional[Dict[str, str]] = None\n\n\nclass XML(BaseModel):\n    name: Optional[str] = None\n    namespace: Optional[str] = None\n    prefix: Optional[str] = None\n    attribute: Optional[bool] = None\n    wrapped: Optional[bool] = None\n\n\nclass ExternalDocumentation(BaseModel):\n    description: Optional[str] = None\n    url: AnyUrl\n\n\nclass SchemaBase(BaseModel):\n    ref: Optional[str] = Field(None, alias=\"$ref\")\n    title: Optional[str] = None\n    multipleOf: Optional[float] = None\n    maximum: Optional[float] = None\n    exclusiveMaximum: Optional[float] = None\n    minimum: Optional[float] = None\n    exclusiveMinimum: Optional[float] = None\n    maxLength: Optional[int] = Field(None, gte=0)\n    minLength: Optional[int] = Field(None, gte=0)\n    pattern: Optional[str] = None\n    maxItems: Optional[int] = Field(None, gte=0)\n    minItems: Optional[int] = Field(None, gte=0)\n    uniqueItems: Optional[bool] = None\n    maxProperties: Optional[int] = Field(None, gte=0)\n    minProperties: Optional[int] = Field(None, gte=0)\n    required: Optional[List[str]] = None\n    enum: Optional[List[Any]] = None\n    type: Optional[str] = None\n    allOf: Optional[List[Any]] = None\n    oneOf: Optional[List[Any]] = None\n    anyOf: Optional[List[Any]] = None\n    not_: Optional[List[Any]] = Field(None, alias=\"not\")\n    items: Optional[Any] = None\n    properties: Optional[Dict[str, Any]] = None\n    additionalProperties: Optional[Union[Dict[str, Any], bool]] = None\n    description: Optional[str] = None\n    format: Optional[str] = None\n    default: Optional[Any] = None\n    nullable: Optional[bool] = None\n    discriminator: Optional[Discriminator] = None\n    readOnly: Optional[bool] = None\n    writeOnly: Optional[bool] = None\n    xml: Optional[XML] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    example: Optional[Any] = None\n    deprecated: Optional[bool] = None\n\n\nclass Schema(SchemaBase):\n    allOf: Optional[List[SchemaBase]] = None\n    oneOf: Optional[List[SchemaBase]] = None\n    anyOf: Optional[List[SchemaBase]] = None\n    not_: Optional[List[SchemaBase]] = Field(None, alias=\"not\")\n    items: Optional[SchemaBase] = None\n    properties: Optional[Dict[str, SchemaBase]] = None\n    additionalProperties: Optional[Union[Dict[str, Any], bool]] = None\n\n\nclass Example(BaseModel):\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    value: Optional[Any] = None\n    externalValue: Optional[AnyUrl] = None\n\n\nclass ParameterInType(Enum):\n    query = \"query\"\n    header = \"header\"\n    path = \"path\"\n    cookie = \"cookie\"\n\n\nclass Encoding(BaseModel):\n    contentType: Optional[str] = None\n    # Workaround OpenAPI recursive reference, using Any\n    headers: Optional[Dict[str, Union[Any, Reference]]] = None\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n\n\nclass MediaType(BaseModel):\n    schema_: Optional[Union[Schema, Reference]] = Field(None, alias=\"schema\")\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    encoding: Optional[Dict[str, Encoding]] = None\n\n\nclass ParameterBase(BaseModel):\n    description: Optional[str] = None\n    required: Optional[bool] = None\n    deprecated: Optional[bool] = None\n    # Serialization rules for simple scenarios\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n    schema_: Optional[Union[Schema, Reference]] = Field(None, alias=\"schema\")\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    # Serialization rules for more complex scenarios\n    content: Optional[Dict[str, MediaType]] = None\n\n\nclass Parameter(ParameterBase):\n    name: str\n    in_: ParameterInType = Field(..., alias=\"in\")\n\n\nclass Header(ParameterBase):\n    pass\n\n\n# Workaround OpenAPI recursive reference\nclass EncodingWithHeaders(Encoding):\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n\n\nclass RequestBody(BaseModel):\n    description: Optional[str] = None\n    content: Dict[str, MediaType]\n    required: Optional[bool] = None\n\n\nclass Link(BaseModel):\n    operationRef: Optional[str] = None\n    operationId: Optional[str] = None\n    parameters: Optional[Dict[str, Union[Any, str]]] = None\n    requestBody: Optional[Union[Any, str]] = None\n    description: Optional[str] = None\n    server: Optional[Server] = None\n\n\nclass Response(BaseModel):\n    description: str\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    content: Optional[Dict[str, MediaType]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n\n\nclass Operation(BaseModel):\n    tags: Optional[List[str]] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    operationId: Optional[str] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n    requestBody: Optional[Union[RequestBody, Reference]] = None\n    responses: Dict[str, Response]\n    # Workaround OpenAPI recursive reference\n    callbacks: Optional[Dict[str, Union[Dict[str, Any], Reference]]] = None\n    deprecated: Optional[bool] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    servers: Optional[List[Server]] = None\n\n\nclass PathItem(BaseModel):\n    ref: Optional[str] = Field(None, alias=\"$ref\")\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    get: Optional[Operation] = None\n    put: Optional[Operation] = None\n    post: Optional[Operation] = None\n    delete: Optional[Operation] = None\n    options: Optional[Operation] = None\n    head: Optional[Operation] = None\n    patch: Optional[Operation] = None\n    trace: Optional[Operation] = None\n    servers: Optional[List[Server]] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n\n\n# Workaround OpenAPI recursive reference\nclass OperationWithCallbacks(BaseModel):\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference]]] = None\n\n\nclass SecuritySchemeType(Enum):\n    apiKey = \"apiKey\"\n    http = \"http\"\n    oauth2 = \"oauth2\"\n    openIdConnect = \"openIdConnect\"\n\n\nclass SecurityBase(BaseModel):\n    type_: SecuritySchemeType = Field(..., alias=\"type\")\n    description: Optional[str] = None\n\n\nclass APIKeyIn(Enum):\n    query = \"query\"\n    header = \"header\"\n    cookie = \"cookie\"\n\n\nclass APIKey(SecurityBase):\n    type_ = Field(SecuritySchemeType.apiKey, alias=\"type\")\n    in_: APIKeyIn = Field(..., alias=\"in\")\n    name: str\n\n\nclass HTTPBase(SecurityBase):\n    type_ = Field(SecuritySchemeType.http, alias=\"type\")\n    scheme: str\n\n\nclass HTTPBearer(HTTPBase):\n    scheme = \"bearer\"\n    bearerFormat: Optional[str] = None\n\n\nclass OAuthFlow(BaseModel):\n    refreshUrl: Optional[str] = None\n    scopes: Dict[str, str] = {}\n\n\nclass OAuthFlowImplicit(OAuthFlow):\n    authorizationUrl: str\n\n\nclass OAuthFlowPassword(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowClientCredentials(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowAuthorizationCode(OAuthFlow):\n    authorizationUrl: str\n    tokenUrl: str\n\n\nclass OAuthFlows(BaseModel):\n    implicit: Optional[OAuthFlowImplicit] = None\n    password: Optional[OAuthFlowPassword] = None\n    clientCredentials: Optional[OAuthFlowClientCredentials] = None\n    authorizationCode: Optional[OAuthFlowAuthorizationCode] = None\n\n\nclass OAuth2(SecurityBase):\n    type_ = Field(SecuritySchemeType.oauth2, alias=\"type\")\n    flows: OAuthFlows\n\n\nclass OpenIdConnect(SecurityBase):\n    type_ = Field(SecuritySchemeType.openIdConnect, alias=\"type\")\n    openIdConnectUrl: str\n\n\nSecurityScheme = Union[APIKey, HTTPBase, OAuth2, OpenIdConnect, HTTPBearer]\n\n\nclass Components(BaseModel):\n    schemas: Optional[Dict[str, Union[Schema, Reference]]] = None\n    responses: Optional[Dict[str, Union[Response, Reference]]] = None\n    parameters: Optional[Dict[str, Union[Parameter, Reference]]] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    requestBodies: Optional[Dict[str, Union[RequestBody, Reference]]] = None\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    securitySchemes: Optional[Dict[str, Union[SecurityScheme, Reference]]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference]]] = None\n\n\nclass Tag(BaseModel):\n    name: str\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n\n\nclass OpenAPI(BaseModel):\n    openapi: str\n    info: Info\n    servers: Optional[List[Server]] = None\n    paths: Dict[str, PathItem]\n    components: Optional[Components] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    tags: Optional[List[Tag]] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n", "fix_code": "from enum import Enum\nfrom typing import Any, Callable, Dict, Iterable, List, Optional, Union\n\nfrom fastapi.logger import logger\nfrom pydantic import BaseModel\n\ntry:\n    from pydantic import AnyUrl, Field\nexcept ImportError:  # pragma: nocover\n    # TODO: remove when removing support for Pydantic < 1.0.0\n    from pydantic import Schema as Field  # type: ignore\n    from pydantic import UrlStr as AnyUrl  # type: ignore\n\ntry:\n    import email_validator\n\n    assert email_validator  # make autoflake ignore the unused import\n    try:\n        from pydantic import EmailStr\n    except ImportError:  # pragma: nocover\n        # TODO: remove when removing support for Pydantic < 1.0.0\n        from pydantic.types import EmailStr  # type: ignore\nexcept ImportError:  # pragma: no cover\n\n    class EmailStr(str):  # type: ignore\n        @classmethod\n        def __get_validators__(cls) -> Iterable[Callable]:\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, v: Any) -> str:\n            logger.warning(\n                \"email-validator not installed, email fields will be treated as str.\\n\"\n                \"To install, run: pip install email-validator\"\n            )\n            return str(v)\n\n\nclass Contact(BaseModel):\n    name: Optional[str] = None\n    url: Optional[AnyUrl] = None\n    email: Optional[EmailStr] = None\n\n\nclass License(BaseModel):\n    name: str\n    url: Optional[AnyUrl] = None\n\n\nclass Info(BaseModel):\n    title: str\n    description: Optional[str] = None\n    termsOfService: Optional[str] = None\n    contact: Optional[Contact] = None\n    license: Optional[License] = None\n    version: str\n\n\nclass ServerVariable(BaseModel):\n    enum: Optional[List[str]] = None\n    default: str\n    description: Optional[str] = None\n\n\nclass Server(BaseModel):\n    url: Union[AnyUrl, str]\n    description: Optional[str] = None\n    variables: Optional[Dict[str, ServerVariable]] = None\n\n\nclass Reference(BaseModel):\n    ref: str = Field(..., alias=\"$ref\")\n\n\nclass Discriminator(BaseModel):\n    propertyName: str\n    mapping: Optional[Dict[str, str]] = None\n\n\nclass XML(BaseModel):\n    name: Optional[str] = None\n    namespace: Optional[str] = None\n    prefix: Optional[str] = None\n    attribute: Optional[bool] = None\n    wrapped: Optional[bool] = None\n\n\nclass ExternalDocumentation(BaseModel):\n    description: Optional[str] = None\n    url: AnyUrl\n\n\nclass SchemaBase(BaseModel):\n    ref: Optional[str] = Field(None, alias=\"$ref\")\n    title: Optional[str] = None\n    multipleOf: Optional[float] = None\n    maximum: Optional[float] = None\n    exclusiveMaximum: Optional[float] = None\n    minimum: Optional[float] = None\n    exclusiveMinimum: Optional[float] = None\n    maxLength: Optional[int] = Field(None, gte=0)\n    minLength: Optional[int] = Field(None, gte=0)\n    pattern: Optional[str] = None\n    maxItems: Optional[int] = Field(None, gte=0)\n    minItems: Optional[int] = Field(None, gte=0)\n    uniqueItems: Optional[bool] = None\n    maxProperties: Optional[int] = Field(None, gte=0)\n    minProperties: Optional[int] = Field(None, gte=0)\n    required: Optional[List[str]] = None\n    enum: Optional[List[Any]] = None\n    type: Optional[str] = None\n    allOf: Optional[List[Any]] = None\n    oneOf: Optional[List[Any]] = None\n    anyOf: Optional[List[Any]] = None\n    not_: Optional[Any] = Field(None, alias=\"not\")\n    items: Optional[Any] = None\n    properties: Optional[Dict[str, Any]] = None\n    additionalProperties: Optional[Union[Dict[str, Any], bool]] = None\n    description: Optional[str] = None\n    format: Optional[str] = None\n    default: Optional[Any] = None\n    nullable: Optional[bool] = None\n    discriminator: Optional[Discriminator] = None\n    readOnly: Optional[bool] = None\n    writeOnly: Optional[bool] = None\n    xml: Optional[XML] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    example: Optional[Any] = None\n    deprecated: Optional[bool] = None\n\n\nclass Schema(SchemaBase):\n    allOf: Optional[List[SchemaBase]] = None\n    oneOf: Optional[List[SchemaBase]] = None\n    anyOf: Optional[List[SchemaBase]] = None\n    not_: Optional[SchemaBase] = Field(None, alias=\"not\")\n    items: Optional[SchemaBase] = None\n    properties: Optional[Dict[str, SchemaBase]] = None\n    additionalProperties: Optional[Union[Dict[str, Any], bool]] = None\n\n\nclass Example(BaseModel):\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    value: Optional[Any] = None\n    externalValue: Optional[AnyUrl] = None\n\n\nclass ParameterInType(Enum):\n    query = \"query\"\n    header = \"header\"\n    path = \"path\"\n    cookie = \"cookie\"\n\n\nclass Encoding(BaseModel):\n    contentType: Optional[str] = None\n    # Workaround OpenAPI recursive reference, using Any\n    headers: Optional[Dict[str, Union[Any, Reference]]] = None\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n\n\nclass MediaType(BaseModel):\n    schema_: Optional[Union[Schema, Reference]] = Field(None, alias=\"schema\")\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    encoding: Optional[Dict[str, Encoding]] = None\n\n\nclass ParameterBase(BaseModel):\n    description: Optional[str] = None\n    required: Optional[bool] = None\n    deprecated: Optional[bool] = None\n    # Serialization rules for simple scenarios\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n    schema_: Optional[Union[Schema, Reference]] = Field(None, alias=\"schema\")\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    # Serialization rules for more complex scenarios\n    content: Optional[Dict[str, MediaType]] = None\n\n\nclass Parameter(ParameterBase):\n    name: str\n    in_: ParameterInType = Field(..., alias=\"in\")\n\n\nclass Header(ParameterBase):\n    pass\n\n\n# Workaround OpenAPI recursive reference\nclass EncodingWithHeaders(Encoding):\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n\n\nclass RequestBody(BaseModel):\n    description: Optional[str] = None\n    content: Dict[str, MediaType]\n    required: Optional[bool] = None\n\n\nclass Link(BaseModel):\n    operationRef: Optional[str] = None\n    operationId: Optional[str] = None\n    parameters: Optional[Dict[str, Union[Any, str]]] = None\n    requestBody: Optional[Union[Any, str]] = None\n    description: Optional[str] = None\n    server: Optional[Server] = None\n\n\nclass Response(BaseModel):\n    description: str\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    content: Optional[Dict[str, MediaType]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n\n\nclass Operation(BaseModel):\n    tags: Optional[List[str]] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    operationId: Optional[str] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n    requestBody: Optional[Union[RequestBody, Reference]] = None\n    responses: Dict[str, Response]\n    # Workaround OpenAPI recursive reference\n    callbacks: Optional[Dict[str, Union[Dict[str, Any], Reference]]] = None\n    deprecated: Optional[bool] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    servers: Optional[List[Server]] = None\n\n\nclass PathItem(BaseModel):\n    ref: Optional[str] = Field(None, alias=\"$ref\")\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    get: Optional[Operation] = None\n    put: Optional[Operation] = None\n    post: Optional[Operation] = None\n    delete: Optional[Operation] = None\n    options: Optional[Operation] = None\n    head: Optional[Operation] = None\n    patch: Optional[Operation] = None\n    trace: Optional[Operation] = None\n    servers: Optional[List[Server]] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n\n\n# Workaround OpenAPI recursive reference\nclass OperationWithCallbacks(BaseModel):\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference]]] = None\n\n\nclass SecuritySchemeType(Enum):\n    apiKey = \"apiKey\"\n    http = \"http\"\n    oauth2 = \"oauth2\"\n    openIdConnect = \"openIdConnect\"\n\n\nclass SecurityBase(BaseModel):\n    type_: SecuritySchemeType = Field(..., alias=\"type\")\n    description: Optional[str] = None\n\n\nclass APIKeyIn(Enum):\n    query = \"query\"\n    header = \"header\"\n    cookie = \"cookie\"\n\n\nclass APIKey(SecurityBase):\n    type_ = Field(SecuritySchemeType.apiKey, alias=\"type\")\n    in_: APIKeyIn = Field(..., alias=\"in\")\n    name: str\n\n\nclass HTTPBase(SecurityBase):\n    type_ = Field(SecuritySchemeType.http, alias=\"type\")\n    scheme: str\n\n\nclass HTTPBearer(HTTPBase):\n    scheme = \"bearer\"\n    bearerFormat: Optional[str] = None\n\n\nclass OAuthFlow(BaseModel):\n    refreshUrl: Optional[str] = None\n    scopes: Dict[str, str] = {}\n\n\nclass OAuthFlowImplicit(OAuthFlow):\n    authorizationUrl: str\n\n\nclass OAuthFlowPassword(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowClientCredentials(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowAuthorizationCode(OAuthFlow):\n    authorizationUrl: str\n    tokenUrl: str\n\n\nclass OAuthFlows(BaseModel):\n    implicit: Optional[OAuthFlowImplicit] = None\n    password: Optional[OAuthFlowPassword] = None\n    clientCredentials: Optional[OAuthFlowClientCredentials] = None\n    authorizationCode: Optional[OAuthFlowAuthorizationCode] = None\n\n\nclass OAuth2(SecurityBase):\n    type_ = Field(SecuritySchemeType.oauth2, alias=\"type\")\n    flows: OAuthFlows\n\n\nclass OpenIdConnect(SecurityBase):\n    type_ = Field(SecuritySchemeType.openIdConnect, alias=\"type\")\n    openIdConnectUrl: str\n\n\nSecurityScheme = Union[APIKey, HTTPBase, OAuth2, OpenIdConnect, HTTPBearer]\n\n\nclass Components(BaseModel):\n    schemas: Optional[Dict[str, Union[Schema, Reference]]] = None\n    responses: Optional[Dict[str, Union[Response, Reference]]] = None\n    parameters: Optional[Dict[str, Union[Parameter, Reference]]] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    requestBodies: Optional[Dict[str, Union[RequestBody, Reference]]] = None\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    securitySchemes: Optional[Dict[str, Union[SecurityScheme, Reference]]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference]]] = None\n\n\nclass Tag(BaseModel):\n    name: str\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n\n\nclass OpenAPI(BaseModel):\n    openapi: str\n    info: Info\n    servers: Optional[List[Server]] = None\n    paths: Dict[str, PathItem]\n    components: Optional[Components] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    tags: Optional[List[Tag]] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n", "diff": "@@ -112,7 +112,7 @@ class SchemaBase(BaseModel):\n     allOf: Optional[List[Any]] = None\n     oneOf: Optional[List[Any]] = None\n     anyOf: Optional[List[Any]] = None\n-    not_: Optional[List[Any]] = Field(None, alias=\"not\")\n+    not_: Optional[Any] = Field(None, alias=\"not\")\n     items: Optional[Any] = None\n     properties: Optional[Dict[str, Any]] = None\n     additionalProperties: Optional[Union[Dict[str, Any], bool]] = None\n@@ -133,7 +133,7 @@ class Schema(SchemaBase):\n     allOf: Optional[List[SchemaBase]] = None\n     oneOf: Optional[List[SchemaBase]] = None\n     anyOf: Optional[List[SchemaBase]] = None\n-    not_: Optional[List[SchemaBase]] = Field(None, alias=\"not\")\n+    not_: Optional[SchemaBase] = Field(None, alias=\"not\")\n     items: Optional[SchemaBase] = None\n     properties: Optional[Dict[str, SchemaBase]] = None\n     additionalProperties: Optional[Union[Dict[str, Any], bool]] = None\n"}
{"commit_hash": "39766d0f96d3bb80b3b0d2f3543f37027ac93cbf", "issue_description": "\ud83d\udc1b Fix link in warning logs (#1611)\n\nCo-authored-by: Dmytro Petruk <petruk@ebu.ch>", "code_before": "from typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union\n\nfrom fastapi import routing\nfrom fastapi.concurrency import AsyncExitStack\nfrom fastapi.encoders import DictIntStrAny, SetIntStr\nfrom fastapi.exception_handlers import (\n    http_exception_handler,\n    request_validation_exception_handler,\n)\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.logger import logger\nfrom fastapi.openapi.docs import (\n    get_redoc_html,\n    get_swagger_ui_html,\n    get_swagger_ui_oauth2_redirect_html,\n)\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.params import Depends\nfrom fastapi.utils import warning_response_model_skip_defaults_deprecated\nfrom starlette.applications import Starlette\nfrom starlette.datastructures import State\nfrom starlette.exceptions import HTTPException\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, JSONResponse, Response\nfrom starlette.routing import BaseRoute\nfrom starlette.types import Receive, Scope, Send\n\n\nclass FastAPI(Starlette):\n    def __init__(\n        self,\n        *,\n        debug: bool = False,\n        routes: List[BaseRoute] = None,\n        title: str = \"FastAPI\",\n        description: str = \"\",\n        version: str = \"0.1.0\",\n        openapi_url: Optional[str] = \"/openapi.json\",\n        openapi_tags: Optional[List[Dict[str, Any]]] = None,\n        servers: Optional[List[Dict[str, Union[str, Any]]]] = None,\n        default_response_class: Type[Response] = JSONResponse,\n        docs_url: Optional[str] = \"/docs\",\n        redoc_url: Optional[str] = \"/redoc\",\n        swagger_ui_oauth2_redirect_url: Optional[str] = \"/docs/oauth2-redirect\",\n        swagger_ui_init_oauth: Optional[dict] = None,\n        middleware: Sequence[Middleware] = None,\n        exception_handlers: Dict[Union[int, Type[Exception]], Callable] = None,\n        on_startup: Sequence[Callable] = None,\n        on_shutdown: Sequence[Callable] = None,\n        openapi_prefix: str = \"\",\n        root_path: str = \"\",\n        **extra: Dict[str, Any],\n    ) -> None:\n        self.default_response_class = default_response_class\n        self._debug = debug\n        self.state = State()\n        self.router: routing.APIRouter = routing.APIRouter(\n            routes,\n            dependency_overrides_provider=self,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n        )\n        self.exception_handlers = (\n            {} if exception_handlers is None else dict(exception_handlers)\n        )\n\n        self.user_middleware = [] if middleware is None else list(middleware)\n        self.middleware_stack = self.build_middleware_stack()\n\n        self.title = title\n        self.description = description\n        self.version = version\n        self.servers = servers\n        self.openapi_url = openapi_url\n        self.openapi_tags = openapi_tags\n        # TODO: remove when discarding the openapi_prefix parameter\n        if openapi_prefix:\n            logger.warning(\n                '\"openapi_prefix\" has been deprecated in favor of \"root_path\", which '\n                \"follows more closely the ASGI standard, is simpler, and more \"\n                \"automatic. Check the docs at \"\n                \"https://fastapi.tiangolo.com/advanced/sub-applications-proxy/\"\n            )\n        self.root_path = root_path or openapi_prefix\n        self.docs_url = docs_url\n        self.redoc_url = redoc_url\n        self.swagger_ui_oauth2_redirect_url = swagger_ui_oauth2_redirect_url\n        self.swagger_ui_init_oauth = swagger_ui_init_oauth\n        self.extra = extra\n        self.dependency_overrides: Dict[Callable, Callable] = {}\n\n        self.openapi_version = \"3.0.2\"\n\n        if self.openapi_url:\n            assert self.title, \"A title must be provided for OpenAPI, e.g.: 'My API'\"\n            assert self.version, \"A version must be provided for OpenAPI, e.g.: '2.1.0'\"\n        self.openapi_schema: Optional[Dict[str, Any]] = None\n        self.setup()\n\n    def openapi(self, openapi_prefix: str = \"\") -> Dict:\n        if not self.openapi_schema:\n            self.openapi_schema = get_openapi(\n                title=self.title,\n                version=self.version,\n                openapi_version=self.openapi_version,\n                description=self.description,\n                routes=self.routes,\n                openapi_prefix=openapi_prefix,\n                tags=self.openapi_tags,\n                servers=self.servers,\n            )\n        return self.openapi_schema\n\n    def setup(self) -> None:\n        if self.openapi_url:\n\n            async def openapi(req: Request) -> JSONResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                return JSONResponse(self.openapi(root_path))\n\n            self.add_route(self.openapi_url, openapi, include_in_schema=False)\n        if self.openapi_url and self.docs_url:\n\n            async def swagger_ui_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n                if oauth2_redirect_url:\n                    oauth2_redirect_url = root_path + oauth2_redirect_url\n                return get_swagger_ui_html(\n                    openapi_url=openapi_url,\n                    title=self.title + \" - Swagger UI\",\n                    oauth2_redirect_url=oauth2_redirect_url,\n                    init_oauth=self.swagger_ui_init_oauth,\n                )\n\n            self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n\n            if self.swagger_ui_oauth2_redirect_url:\n\n                async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                    return get_swagger_ui_oauth2_redirect_html()\n\n                self.add_route(\n                    self.swagger_ui_oauth2_redirect_url,\n                    swagger_ui_redirect,\n                    include_in_schema=False,\n                )\n        if self.openapi_url and self.redoc_url:\n\n            async def redoc_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                return get_redoc_html(\n                    openapi_url=openapi_url, title=self.title + \" - ReDoc\"\n                )\n\n            self.add_route(self.redoc_url, redoc_html, include_in_schema=False)\n        self.add_exception_handler(HTTPException, http_exception_handler)\n        self.add_exception_handler(\n            RequestValidationError, request_validation_exception_handler\n        )\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.root_path:\n            scope[\"root_path\"] = self.root_path\n        if AsyncExitStack:\n            async with AsyncExitStack() as stack:\n                scope[\"fastapi_astack\"] = stack\n                await super().__call__(scope, receive, send)\n        else:\n            await super().__call__(scope, receive, send)  # pragma: no cover\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n    ) -> None:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        self.router.add_api_route(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n        )\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n\n        def decorator(func: Callable) -> Callable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=bool(\n                    response_model_exclude_unset or response_model_skip_defaults\n                ),\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class or self.default_response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        self.router.add_api_websocket_route(path, endpoint, name=name)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: routing.APIRouter,\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        default_response_class: Optional[Type[Response]] = None,\n    ) -> None:\n        self.router.include_router(\n            router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            responses=responses or {},\n            default_response_class=default_response_class\n            or self.default_response_class,\n        )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.get(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.put(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.post(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.delete(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            operation_id=operation_id,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.options(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.head(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.patch(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.trace(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n", "fix_code": "from typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union\n\nfrom fastapi import routing\nfrom fastapi.concurrency import AsyncExitStack\nfrom fastapi.encoders import DictIntStrAny, SetIntStr\nfrom fastapi.exception_handlers import (\n    http_exception_handler,\n    request_validation_exception_handler,\n)\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.logger import logger\nfrom fastapi.openapi.docs import (\n    get_redoc_html,\n    get_swagger_ui_html,\n    get_swagger_ui_oauth2_redirect_html,\n)\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.params import Depends\nfrom fastapi.utils import warning_response_model_skip_defaults_deprecated\nfrom starlette.applications import Starlette\nfrom starlette.datastructures import State\nfrom starlette.exceptions import HTTPException\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, JSONResponse, Response\nfrom starlette.routing import BaseRoute\nfrom starlette.types import Receive, Scope, Send\n\n\nclass FastAPI(Starlette):\n    def __init__(\n        self,\n        *,\n        debug: bool = False,\n        routes: List[BaseRoute] = None,\n        title: str = \"FastAPI\",\n        description: str = \"\",\n        version: str = \"0.1.0\",\n        openapi_url: Optional[str] = \"/openapi.json\",\n        openapi_tags: Optional[List[Dict[str, Any]]] = None,\n        servers: Optional[List[Dict[str, Union[str, Any]]]] = None,\n        default_response_class: Type[Response] = JSONResponse,\n        docs_url: Optional[str] = \"/docs\",\n        redoc_url: Optional[str] = \"/redoc\",\n        swagger_ui_oauth2_redirect_url: Optional[str] = \"/docs/oauth2-redirect\",\n        swagger_ui_init_oauth: Optional[dict] = None,\n        middleware: Sequence[Middleware] = None,\n        exception_handlers: Dict[Union[int, Type[Exception]], Callable] = None,\n        on_startup: Sequence[Callable] = None,\n        on_shutdown: Sequence[Callable] = None,\n        openapi_prefix: str = \"\",\n        root_path: str = \"\",\n        **extra: Dict[str, Any],\n    ) -> None:\n        self.default_response_class = default_response_class\n        self._debug = debug\n        self.state = State()\n        self.router: routing.APIRouter = routing.APIRouter(\n            routes,\n            dependency_overrides_provider=self,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n        )\n        self.exception_handlers = (\n            {} if exception_handlers is None else dict(exception_handlers)\n        )\n\n        self.user_middleware = [] if middleware is None else list(middleware)\n        self.middleware_stack = self.build_middleware_stack()\n\n        self.title = title\n        self.description = description\n        self.version = version\n        self.servers = servers\n        self.openapi_url = openapi_url\n        self.openapi_tags = openapi_tags\n        # TODO: remove when discarding the openapi_prefix parameter\n        if openapi_prefix:\n            logger.warning(\n                '\"openapi_prefix\" has been deprecated in favor of \"root_path\", which '\n                \"follows more closely the ASGI standard, is simpler, and more \"\n                \"automatic. Check the docs at \"\n                \"https://fastapi.tiangolo.com/advanced/sub-applications/\"\n            )\n        self.root_path = root_path or openapi_prefix\n        self.docs_url = docs_url\n        self.redoc_url = redoc_url\n        self.swagger_ui_oauth2_redirect_url = swagger_ui_oauth2_redirect_url\n        self.swagger_ui_init_oauth = swagger_ui_init_oauth\n        self.extra = extra\n        self.dependency_overrides: Dict[Callable, Callable] = {}\n\n        self.openapi_version = \"3.0.2\"\n\n        if self.openapi_url:\n            assert self.title, \"A title must be provided for OpenAPI, e.g.: 'My API'\"\n            assert self.version, \"A version must be provided for OpenAPI, e.g.: '2.1.0'\"\n        self.openapi_schema: Optional[Dict[str, Any]] = None\n        self.setup()\n\n    def openapi(self, openapi_prefix: str = \"\") -> Dict:\n        if not self.openapi_schema:\n            self.openapi_schema = get_openapi(\n                title=self.title,\n                version=self.version,\n                openapi_version=self.openapi_version,\n                description=self.description,\n                routes=self.routes,\n                openapi_prefix=openapi_prefix,\n                tags=self.openapi_tags,\n                servers=self.servers,\n            )\n        return self.openapi_schema\n\n    def setup(self) -> None:\n        if self.openapi_url:\n\n            async def openapi(req: Request) -> JSONResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                return JSONResponse(self.openapi(root_path))\n\n            self.add_route(self.openapi_url, openapi, include_in_schema=False)\n        if self.openapi_url and self.docs_url:\n\n            async def swagger_ui_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n                if oauth2_redirect_url:\n                    oauth2_redirect_url = root_path + oauth2_redirect_url\n                return get_swagger_ui_html(\n                    openapi_url=openapi_url,\n                    title=self.title + \" - Swagger UI\",\n                    oauth2_redirect_url=oauth2_redirect_url,\n                    init_oauth=self.swagger_ui_init_oauth,\n                )\n\n            self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n\n            if self.swagger_ui_oauth2_redirect_url:\n\n                async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                    return get_swagger_ui_oauth2_redirect_html()\n\n                self.add_route(\n                    self.swagger_ui_oauth2_redirect_url,\n                    swagger_ui_redirect,\n                    include_in_schema=False,\n                )\n        if self.openapi_url and self.redoc_url:\n\n            async def redoc_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                return get_redoc_html(\n                    openapi_url=openapi_url, title=self.title + \" - ReDoc\"\n                )\n\n            self.add_route(self.redoc_url, redoc_html, include_in_schema=False)\n        self.add_exception_handler(HTTPException, http_exception_handler)\n        self.add_exception_handler(\n            RequestValidationError, request_validation_exception_handler\n        )\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.root_path:\n            scope[\"root_path\"] = self.root_path\n        if AsyncExitStack:\n            async with AsyncExitStack() as stack:\n                scope[\"fastapi_astack\"] = stack\n                await super().__call__(scope, receive, send)\n        else:\n            await super().__call__(scope, receive, send)  # pragma: no cover\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n    ) -> None:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        self.router.add_api_route(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n        )\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n\n        def decorator(func: Callable) -> Callable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=bool(\n                    response_model_exclude_unset or response_model_skip_defaults\n                ),\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class or self.default_response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        self.router.add_api_websocket_route(path, endpoint, name=name)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: routing.APIRouter,\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        default_response_class: Optional[Type[Response]] = None,\n    ) -> None:\n        self.router.include_router(\n            router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            responses=responses or {},\n            default_response_class=default_response_class\n            or self.default_response_class,\n        )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.get(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.put(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.post(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.delete(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            operation_id=operation_id,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.options(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.head(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.patch(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.trace(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n", "diff": "@@ -80,7 +80,7 @@ class FastAPI(Starlette):\n                 '\"openapi_prefix\" has been deprecated in favor of \"root_path\", which '\n                 \"follows more closely the ASGI standard, is simpler, and more \"\n                 \"automatic. Check the docs at \"\n-                \"https://fastapi.tiangolo.com/advanced/sub-applications-proxy/\"\n+                \"https://fastapi.tiangolo.com/advanced/sub-applications/\"\n             )\n         self.root_path = root_path or openapi_prefix\n         self.docs_url = docs_url\n"}
{"commit_hash": "ff6afeaf78ef9864ed8987e0c5b6f0d127773413", "issue_description": "\u270f Fix docstring typo for oauth2 utils (#1621)", "code_before": "from typing import List, Optional\n\nfrom fastapi.exceptions import HTTPException\nfrom fastapi.openapi.models import OAuth2 as OAuth2Model\nfrom fastapi.openapi.models import OAuthFlows as OAuthFlowsModel\nfrom fastapi.param_functions import Form\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom starlette.requests import Request\nfrom starlette.status import HTTP_401_UNAUTHORIZED, HTTP_403_FORBIDDEN\n\n\nclass OAuth2PasswordRequestForm:\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: Oauth2PasswordRequestForm = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scopes:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n    \n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        Nevertheless, this dependency class is permissive and allows not passing it. If you want to enforce it,\n        use instead the OAuth2PasswordRequestFormStrict dependency.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(None, regex=\"password\"),\n        username: str = Form(...),\n        password: str = Form(...),\n        scope: str = Form(\"\"),\n        client_id: Optional[str] = Form(None),\n        client_secret: Optional[str] = Form(None),\n    ):\n        self.grant_type = grant_type\n        self.username = username\n        self.password = password\n        self.scopes = scope.split()\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n\nclass OAuth2PasswordRequestFormStrict(OAuth2PasswordRequestForm):\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: Oauth2PasswordRequestFormStrict = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scopes:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n    \n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        This dependency is strict about it. If you want to be permissive, use instead the\n        OAuth2PasswordRequestForm dependency class.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(..., regex=\"password\"),\n        username: str = Form(...),\n        password: str = Form(...),\n        scope: str = Form(\"\"),\n        client_id: Optional[str] = Form(None),\n        client_secret: Optional[str] = Form(None),\n    ):\n        super().__init__(\n            grant_type=grant_type,\n            username=username,\n            password=password,\n            scope=scope,\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n\nclass OAuth2(SecurityBase):\n    def __init__(\n        self,\n        *,\n        flows: OAuthFlowsModel = OAuthFlowsModel(),\n        scheme_name: str = None,\n        auto_error: bool = True\n    ):\n        self.model = OAuth2Model(flows=flows)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        if not authorization:\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        return authorization\n\n\nclass OAuth2PasswordBearer(OAuth2):\n    def __init__(\n        self,\n        tokenUrl: str,\n        scheme_name: str = None,\n        scopes: dict = None,\n        auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(password={\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        super().__init__(flows=flows, scheme_name=scheme_name, auto_error=auto_error)\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            else:\n                return None\n        return param\n\n\nclass OAuth2AuthorizationCodeBearer(OAuth2):\n    def __init__(\n        self,\n        authorizationUrl: str,\n        tokenUrl: str,\n        refreshUrl: str = None,\n        scheme_name: str = None,\n        scopes: dict = None,\n        auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(\n            authorizationCode={\n                \"authorizationUrl\": authorizationUrl,\n                \"tokenUrl\": tokenUrl,\n                \"refreshUrl\": refreshUrl,\n                \"scopes\": scopes,\n            }\n        )\n        super().__init__(flows=flows, scheme_name=scheme_name, auto_error=auto_error)\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            else:\n                return None  # pragma: nocover\n        return param\n\n\nclass SecurityScopes:\n    def __init__(self, scopes: List[str] = None):\n        self.scopes = scopes or []\n        self.scope_str = \" \".join(self.scopes)\n", "fix_code": "from typing import List, Optional\n\nfrom fastapi.exceptions import HTTPException\nfrom fastapi.openapi.models import OAuth2 as OAuth2Model\nfrom fastapi.openapi.models import OAuthFlows as OAuthFlowsModel\nfrom fastapi.param_functions import Form\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom starlette.requests import Request\nfrom starlette.status import HTTP_401_UNAUTHORIZED, HTTP_403_FORBIDDEN\n\n\nclass OAuth2PasswordRequestForm:\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: OAuth2PasswordRequestForm = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scopes:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n    \n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        Nevertheless, this dependency class is permissive and allows not passing it. If you want to enforce it,\n        use instead the OAuth2PasswordRequestFormStrict dependency.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(None, regex=\"password\"),\n        username: str = Form(...),\n        password: str = Form(...),\n        scope: str = Form(\"\"),\n        client_id: Optional[str] = Form(None),\n        client_secret: Optional[str] = Form(None),\n    ):\n        self.grant_type = grant_type\n        self.username = username\n        self.password = password\n        self.scopes = scope.split()\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n\nclass OAuth2PasswordRequestFormStrict(OAuth2PasswordRequestForm):\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: OAuth2PasswordRequestFormStrict = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scopes:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n    \n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        This dependency is strict about it. If you want to be permissive, use instead the\n        OAuth2PasswordRequestForm dependency class.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(..., regex=\"password\"),\n        username: str = Form(...),\n        password: str = Form(...),\n        scope: str = Form(\"\"),\n        client_id: Optional[str] = Form(None),\n        client_secret: Optional[str] = Form(None),\n    ):\n        super().__init__(\n            grant_type=grant_type,\n            username=username,\n            password=password,\n            scope=scope,\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n\nclass OAuth2(SecurityBase):\n    def __init__(\n        self,\n        *,\n        flows: OAuthFlowsModel = OAuthFlowsModel(),\n        scheme_name: str = None,\n        auto_error: bool = True\n    ):\n        self.model = OAuth2Model(flows=flows)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        if not authorization:\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        return authorization\n\n\nclass OAuth2PasswordBearer(OAuth2):\n    def __init__(\n        self,\n        tokenUrl: str,\n        scheme_name: str = None,\n        scopes: dict = None,\n        auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(password={\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        super().__init__(flows=flows, scheme_name=scheme_name, auto_error=auto_error)\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            else:\n                return None\n        return param\n\n\nclass OAuth2AuthorizationCodeBearer(OAuth2):\n    def __init__(\n        self,\n        authorizationUrl: str,\n        tokenUrl: str,\n        refreshUrl: str = None,\n        scheme_name: str = None,\n        scopes: dict = None,\n        auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(\n            authorizationCode={\n                \"authorizationUrl\": authorizationUrl,\n                \"tokenUrl\": tokenUrl,\n                \"refreshUrl\": refreshUrl,\n                \"scopes\": scopes,\n            }\n        )\n        super().__init__(flows=flows, scheme_name=scheme_name, auto_error=auto_error)\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            else:\n                return None  # pragma: nocover\n        return param\n\n\nclass SecurityScopes:\n    def __init__(self, scopes: List[str] = None):\n        self.scopes = scopes or []\n        self.scope_str = \" \".join(self.scopes)\n", "diff": "@@ -15,7 +15,7 @@ class OAuth2PasswordRequestForm:\n     This is a dependency class, use it like:\n \n         @app.post(\"/login\")\n-        def login(form_data: Oauth2PasswordRequestForm = Depends()):\n+        def login(form_data: OAuth2PasswordRequestForm = Depends()):\n             data = form_data.parse()\n             print(data.username)\n             print(data.password)\n@@ -65,7 +65,7 @@ class OAuth2PasswordRequestFormStrict(OAuth2PasswordRequestForm):\n     This is a dependency class, use it like:\n \n         @app.post(\"/login\")\n-        def login(form_data: Oauth2PasswordRequestFormStrict = Depends()):\n+        def login(form_data: OAuth2PasswordRequestFormStrict = Depends()):\n             data = form_data.parse()\n             print(data.username)\n             print(data.password)\n"}
{"commit_hash": "e0080e5f75b3f58309222591c529e4dbf1dcc895", "issue_description": "\ud83d\udc1b Fix Watch Previews action", "code_before": "import logging\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport httpx\nfrom github import Github\nfrom github.NamedUser import NamedUser\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_api = \"https://api.github.com\"\nnetlify_api = \"https://api.netlify.com\"\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    github_repository: str\n    github_event_path: Path\n    github_event_name: Optional[str] = None\n\n\nclass Artifact(BaseModel):\n    id: int\n    node_id: str\n    name: str\n    size_in_bytes: int\n    url: str\n    archive_download_url: str\n    expired: bool\n    created_at: datetime\n    updated_at: datetime\n\n\nclass ArtifactResponse(BaseModel):\n    total_count: int\n    artifacts: List[Artifact]\n\n\ndef get_message(commit: str) -> str:\n    return f\"Docs preview for commit {commit} at\"\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    owner: NamedUser = repo.owner\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    prs = list(repo.get_pulls(state=\"open\"))\n    for pr in prs:\n        logging.info(\"-----\")\n        logging.info(f\"Processing PR #{pr.number}: {pr.title}\")\n        pr_comments = list(pr.get_issue_comments())\n        pr_commits = list(pr.get_commits())\n        last_commit = pr_commits[0]\n        for pr_commit in pr_commits:\n            if pr_commit.commit.author.date > last_commit.commit.author.date:\n                last_commit = pr_commit\n        commit = last_commit.commit.sha\n        logging.info(f\"Last commit: {commit}\")\n        message = get_message(commit)\n        notified = False\n        for pr_comment in pr_comments:\n            if message in pr_comment.body:\n                notified = True\n        logging.info(f\"Docs preview was notified: {notified}\")\n        if not notified:\n            response = httpx.get(\n                f\"{github_api}/repos/{settings.github_repository}/actions/artifacts\",\n                headers=headers,\n            )\n            data = response.json()\n            artifacts_response = ArtifactResponse.parse_obj(data)\n            use_artifact: Optional[Artifact] = None\n            for artifact in artifacts_response.artifacts:\n                if artifact.name == settings.input_name:\n                    use_artifact = artifact\n                    break\n            if use_artifact:\n                logging.info(f\"Existing artifact: {use_artifact.name}\")\n                response = httpx.post(\n                    \"https://api.github.com/repos/tiangolo/fastapi/actions/workflows/preview-docs.yml/dispatches\",\n                    headers=headers,\n                    json={\n                        \"ref\": \"master\",\n                        \"inputs\": {\"pr\": f\"{pr.number}\", \"name\": f\"docs-zip-{commit}\"},\n                    },\n                )\n                logging.info(\n                    f\"Trigger sent, response status: {response.status_code} - content: {response.content}\"\n                )\n    logging.info(\"Finished\")\n", "fix_code": "import logging\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport httpx\nfrom github import Github\nfrom github.NamedUser import NamedUser\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_api = \"https://api.github.com\"\nnetlify_api = \"https://api.netlify.com\"\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    github_repository: str\n    github_event_path: Path\n    github_event_name: Optional[str] = None\n\n\nclass Artifact(BaseModel):\n    id: int\n    node_id: str\n    name: str\n    size_in_bytes: int\n    url: str\n    archive_download_url: str\n    expired: bool\n    created_at: datetime\n    updated_at: datetime\n\n\nclass ArtifactResponse(BaseModel):\n    total_count: int\n    artifacts: List[Artifact]\n\n\ndef get_message(commit: str) -> str:\n    return f\"Docs preview for commit {commit} at\"\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    owner: NamedUser = repo.owner\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    prs = list(repo.get_pulls(state=\"open\"))\n    for pr in prs:\n        logging.info(\"-----\")\n        logging.info(f\"Processing PR #{pr.number}: {pr.title}\")\n        pr_comments = list(pr.get_issue_comments())\n        pr_commits = list(pr.get_commits())\n        last_commit = pr_commits[0]\n        for pr_commit in pr_commits:\n            if pr_commit.commit.author.date > last_commit.commit.author.date:\n                last_commit = pr_commit\n        commit = last_commit.commit.sha\n        logging.info(f\"Last commit: {commit}\")\n        message = get_message(commit)\n        notified = False\n        for pr_comment in pr_comments:\n            if message in pr_comment.body:\n                notified = True\n        logging.info(f\"Docs preview was notified: {notified}\")\n        if not notified:\n            artifact_name = f\"docs-zip-{commit}\"\n            response = httpx.get(\n                f\"{github_api}/repos/{settings.github_repository}/actions/artifacts\",\n                headers=headers,\n            )\n            data = response.json()\n            artifacts_response = ArtifactResponse.parse_obj(data)\n            use_artifact: Optional[Artifact] = None\n            for artifact in artifacts_response.artifacts:\n                if artifact.name == artifact_name:\n                    use_artifact = artifact\n                    break\n            if use_artifact:\n                logging.info(f\"Existing artifact: {use_artifact.name}\")\n                response = httpx.post(\n                    \"https://api.github.com/repos/tiangolo/fastapi/actions/workflows/preview-docs.yml/dispatches\",\n                    headers=headers,\n                    json={\n                        \"ref\": \"master\",\n                        \"inputs\": {\"pr\": f\"{pr.number}\", \"name\": artifact_name},\n                    },\n                )\n                logging.info(\n                    f\"Trigger sent, response status: {response.status_code} - content: {response.content}\"\n                )\n    logging.info(\"Finished\")\n", "diff": "@@ -67,6 +67,7 @@ if __name__ == \"__main__\":\n                 notified = True\n         logging.info(f\"Docs preview was notified: {notified}\")\n         if not notified:\n+            artifact_name = f\"docs-zip-{commit}\"\n             response = httpx.get(\n                 f\"{github_api}/repos/{settings.github_repository}/actions/artifacts\",\n                 headers=headers,\n@@ -75,7 +76,7 @@ if __name__ == \"__main__\":\n             artifacts_response = ArtifactResponse.parse_obj(data)\n             use_artifact: Optional[Artifact] = None\n             for artifact in artifacts_response.artifacts:\n-                if artifact.name == settings.input_name:\n+                if artifact.name == artifact_name:\n                     use_artifact = artifact\n                     break\n             if use_artifact:\n@@ -85,7 +86,7 @@ if __name__ == \"__main__\":\n                     headers=headers,\n                     json={\n                         \"ref\": \"master\",\n-                        \"inputs\": {\"pr\": f\"{pr.number}\", \"name\": f\"docs-zip-{commit}\"},\n+                        \"inputs\": {\"pr\": f\"{pr.number}\", \"name\": artifact_name},\n                     },\n                 )\n                 logging.info(\n"}
{"commit_hash": "7b3ef431274f1223abc8a4343319fb9315f82199", "issue_description": "\ud83d\udc1b Fix Watch Preview Docs GitHub Action, strike 2", "code_before": "import logging\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport httpx\nfrom github import Github\nfrom github.NamedUser import NamedUser\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_api = \"https://api.github.com\"\nnetlify_api = \"https://api.netlify.com\"\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    github_repository: str\n    github_event_path: Path\n    github_event_name: Optional[str] = None\n\n\nclass Artifact(BaseModel):\n    id: int\n    node_id: str\n    name: str\n    size_in_bytes: int\n    url: str\n    archive_download_url: str\n    expired: bool\n    created_at: datetime\n    updated_at: datetime\n\n\nclass ArtifactResponse(BaseModel):\n    total_count: int\n    artifacts: List[Artifact]\n\n\ndef get_message(commit: str) -> str:\n    return f\"Docs preview for commit {commit} at\"\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    owner: NamedUser = repo.owner\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    prs = list(repo.get_pulls(state=\"open\"))\n    for pr in prs:\n        logging.info(\"-----\")\n        logging.info(f\"Processing PR #{pr.number}: {pr.title}\")\n        pr_comments = list(pr.get_issue_comments())\n        pr_commits = list(pr.get_commits())\n        last_commit = pr_commits[0]\n        for pr_commit in pr_commits:\n            if pr_commit.commit.author.date > last_commit.commit.author.date:\n                last_commit = pr_commit\n        commit = last_commit.commit.sha\n        logging.info(f\"Last commit: {commit}\")\n        message = get_message(commit)\n        notified = False\n        for pr_comment in pr_comments:\n            if message in pr_comment.body:\n                notified = True\n        logging.info(f\"Docs preview was notified: {notified}\")\n        if not notified:\n            artifact_name = f\"docs-zip-{commit}\"\n            response = httpx.get(\n                f\"{github_api}/repos/{settings.github_repository}/actions/artifacts\",\n                headers=headers,\n            )\n            data = response.json()\n            artifacts_response = ArtifactResponse.parse_obj(data)\n            use_artifact: Optional[Artifact] = None\n            for artifact in artifacts_response.artifacts:\n                if artifact.name == artifact_name:\n                    use_artifact = artifact\n                    break\n            if use_artifact:\n                logging.info(f\"Existing artifact: {use_artifact.name}\")\n                response = httpx.post(\n                    \"https://api.github.com/repos/tiangolo/fastapi/actions/workflows/preview-docs.yml/dispatches\",\n                    headers=headers,\n                    json={\n                        \"ref\": \"master\",\n                        \"inputs\": {\"pr\": f\"{pr.number}\", \"name\": artifact_name},\n                    },\n                )\n                logging.info(\n                    f\"Trigger sent, response status: {response.status_code} - content: {response.content}\"\n                )\n    logging.info(\"Finished\")\n", "fix_code": "import logging\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport httpx\nfrom github import Github\nfrom github.NamedUser import NamedUser\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_api = \"https://api.github.com\"\nnetlify_api = \"https://api.netlify.com\"\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    github_repository: str\n    github_event_path: Path\n    github_event_name: Optional[str] = None\n\n\nclass Artifact(BaseModel):\n    id: int\n    node_id: str\n    name: str\n    size_in_bytes: int\n    url: str\n    archive_download_url: str\n    expired: bool\n    created_at: datetime\n    updated_at: datetime\n\n\nclass ArtifactResponse(BaseModel):\n    total_count: int\n    artifacts: List[Artifact]\n\n\ndef get_message(commit: str) -> str:\n    return f\"Docs preview for commit {commit} at\"\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    owner: NamedUser = repo.owner\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    prs = list(repo.get_pulls(state=\"open\"))\n    for pr in prs:\n        logging.info(\"-----\")\n        logging.info(f\"Processing PR #{pr.number}: {pr.title}\")\n        pr_comments = list(pr.get_issue_comments())\n        pr_commits = list(pr.get_commits())\n        last_commit = pr_commits[0]\n        for pr_commit in pr_commits:\n            if pr_commit.commit.author.date > last_commit.commit.author.date:\n                last_commit = pr_commit\n        commit = last_commit.commit.sha\n        logging.info(f\"Last commit: {commit}\")\n        message = get_message(commit)\n        notified = False\n        for pr_comment in pr_comments:\n            if message in pr_comment.body:\n                notified = True\n        logging.info(f\"Docs preview was notified: {notified}\")\n        if not notified:\n            artifact_name = f\"docs-zip-{commit}\"\n            response = httpx.get(\n                f\"{github_api}/repos/{settings.github_repository}/actions/artifacts\",\n                headers=headers,\n            )\n            data = response.json()\n            artifacts_response = ArtifactResponse.parse_obj(data)\n            use_artifact: Optional[Artifact] = None\n            for artifact in artifacts_response.artifacts:\n                if artifact.name == artifact_name:\n                    use_artifact = artifact\n                    break\n            if use_artifact:\n                logging.info(f\"Existing artifact: {use_artifact.name}\")\n                response = httpx.post(\n                    \"https://api.github.com/repos/tiangolo/fastapi/actions/workflows/preview-docs.yml/dispatches\",\n                    headers=headers,\n                    json={\n                        \"ref\": \"master\",\n                        \"inputs\": {\"pr\": f\"{pr.number}\", \"name\": artifact_name, \"commit\": commit},\n                    },\n                )\n                logging.info(\n                    f\"Trigger sent, response status: {response.status_code} - content: {response.content}\"\n                )\n    logging.info(\"Finished\")\n", "diff": "@@ -86,7 +86,7 @@ if __name__ == \"__main__\":\n                     headers=headers,\n                     json={\n                         \"ref\": \"master\",\n-                        \"inputs\": {\"pr\": f\"{pr.number}\", \"name\": artifact_name},\n+                        \"inputs\": {\"pr\": f\"{pr.number}\", \"name\": artifact_name, \"commit\": commit},\n                     },\n                 )\n                 logging.info(\n"}
{"commit_hash": "f1c5330b6526b706b1dc2d9b3301a3ec401ddca4", "issue_description": "\ud83d\udc1b Fix app.extra type annotation (#1659)\n\nCo-authored-by: bar.harel <bar.harel@biocatch.com>", "code_before": "from typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union\n\nfrom fastapi import routing\nfrom fastapi.concurrency import AsyncExitStack\nfrom fastapi.encoders import DictIntStrAny, SetIntStr\nfrom fastapi.exception_handlers import (\n    http_exception_handler,\n    request_validation_exception_handler,\n)\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.logger import logger\nfrom fastapi.openapi.docs import (\n    get_redoc_html,\n    get_swagger_ui_html,\n    get_swagger_ui_oauth2_redirect_html,\n)\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.params import Depends\nfrom fastapi.utils import warning_response_model_skip_defaults_deprecated\nfrom starlette.applications import Starlette\nfrom starlette.datastructures import State\nfrom starlette.exceptions import HTTPException\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, JSONResponse, Response\nfrom starlette.routing import BaseRoute\nfrom starlette.types import Receive, Scope, Send\n\n\nclass FastAPI(Starlette):\n    def __init__(\n        self,\n        *,\n        debug: bool = False,\n        routes: List[BaseRoute] = None,\n        title: str = \"FastAPI\",\n        description: str = \"\",\n        version: str = \"0.1.0\",\n        openapi_url: Optional[str] = \"/openapi.json\",\n        openapi_tags: Optional[List[Dict[str, Any]]] = None,\n        servers: Optional[List[Dict[str, Union[str, Any]]]] = None,\n        default_response_class: Type[Response] = JSONResponse,\n        docs_url: Optional[str] = \"/docs\",\n        redoc_url: Optional[str] = \"/redoc\",\n        swagger_ui_oauth2_redirect_url: Optional[str] = \"/docs/oauth2-redirect\",\n        swagger_ui_init_oauth: Optional[dict] = None,\n        middleware: Sequence[Middleware] = None,\n        exception_handlers: Dict[Union[int, Type[Exception]], Callable] = None,\n        on_startup: Sequence[Callable] = None,\n        on_shutdown: Sequence[Callable] = None,\n        openapi_prefix: str = \"\",\n        root_path: str = \"\",\n        root_path_in_servers: bool = True,\n        **extra: Dict[str, Any],\n    ) -> None:\n        self.default_response_class = default_response_class\n        self._debug = debug\n        self.state = State()\n        self.router: routing.APIRouter = routing.APIRouter(\n            routes,\n            dependency_overrides_provider=self,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n        )\n        self.exception_handlers = (\n            {} if exception_handlers is None else dict(exception_handlers)\n        )\n\n        self.user_middleware = [] if middleware is None else list(middleware)\n        self.middleware_stack = self.build_middleware_stack()\n\n        self.title = title\n        self.description = description\n        self.version = version\n        self.servers = servers or []\n        self.openapi_url = openapi_url\n        self.openapi_tags = openapi_tags\n        # TODO: remove when discarding the openapi_prefix parameter\n        if openapi_prefix:\n            logger.warning(\n                '\"openapi_prefix\" has been deprecated in favor of \"root_path\", which '\n                \"follows more closely the ASGI standard, is simpler, and more \"\n                \"automatic. Check the docs at \"\n                \"https://fastapi.tiangolo.com/advanced/sub-applications/\"\n            )\n        self.root_path = root_path or openapi_prefix\n        self.root_path_in_servers = root_path_in_servers\n        self.docs_url = docs_url\n        self.redoc_url = redoc_url\n        self.swagger_ui_oauth2_redirect_url = swagger_ui_oauth2_redirect_url\n        self.swagger_ui_init_oauth = swagger_ui_init_oauth\n        self.extra = extra\n        self.dependency_overrides: Dict[Callable, Callable] = {}\n\n        self.openapi_version = \"3.0.2\"\n\n        if self.openapi_url:\n            assert self.title, \"A title must be provided for OpenAPI, e.g.: 'My API'\"\n            assert self.version, \"A version must be provided for OpenAPI, e.g.: '2.1.0'\"\n        self.openapi_schema: Optional[Dict[str, Any]] = None\n        self.setup()\n\n    def openapi(self) -> Dict:\n        if not self.openapi_schema:\n            self.openapi_schema = get_openapi(\n                title=self.title,\n                version=self.version,\n                openapi_version=self.openapi_version,\n                description=self.description,\n                routes=self.routes,\n                tags=self.openapi_tags,\n                servers=self.servers,\n            )\n        return self.openapi_schema\n\n    def setup(self) -> None:\n        if self.openapi_url:\n            server_urls = set()\n            for server_data in self.servers:\n                url = server_data.get(\"url\")\n                if url:\n                    server_urls.add(url)\n\n            async def openapi(req: Request) -> JSONResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                if root_path not in server_urls:\n                    if root_path and self.root_path_in_servers:\n                        self.servers.insert(0, {\"url\": root_path})\n                        server_urls.add(root_path)\n                return JSONResponse(self.openapi())\n\n            self.add_route(self.openapi_url, openapi, include_in_schema=False)\n        if self.openapi_url and self.docs_url:\n\n            async def swagger_ui_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n                if oauth2_redirect_url:\n                    oauth2_redirect_url = root_path + oauth2_redirect_url\n                return get_swagger_ui_html(\n                    openapi_url=openapi_url,\n                    title=self.title + \" - Swagger UI\",\n                    oauth2_redirect_url=oauth2_redirect_url,\n                    init_oauth=self.swagger_ui_init_oauth,\n                )\n\n            self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n\n            if self.swagger_ui_oauth2_redirect_url:\n\n                async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                    return get_swagger_ui_oauth2_redirect_html()\n\n                self.add_route(\n                    self.swagger_ui_oauth2_redirect_url,\n                    swagger_ui_redirect,\n                    include_in_schema=False,\n                )\n        if self.openapi_url and self.redoc_url:\n\n            async def redoc_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                return get_redoc_html(\n                    openapi_url=openapi_url, title=self.title + \" - ReDoc\"\n                )\n\n            self.add_route(self.redoc_url, redoc_html, include_in_schema=False)\n        self.add_exception_handler(HTTPException, http_exception_handler)\n        self.add_exception_handler(\n            RequestValidationError, request_validation_exception_handler\n        )\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.root_path:\n            scope[\"root_path\"] = self.root_path\n        if AsyncExitStack:\n            async with AsyncExitStack() as stack:\n                scope[\"fastapi_astack\"] = stack\n                await super().__call__(scope, receive, send)\n        else:\n            await super().__call__(scope, receive, send)  # pragma: no cover\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n    ) -> None:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        self.router.add_api_route(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n        )\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n\n        def decorator(func: Callable) -> Callable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=bool(\n                    response_model_exclude_unset or response_model_skip_defaults\n                ),\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class or self.default_response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        self.router.add_api_websocket_route(path, endpoint, name=name)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: routing.APIRouter,\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        default_response_class: Optional[Type[Response]] = None,\n    ) -> None:\n        self.router.include_router(\n            router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            responses=responses or {},\n            default_response_class=default_response_class\n            or self.default_response_class,\n        )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.get(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.put(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.post(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.delete(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            operation_id=operation_id,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.options(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.head(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.patch(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.trace(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n", "fix_code": "from typing import Any, Callable, Dict, List, Optional, Sequence, Type, Union\n\nfrom fastapi import routing\nfrom fastapi.concurrency import AsyncExitStack\nfrom fastapi.encoders import DictIntStrAny, SetIntStr\nfrom fastapi.exception_handlers import (\n    http_exception_handler,\n    request_validation_exception_handler,\n)\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.logger import logger\nfrom fastapi.openapi.docs import (\n    get_redoc_html,\n    get_swagger_ui_html,\n    get_swagger_ui_oauth2_redirect_html,\n)\nfrom fastapi.openapi.utils import get_openapi\nfrom fastapi.params import Depends\nfrom fastapi.utils import warning_response_model_skip_defaults_deprecated\nfrom starlette.applications import Starlette\nfrom starlette.datastructures import State\nfrom starlette.exceptions import HTTPException\nfrom starlette.middleware import Middleware\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse, JSONResponse, Response\nfrom starlette.routing import BaseRoute\nfrom starlette.types import Receive, Scope, Send\n\n\nclass FastAPI(Starlette):\n    def __init__(\n        self,\n        *,\n        debug: bool = False,\n        routes: List[BaseRoute] = None,\n        title: str = \"FastAPI\",\n        description: str = \"\",\n        version: str = \"0.1.0\",\n        openapi_url: Optional[str] = \"/openapi.json\",\n        openapi_tags: Optional[List[Dict[str, Any]]] = None,\n        servers: Optional[List[Dict[str, Union[str, Any]]]] = None,\n        default_response_class: Type[Response] = JSONResponse,\n        docs_url: Optional[str] = \"/docs\",\n        redoc_url: Optional[str] = \"/redoc\",\n        swagger_ui_oauth2_redirect_url: Optional[str] = \"/docs/oauth2-redirect\",\n        swagger_ui_init_oauth: Optional[dict] = None,\n        middleware: Sequence[Middleware] = None,\n        exception_handlers: Dict[Union[int, Type[Exception]], Callable] = None,\n        on_startup: Sequence[Callable] = None,\n        on_shutdown: Sequence[Callable] = None,\n        openapi_prefix: str = \"\",\n        root_path: str = \"\",\n        root_path_in_servers: bool = True,\n        **extra: Any,\n    ) -> None:\n        self.default_response_class = default_response_class\n        self._debug = debug\n        self.state = State()\n        self.router: routing.APIRouter = routing.APIRouter(\n            routes,\n            dependency_overrides_provider=self,\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n        )\n        self.exception_handlers = (\n            {} if exception_handlers is None else dict(exception_handlers)\n        )\n\n        self.user_middleware = [] if middleware is None else list(middleware)\n        self.middleware_stack = self.build_middleware_stack()\n\n        self.title = title\n        self.description = description\n        self.version = version\n        self.servers = servers or []\n        self.openapi_url = openapi_url\n        self.openapi_tags = openapi_tags\n        # TODO: remove when discarding the openapi_prefix parameter\n        if openapi_prefix:\n            logger.warning(\n                '\"openapi_prefix\" has been deprecated in favor of \"root_path\", which '\n                \"follows more closely the ASGI standard, is simpler, and more \"\n                \"automatic. Check the docs at \"\n                \"https://fastapi.tiangolo.com/advanced/sub-applications/\"\n            )\n        self.root_path = root_path or openapi_prefix\n        self.root_path_in_servers = root_path_in_servers\n        self.docs_url = docs_url\n        self.redoc_url = redoc_url\n        self.swagger_ui_oauth2_redirect_url = swagger_ui_oauth2_redirect_url\n        self.swagger_ui_init_oauth = swagger_ui_init_oauth\n        self.extra = extra\n        self.dependency_overrides: Dict[Callable, Callable] = {}\n\n        self.openapi_version = \"3.0.2\"\n\n        if self.openapi_url:\n            assert self.title, \"A title must be provided for OpenAPI, e.g.: 'My API'\"\n            assert self.version, \"A version must be provided for OpenAPI, e.g.: '2.1.0'\"\n        self.openapi_schema: Optional[Dict[str, Any]] = None\n        self.setup()\n\n    def openapi(self) -> Dict:\n        if not self.openapi_schema:\n            self.openapi_schema = get_openapi(\n                title=self.title,\n                version=self.version,\n                openapi_version=self.openapi_version,\n                description=self.description,\n                routes=self.routes,\n                tags=self.openapi_tags,\n                servers=self.servers,\n            )\n        return self.openapi_schema\n\n    def setup(self) -> None:\n        if self.openapi_url:\n            server_urls = set()\n            for server_data in self.servers:\n                url = server_data.get(\"url\")\n                if url:\n                    server_urls.add(url)\n\n            async def openapi(req: Request) -> JSONResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                if root_path not in server_urls:\n                    if root_path and self.root_path_in_servers:\n                        self.servers.insert(0, {\"url\": root_path})\n                        server_urls.add(root_path)\n                return JSONResponse(self.openapi())\n\n            self.add_route(self.openapi_url, openapi, include_in_schema=False)\n        if self.openapi_url and self.docs_url:\n\n            async def swagger_ui_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                oauth2_redirect_url = self.swagger_ui_oauth2_redirect_url\n                if oauth2_redirect_url:\n                    oauth2_redirect_url = root_path + oauth2_redirect_url\n                return get_swagger_ui_html(\n                    openapi_url=openapi_url,\n                    title=self.title + \" - Swagger UI\",\n                    oauth2_redirect_url=oauth2_redirect_url,\n                    init_oauth=self.swagger_ui_init_oauth,\n                )\n\n            self.add_route(self.docs_url, swagger_ui_html, include_in_schema=False)\n\n            if self.swagger_ui_oauth2_redirect_url:\n\n                async def swagger_ui_redirect(req: Request) -> HTMLResponse:\n                    return get_swagger_ui_oauth2_redirect_html()\n\n                self.add_route(\n                    self.swagger_ui_oauth2_redirect_url,\n                    swagger_ui_redirect,\n                    include_in_schema=False,\n                )\n        if self.openapi_url and self.redoc_url:\n\n            async def redoc_html(req: Request) -> HTMLResponse:\n                root_path = req.scope.get(\"root_path\", \"\").rstrip(\"/\")\n                openapi_url = root_path + self.openapi_url\n                return get_redoc_html(\n                    openapi_url=openapi_url, title=self.title + \" - ReDoc\"\n                )\n\n            self.add_route(self.redoc_url, redoc_html, include_in_schema=False)\n        self.add_exception_handler(HTTPException, http_exception_handler)\n        self.add_exception_handler(\n            RequestValidationError, request_validation_exception_handler\n        )\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        if self.root_path:\n            scope[\"root_path\"] = self.root_path\n        if AsyncExitStack:\n            async with AsyncExitStack() as stack:\n                scope[\"fastapi_astack\"] = stack\n                await super().__call__(scope, receive, send)\n        else:\n            await super().__call__(scope, receive, send)  # pragma: no cover\n\n    def add_api_route(\n        self,\n        path: str,\n        endpoint: Callable,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n    ) -> None:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        self.router.add_api_route(\n            path,\n            endpoint=endpoint,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            methods=methods,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n        )\n\n    def api_route(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        methods: List[str] = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n\n        def decorator(func: Callable) -> Callable:\n            self.router.add_api_route(\n                path,\n                func,\n                response_model=response_model,\n                status_code=status_code,\n                tags=tags or [],\n                dependencies=dependencies,\n                summary=summary,\n                description=description,\n                response_description=response_description,\n                responses=responses or {},\n                deprecated=deprecated,\n                methods=methods,\n                operation_id=operation_id,\n                response_model_include=response_model_include,\n                response_model_exclude=response_model_exclude,\n                response_model_by_alias=response_model_by_alias,\n                response_model_exclude_unset=bool(\n                    response_model_exclude_unset or response_model_skip_defaults\n                ),\n                response_model_exclude_defaults=response_model_exclude_defaults,\n                response_model_exclude_none=response_model_exclude_none,\n                include_in_schema=include_in_schema,\n                response_class=response_class or self.default_response_class,\n                name=name,\n            )\n            return func\n\n        return decorator\n\n    def add_api_websocket_route(\n        self, path: str, endpoint: Callable, name: str = None\n    ) -> None:\n        self.router.add_api_websocket_route(path, endpoint, name=name)\n\n    def websocket(self, path: str, name: str = None) -> Callable:\n        def decorator(func: Callable) -> Callable:\n            self.add_api_websocket_route(path, func, name=name)\n            return func\n\n        return decorator\n\n    def include_router(\n        self,\n        router: routing.APIRouter,\n        *,\n        prefix: str = \"\",\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        default_response_class: Optional[Type[Response]] = None,\n    ) -> None:\n        self.router.include_router(\n            router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            responses=responses or {},\n            default_response_class=default_response_class\n            or self.default_response_class,\n        )\n\n    def get(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.get(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def put(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.put(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def post(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.post(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def delete(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.delete(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            operation_id=operation_id,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def options(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.options(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def head(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.head(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def patch(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.patch(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n\n    def trace(\n        self,\n        path: str,\n        *,\n        response_model: Type[Any] = None,\n        status_code: int = 200,\n        tags: List[str] = None,\n        dependencies: Sequence[Depends] = None,\n        summary: str = None,\n        description: str = None,\n        response_description: str = \"Successful Response\",\n        responses: Dict[Union[int, str], Dict[str, Any]] = None,\n        deprecated: bool = None,\n        operation_id: str = None,\n        response_model_include: Union[SetIntStr, DictIntStrAny] = None,\n        response_model_exclude: Union[SetIntStr, DictIntStrAny] = set(),\n        response_model_by_alias: bool = True,\n        response_model_skip_defaults: bool = None,\n        response_model_exclude_unset: bool = False,\n        response_model_exclude_defaults: bool = False,\n        response_model_exclude_none: bool = False,\n        include_in_schema: bool = True,\n        response_class: Type[Response] = None,\n        name: str = None,\n        callbacks: List[routing.APIRoute] = None,\n    ) -> Callable:\n        if response_model_skip_defaults is not None:\n            warning_response_model_skip_defaults_deprecated()  # pragma: nocover\n        return self.router.trace(\n            path,\n            response_model=response_model,\n            status_code=status_code,\n            tags=tags or [],\n            dependencies=dependencies,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n            responses=responses or {},\n            deprecated=deprecated,\n            operation_id=operation_id,\n            response_model_include=response_model_include,\n            response_model_exclude=response_model_exclude,\n            response_model_by_alias=response_model_by_alias,\n            response_model_exclude_unset=bool(\n                response_model_exclude_unset or response_model_skip_defaults\n            ),\n            response_model_exclude_defaults=response_model_exclude_defaults,\n            response_model_exclude_none=response_model_exclude_none,\n            include_in_schema=include_in_schema,\n            response_class=response_class or self.default_response_class,\n            name=name,\n            callbacks=callbacks,\n        )\n", "diff": "@@ -51,7 +51,7 @@ class FastAPI(Starlette):\n         openapi_prefix: str = \"\",\n         root_path: str = \"\",\n         root_path_in_servers: bool = True,\n-        **extra: Dict[str, Any],\n+        **extra: Any,\n     ) -> None:\n         self.default_response_class = default_response_class\n         self._debug = debug\n"}
{"commit_hash": "0752c7242dfc86344a9d1acab48b9a2c2209817c", "issue_description": "\ud83d\udd0a Fix empty log message in docs example about raised exceptions (#1815)", "code_before": "from fastapi import FastAPI, HTTPException\nfrom fastapi.exception_handlers import (\n    http_exception_handler,\n    request_validation_exception_handler,\n)\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\napp = FastAPI()\n\n\n@app.exception_handler(StarletteHTTPException)\nasync def custom_http_exception_handler(request, exc):\n    print(f\"OMG! An HTTP error!: {exc}\")\n    return await http_exception_handler(request, exc)\n\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request, exc):\n    print(f\"OMG! The client sent invalid data!: {exc}\")\n    return await request_validation_exception_handler(request, exc)\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id == 3:\n        raise HTTPException(status_code=418, detail=\"Nope! I don't like 3.\")\n    return {\"item_id\": item_id}\n", "fix_code": "from fastapi import FastAPI, HTTPException\nfrom fastapi.exception_handlers import (\n    http_exception_handler,\n    request_validation_exception_handler,\n)\nfrom fastapi.exceptions import RequestValidationError\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\napp = FastAPI()\n\n\n@app.exception_handler(StarletteHTTPException)\nasync def custom_http_exception_handler(request, exc):\n    print(f\"OMG! An HTTP error!: {repr(exc)}\")\n    return await http_exception_handler(request, exc)\n\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request, exc):\n    print(f\"OMG! The client sent invalid data!: {exc}\")\n    return await request_validation_exception_handler(request, exc)\n\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id == 3:\n        raise HTTPException(status_code=418, detail=\"Nope! I don't like 3.\")\n    return {\"item_id\": item_id}\n", "diff": "@@ -11,7 +11,7 @@ app = FastAPI()\n \n @app.exception_handler(StarletteHTTPException)\n async def custom_http_exception_handler(request, exc):\n-    print(f\"OMG! An HTTP error!: {exc}\")\n+    print(f\"OMG! An HTTP error!: {repr(exc)}\")\n     return await http_exception_handler(request, exc)\n \n \n"}
{"commit_hash": "0dfde6e284b221bf6695a98762a56d13a995e807", "issue_description": "\ud83d\udc1b Fix issues introduced by removing sqlalchemy safeguard in jsonable_encoder (#1987)", "code_before": "from collections import defaultdict\nfrom enum import Enum\nfrom pathlib import PurePath\nfrom types import GeneratorType\nfrom typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union\n\nfrom pydantic import BaseModel\nfrom pydantic.json import ENCODERS_BY_TYPE\n\nSetIntStr = Set[Union[int, str]]\nDictIntStrAny = Dict[Union[int, str], Any]\n\n\ndef generate_encoders_by_class_tuples(\n    type_encoder_map: Dict[Any, Callable]\n) -> Dict[Callable, Tuple]:\n    encoders_by_class_tuples: Dict[Callable, Tuple] = defaultdict(tuple)\n    for type_, encoder in type_encoder_map.items():\n        encoders_by_class_tuples[encoder] += (type_,)\n    return encoders_by_class_tuples\n\n\nencoders_by_class_tuples = generate_encoders_by_class_tuples(ENCODERS_BY_TYPE)\n\n\ndef jsonable_encoder(\n    obj: Any,\n    include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    custom_encoder: dict = {},\n) -> Any:\n    if include is not None and not isinstance(include, set):\n        include = set(include)\n    if exclude is not None and not isinstance(exclude, set):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoder = getattr(obj.__config__, \"json_encoders\", {})\n        if custom_encoder:\n            encoder.update(custom_encoder)\n        obj_dict = obj.dict(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n        )\n        if \"__root__\" in obj_dict:\n            obj_dict = obj_dict[\"__root__\"]\n        return jsonable_encoder(\n            obj_dict,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n            custom_encoder=encoder,\n        )\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        for key, value in obj.items():\n            if (value is not None or not exclude_none) and (\n                (include and key in include) or not exclude or key not in exclude\n            ):\n                encoded_key = jsonable_encoder(\n                    key,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                )\n                encoded_value = jsonable_encoder(\n                    value,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                )\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(\n                jsonable_encoder(\n                    item,\n                    include=include,\n                    exclude=exclude,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                )\n            )\n        return encoded_list\n\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder(obj)\n\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n\n    errors: List[Exception] = []\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors)\n    return jsonable_encoder(\n        data,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        custom_encoder=custom_encoder,\n    )\n", "fix_code": "from collections import defaultdict\nfrom enum import Enum\nfrom pathlib import PurePath\nfrom types import GeneratorType\nfrom typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union\n\nfrom pydantic import BaseModel\nfrom pydantic.json import ENCODERS_BY_TYPE\n\nSetIntStr = Set[Union[int, str]]\nDictIntStrAny = Dict[Union[int, str], Any]\n\n\ndef generate_encoders_by_class_tuples(\n    type_encoder_map: Dict[Any, Callable]\n) -> Dict[Callable, Tuple]:\n    encoders_by_class_tuples: Dict[Callable, Tuple] = defaultdict(tuple)\n    for type_, encoder in type_encoder_map.items():\n        encoders_by_class_tuples[encoder] += (type_,)\n    return encoders_by_class_tuples\n\n\nencoders_by_class_tuples = generate_encoders_by_class_tuples(ENCODERS_BY_TYPE)\n\n\ndef jsonable_encoder(\n    obj: Any,\n    include: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    exclude: Optional[Union[SetIntStr, DictIntStrAny]] = None,\n    by_alias: bool = True,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    custom_encoder: dict = {},\n    sqlalchemy_safe: bool = True,\n) -> Any:\n    if include is not None and not isinstance(include, set):\n        include = set(include)\n    if exclude is not None and not isinstance(exclude, set):\n        exclude = set(exclude)\n    if isinstance(obj, BaseModel):\n        encoder = getattr(obj.__config__, \"json_encoders\", {})\n        if custom_encoder:\n            encoder.update(custom_encoder)\n        obj_dict = obj.dict(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n        )\n        if \"__root__\" in obj_dict:\n            obj_dict = obj_dict[\"__root__\"]\n        return jsonable_encoder(\n            obj_dict,\n            exclude_none=exclude_none,\n            exclude_defaults=exclude_defaults,\n            custom_encoder=encoder,\n            sqlalchemy_safe=sqlalchemy_safe,\n        )\n    if isinstance(obj, Enum):\n        return obj.value\n    if isinstance(obj, PurePath):\n        return str(obj)\n    if isinstance(obj, (str, int, float, type(None))):\n        return obj\n    if isinstance(obj, dict):\n        encoded_dict = {}\n        for key, value in obj.items():\n            if (\n                (\n                    not sqlalchemy_safe\n                    or (not isinstance(key, str))\n                    or (not key.startswith(\"_sa\"))\n                )\n                and (value is not None or not exclude_none)\n                and ((include and key in include) or not exclude or key not in exclude)\n            ):\n                encoded_key = jsonable_encoder(\n                    key,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n                encoded_value = jsonable_encoder(\n                    value,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n                encoded_dict[encoded_key] = encoded_value\n        return encoded_dict\n    if isinstance(obj, (list, set, frozenset, GeneratorType, tuple)):\n        encoded_list = []\n        for item in obj:\n            encoded_list.append(\n                jsonable_encoder(\n                    item,\n                    include=include,\n                    exclude=exclude,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    exclude_none=exclude_none,\n                    custom_encoder=custom_encoder,\n                    sqlalchemy_safe=sqlalchemy_safe,\n                )\n            )\n        return encoded_list\n\n    if custom_encoder:\n        if type(obj) in custom_encoder:\n            return custom_encoder[type(obj)](obj)\n        else:\n            for encoder_type, encoder in custom_encoder.items():\n                if isinstance(obj, encoder_type):\n                    return encoder(obj)\n\n    if type(obj) in ENCODERS_BY_TYPE:\n        return ENCODERS_BY_TYPE[type(obj)](obj)\n    for encoder, classes_tuple in encoders_by_class_tuples.items():\n        if isinstance(obj, classes_tuple):\n            return encoder(obj)\n\n    errors: List[Exception] = []\n    try:\n        data = dict(obj)\n    except Exception as e:\n        errors.append(e)\n        try:\n            data = vars(obj)\n        except Exception as e:\n            errors.append(e)\n            raise ValueError(errors)\n    return jsonable_encoder(\n        data,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        custom_encoder=custom_encoder,\n        sqlalchemy_safe=sqlalchemy_safe,\n    )\n", "diff": "@@ -32,6 +32,7 @@ def jsonable_encoder(\n     exclude_defaults: bool = False,\n     exclude_none: bool = False,\n     custom_encoder: dict = {},\n+    sqlalchemy_safe: bool = True,\n ) -> Any:\n     if include is not None and not isinstance(include, set):\n         include = set(include)\n@@ -56,6 +57,7 @@ def jsonable_encoder(\n             exclude_none=exclude_none,\n             exclude_defaults=exclude_defaults,\n             custom_encoder=encoder,\n+            sqlalchemy_safe=sqlalchemy_safe,\n         )\n     if isinstance(obj, Enum):\n         return obj.value\n@@ -66,8 +68,14 @@ def jsonable_encoder(\n     if isinstance(obj, dict):\n         encoded_dict = {}\n         for key, value in obj.items():\n-            if (value is not None or not exclude_none) and (\n-                (include and key in include) or not exclude or key not in exclude\n+            if (\n+                (\n+                    not sqlalchemy_safe\n+                    or (not isinstance(key, str))\n+                    or (not key.startswith(\"_sa\"))\n+                )\n+                and (value is not None or not exclude_none)\n+                and ((include and key in include) or not exclude or key not in exclude)\n             ):\n                 encoded_key = jsonable_encoder(\n                     key,\n@@ -75,6 +83,7 @@ def jsonable_encoder(\n                     exclude_unset=exclude_unset,\n                     exclude_none=exclude_none,\n                     custom_encoder=custom_encoder,\n+                    sqlalchemy_safe=sqlalchemy_safe,\n                 )\n                 encoded_value = jsonable_encoder(\n                     value,\n@@ -82,6 +91,7 @@ def jsonable_encoder(\n                     exclude_unset=exclude_unset,\n                     exclude_none=exclude_none,\n                     custom_encoder=custom_encoder,\n+                    sqlalchemy_safe=sqlalchemy_safe,\n                 )\n                 encoded_dict[encoded_key] = encoded_value\n         return encoded_dict\n@@ -98,6 +108,7 @@ def jsonable_encoder(\n                     exclude_defaults=exclude_defaults,\n                     exclude_none=exclude_none,\n                     custom_encoder=custom_encoder,\n+                    sqlalchemy_safe=sqlalchemy_safe,\n                 )\n             )\n         return encoded_list\n@@ -133,4 +144,5 @@ def jsonable_encoder(\n         exclude_defaults=exclude_defaults,\n         exclude_none=exclude_none,\n         custom_encoder=custom_encoder,\n+        sqlalchemy_safe=sqlalchemy_safe,\n     )\n"}
{"commit_hash": "8486b4134991715ab56ad9a11d674d93fbf54967", "issue_description": "Fix tags's declare", "code_before": "from typing import Optional, Set\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n    tags: Set[str] = []\n    image: Optional[Image] = None\n\n\n@app.put(\"/items/{item_id}\")\nasync def update_item(item_id: int, item: Item):\n    results = {\"item_id\": item_id, \"item\": item}\n    return results\n", "fix_code": "from typing import Optional, Set\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n    tags: Set[str] = set()\n    image: Optional[Image] = None\n\n\n@app.put(\"/items/{item_id}\")\nasync def update_item(item_id: int, item: Item):\n    results = {\"item_id\": item_id, \"item\": item}\n    return results\n", "diff": "@@ -16,7 +16,7 @@ class Item(BaseModel):\n     description: Optional[str] = None\n     price: float\n     tax: Optional[float] = None\n-    tags: Set[str] = []\n+    tags: Set[str] = set()\n     image: Optional[Image] = None\n \n \n"}
{"commit_hash": "479e87e467eafa944b0dcb78d3ed4bd7cae6cfda", "issue_description": "\ud83d\udc1b Fix FastAPI People GitHub Action when there's nothing to change (#2196)", "code_before": "import logging\nimport subprocess\nfrom collections import Counter\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Container, Dict, List, Optional, Set\n\nimport httpx\nfrom github import Github\nimport yaml\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_graphql_url = \"https://api.github.com/graphql\"\n\nissues_query = \"\"\"\nquery Q($after: String) { \n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    issues(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nprs_query = \"\"\"\nquery Q($after: String) { \n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    pullRequests(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          labels(first: 100) {\n            nodes {\n              name\n            }\n          }\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n          reviews(first:100) {\n            nodes {\n              author {\n                login\n                avatarUrl\n                url\n              }\n              state\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nsponsors_query = \"\"\"\nquery Q($after: String) {\n  user(login: \"tiangolo\") {\n    sponsorshipsAsMaintainer(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          sponsorEntity {\n            ... on Organization {\n              login\n              avatarUrl\n              url\n            }\n            ... on User {\n              login\n              avatarUrl\n              url\n            }\n          }\n          tier {\n            name\n            monthlyPriceInDollars\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\n\nclass Author(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass CommentsNode(BaseModel):\n    createdAt: datetime\n    author: Optional[Author] = None\n\n\nclass Comments(BaseModel):\n    nodes: List[CommentsNode]\n\n\nclass IssuesNode(BaseModel):\n    number: int\n    author: Optional[Author] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n\n\nclass IssuesEdge(BaseModel):\n    cursor: str\n    node: IssuesNode\n\n\nclass Issues(BaseModel):\n    edges: List[IssuesEdge]\n\n\nclass IssuesRepository(BaseModel):\n    issues: Issues\n\n\nclass IssuesResponseData(BaseModel):\n    repository: IssuesRepository\n\n\nclass IssuesResponse(BaseModel):\n    data: IssuesResponseData\n\n\nclass LabelNode(BaseModel):\n    name: str\n\n\nclass Labels(BaseModel):\n    nodes: List[LabelNode]\n\n\nclass ReviewNode(BaseModel):\n    author: Optional[Author] = None\n    state: str\n\n\nclass Reviews(BaseModel):\n    nodes: List[ReviewNode]\n\n\nclass PullRequestNode(BaseModel):\n    number: int\n    labels: Labels\n    author: Optional[Author] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n    reviews: Reviews\n\n\nclass PullRequestEdge(BaseModel):\n    cursor: str\n    node: PullRequestNode\n\n\nclass PullRequests(BaseModel):\n    edges: List[PullRequestEdge]\n\n\nclass PRsRepository(BaseModel):\n    pullRequests: PullRequests\n\n\nclass PRsResponseData(BaseModel):\n    repository: PRsRepository\n\n\nclass PRsResponse(BaseModel):\n    data: PRsResponseData\n\n\nclass SponsorEntity(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass Tier(BaseModel):\n    name: str\n    monthlyPriceInDollars: float\n\n\nclass SponsorshipAsMaintainerNode(BaseModel):\n    sponsorEntity: SponsorEntity\n    tier: Tier\n\n\nclass SponsorshipAsMaintainerEdge(BaseModel):\n    cursor: str\n    node: SponsorshipAsMaintainerNode\n\n\nclass SponsorshipAsMaintainer(BaseModel):\n    edges: List[SponsorshipAsMaintainerEdge]\n\n\nclass SponsorsUser(BaseModel):\n    sponsorshipsAsMaintainer: SponsorshipAsMaintainer\n\n\nclass SponsorsResponseData(BaseModel):\n    user: SponsorsUser\n\n\nclass SponsorsResponse(BaseModel):\n    data: SponsorsResponseData\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    github_repository: str\n\n\ndef get_graphql_response(\n    *, settings: Settings, query: str, after: Optional[str] = None\n):\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = httpx.post(\n        github_graphql_url,\n        headers=headers,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if not response.status_code == 200:\n        logging.error(f\"Response was not 200, after: {after}\")\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    return data\n\n\ndef get_graphql_issue_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.parse_obj(data)\n    return graphql_response.data.repository.issues.edges\n\n\ndef get_graphql_pr_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.parse_obj(data)\n    return graphql_response.data.repository.pullRequests.edges\n\n\ndef get_graphql_sponsor_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n    graphql_response = SponsorsResponse.parse_obj(data)\n    return graphql_response.data.user.sponsorshipsAsMaintainer.edges\n\n\ndef get_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == issue_author_name:\n                    continue\n                issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors\n\n\ndef get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors\n\n\ndef get_sponsors(settings: Settings):\n    nodes: List[SponsorshipAsMaintainerNode] = []\n    edges = get_graphql_sponsor_edges(settings=settings)\n\n    while edges:\n        for edge in edges:\n            nodes.append(edge.node)\n        last_edge = edges[-1]\n        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n\n    entities: Dict[str, SponsorEntity] = {}\n    for node in nodes:\n        entities[node.sponsorEntity.login] = node.sponsorEntity\n    return entities\n\n\ndef get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    issue_commentors, issue_last_month_commentors, issue_authors = get_experts(\n        settings=settings\n    )\n    contributors, pr_commentors, reviewers, pr_authors = get_contributors(\n        settings=settings\n    )\n    authors = {**issue_authors, **pr_authors}\n    maintainers_logins = {\"tiangolo\"}\n    bot_names = {\"codecov\", \"github-actions\"}\n    maintainers = []\n    for login in maintainers_logins:\n        user = authors[login]\n        maintainers.append(\n            {\n                \"login\": login,\n                \"answers\": issue_commentors[login],\n                \"prs\": contributors[login],\n                \"avatarUrl\": user.avatarUrl,\n                \"url\": user.url,\n            }\n        )\n\n    min_count_expert = 10\n    min_count_last_month = 3\n    min_count_contributor = 4\n    min_count_reviewer = 4\n    skip_users = maintainers_logins | bot_names\n    experts = get_top_users(\n        counter=issue_commentors,\n        min_count=min_count_expert,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    last_month_active = get_top_users(\n        counter=issue_last_month_commentors,\n        min_count=min_count_last_month,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_contributors = get_top_users(\n        counter=contributors,\n        min_count=min_count_contributor,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_reviewers = get_top_users(\n        counter=reviewers,\n        min_count=min_count_reviewer,\n        authors=authors,\n        skip_users=skip_users,\n    )\n\n    sponsors_by_login = get_sponsors(settings=settings)\n    sponsors = []\n    for login, sponsor in sponsors_by_login.items():\n        sponsors.append(\n            {\"login\": login, \"avatarUrl\": sponsor.avatarUrl, \"url\": sponsor.url}\n        )\n\n    people = {\n        \"maintainers\": maintainers,\n        \"experts\": experts,\n        \"last_month_active\": last_month_active,\n        \"top_contributors\": top_contributors,\n        \"top_reviewers\": top_reviewers,\n        \"sponsors\": sponsors,\n    }\n    people_path = Path(\"./docs/en/data/people.yml\")\n    people_path.write_text(\n        yaml.dump(people, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    logging.info(\"Setting up GitHub Actions git user\")\n    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n    subprocess.run([\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True)\n    branch_name = \"fastapi-people\"\n    logging.info(f\"Creating a new branch {branch_name}\")\n    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n    logging.info(\"Adding updated file\")\n    subprocess.run([\"git\", \"add\", str(people_path)], check=True)\n    logging.info(\"Committing updated file\")\n    message = \"\ud83d\udc65 Update FastAPI People\"\n    result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n    logging.info(\"Pushing branch\")\n    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n    logging.info(\"Creating PR\")\n    pr = repo.create_pull(title=message, body=message, base=\"master\", head=branch_name)\n    logging.info(f\"Created PR: {pr.number}\")\n    logging.info(\"Finished\")\n", "fix_code": "import logging\nimport subprocess\nimport sys\nfrom collections import Counter\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Container, Dict, List, Optional, Set\n\nimport httpx\nimport yaml\nfrom github import Github\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_graphql_url = \"https://api.github.com/graphql\"\n\nissues_query = \"\"\"\nquery Q($after: String) { \n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    issues(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nprs_query = \"\"\"\nquery Q($after: String) { \n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    pullRequests(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          labels(first: 100) {\n            nodes {\n              name\n            }\n          }\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n          reviews(first:100) {\n            nodes {\n              author {\n                login\n                avatarUrl\n                url\n              }\n              state\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nsponsors_query = \"\"\"\nquery Q($after: String) {\n  user(login: \"tiangolo\") {\n    sponsorshipsAsMaintainer(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          sponsorEntity {\n            ... on Organization {\n              login\n              avatarUrl\n              url\n            }\n            ... on User {\n              login\n              avatarUrl\n              url\n            }\n          }\n          tier {\n            name\n            monthlyPriceInDollars\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\n\nclass Author(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass CommentsNode(BaseModel):\n    createdAt: datetime\n    author: Optional[Author] = None\n\n\nclass Comments(BaseModel):\n    nodes: List[CommentsNode]\n\n\nclass IssuesNode(BaseModel):\n    number: int\n    author: Optional[Author] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n\n\nclass IssuesEdge(BaseModel):\n    cursor: str\n    node: IssuesNode\n\n\nclass Issues(BaseModel):\n    edges: List[IssuesEdge]\n\n\nclass IssuesRepository(BaseModel):\n    issues: Issues\n\n\nclass IssuesResponseData(BaseModel):\n    repository: IssuesRepository\n\n\nclass IssuesResponse(BaseModel):\n    data: IssuesResponseData\n\n\nclass LabelNode(BaseModel):\n    name: str\n\n\nclass Labels(BaseModel):\n    nodes: List[LabelNode]\n\n\nclass ReviewNode(BaseModel):\n    author: Optional[Author] = None\n    state: str\n\n\nclass Reviews(BaseModel):\n    nodes: List[ReviewNode]\n\n\nclass PullRequestNode(BaseModel):\n    number: int\n    labels: Labels\n    author: Optional[Author] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n    reviews: Reviews\n\n\nclass PullRequestEdge(BaseModel):\n    cursor: str\n    node: PullRequestNode\n\n\nclass PullRequests(BaseModel):\n    edges: List[PullRequestEdge]\n\n\nclass PRsRepository(BaseModel):\n    pullRequests: PullRequests\n\n\nclass PRsResponseData(BaseModel):\n    repository: PRsRepository\n\n\nclass PRsResponse(BaseModel):\n    data: PRsResponseData\n\n\nclass SponsorEntity(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass Tier(BaseModel):\n    name: str\n    monthlyPriceInDollars: float\n\n\nclass SponsorshipAsMaintainerNode(BaseModel):\n    sponsorEntity: SponsorEntity\n    tier: Tier\n\n\nclass SponsorshipAsMaintainerEdge(BaseModel):\n    cursor: str\n    node: SponsorshipAsMaintainerNode\n\n\nclass SponsorshipAsMaintainer(BaseModel):\n    edges: List[SponsorshipAsMaintainerEdge]\n\n\nclass SponsorsUser(BaseModel):\n    sponsorshipsAsMaintainer: SponsorshipAsMaintainer\n\n\nclass SponsorsResponseData(BaseModel):\n    user: SponsorsUser\n\n\nclass SponsorsResponse(BaseModel):\n    data: SponsorsResponseData\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    github_repository: str\n\n\ndef get_graphql_response(\n    *, settings: Settings, query: str, after: Optional[str] = None\n):\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = httpx.post(\n        github_graphql_url,\n        headers=headers,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if not response.status_code == 200:\n        logging.error(f\"Response was not 200, after: {after}\")\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    return data\n\n\ndef get_graphql_issue_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.parse_obj(data)\n    return graphql_response.data.repository.issues.edges\n\n\ndef get_graphql_pr_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.parse_obj(data)\n    return graphql_response.data.repository.pullRequests.edges\n\n\ndef get_graphql_sponsor_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n    graphql_response = SponsorsResponse.parse_obj(data)\n    return graphql_response.data.user.sponsorshipsAsMaintainer.edges\n\n\ndef get_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == issue_author_name:\n                    continue\n                issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors\n\n\ndef get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors\n\n\ndef get_sponsors(settings: Settings):\n    nodes: List[SponsorshipAsMaintainerNode] = []\n    edges = get_graphql_sponsor_edges(settings=settings)\n\n    while edges:\n        for edge in edges:\n            nodes.append(edge.node)\n        last_edge = edges[-1]\n        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n\n    entities: Dict[str, SponsorEntity] = {}\n    for node in nodes:\n        entities[node.sponsorEntity.login] = node.sponsorEntity\n    return entities\n\n\ndef get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    issue_commentors, issue_last_month_commentors, issue_authors = get_experts(\n        settings=settings\n    )\n    contributors, pr_commentors, reviewers, pr_authors = get_contributors(\n        settings=settings\n    )\n    authors = {**issue_authors, **pr_authors}\n    maintainers_logins = {\"tiangolo\"}\n    bot_names = {\"codecov\", \"github-actions\"}\n    maintainers = []\n    for login in maintainers_logins:\n        user = authors[login]\n        maintainers.append(\n            {\n                \"login\": login,\n                \"answers\": issue_commentors[login],\n                \"prs\": contributors[login],\n                \"avatarUrl\": user.avatarUrl,\n                \"url\": user.url,\n            }\n        )\n\n    min_count_expert = 10\n    min_count_last_month = 3\n    min_count_contributor = 4\n    min_count_reviewer = 4\n    skip_users = maintainers_logins | bot_names\n    experts = get_top_users(\n        counter=issue_commentors,\n        min_count=min_count_expert,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    last_month_active = get_top_users(\n        counter=issue_last_month_commentors,\n        min_count=min_count_last_month,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_contributors = get_top_users(\n        counter=contributors,\n        min_count=min_count_contributor,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_reviewers = get_top_users(\n        counter=reviewers,\n        min_count=min_count_reviewer,\n        authors=authors,\n        skip_users=skip_users,\n    )\n\n    sponsors_by_login = get_sponsors(settings=settings)\n    sponsors = []\n    for login, sponsor in sponsors_by_login.items():\n        sponsors.append(\n            {\"login\": login, \"avatarUrl\": sponsor.avatarUrl, \"url\": sponsor.url}\n        )\n\n    people = {\n        \"maintainers\": maintainers,\n        \"experts\": experts,\n        \"last_month_active\": last_month_active,\n        \"top_contributors\": top_contributors,\n        \"top_reviewers\": top_reviewers,\n        \"sponsors\": sponsors,\n    }\n    people_path = Path(\"./docs/en/data/people.yml\")\n    people_old_content = people_path.read_text(encoding=\"utf-8\")\n    new_content = yaml.dump(people, sort_keys=False, width=200, allow_unicode=True)\n    if people_old_content == new_content:\n        logging.info(\"The FastAPI People data hasn't changed, finishing.\")\n        sys.exit(0)\n    people_path.write_text(new_content, encoding=\"utf-8\")\n    logging.info(\"Setting up GitHub Actions git user\")\n    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n    subprocess.run(\n        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n    )\n    branch_name = \"fastapi-people\"\n    logging.info(f\"Creating a new branch {branch_name}\")\n    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n    logging.info(\"Adding updated file\")\n    subprocess.run([\"git\", \"add\", str(people_path)], check=True)\n    logging.info(\"Committing updated file\")\n    message = \"\ud83d\udc65 Update FastAPI People\"\n    result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n    logging.info(\"Pushing branch\")\n    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n    logging.info(\"Creating PR\")\n    pr = repo.create_pull(title=message, body=message, base=\"master\", head=branch_name)\n    logging.info(f\"Created PR: {pr.number}\")\n    logging.info(\"Finished\")\n", "diff": "@@ -1,13 +1,14 @@\n import logging\n import subprocess\n+import sys\n from collections import Counter\n from datetime import datetime, timedelta, timezone\n from pathlib import Path\n from typing import Container, Dict, List, Optional, Set\n \n import httpx\n-from github import Github\n import yaml\n+from github import Github\n from pydantic import BaseModel, BaseSettings, SecretStr\n \n github_graphql_url = \"https://api.github.com/graphql\"\n@@ -487,13 +488,17 @@ if __name__ == \"__main__\":\n         \"sponsors\": sponsors,\n     }\n     people_path = Path(\"./docs/en/data/people.yml\")\n-    people_path.write_text(\n-        yaml.dump(people, sort_keys=False, width=200, allow_unicode=True),\n-        encoding=\"utf-8\",\n-    )\n+    people_old_content = people_path.read_text(encoding=\"utf-8\")\n+    new_content = yaml.dump(people, sort_keys=False, width=200, allow_unicode=True)\n+    if people_old_content == new_content:\n+        logging.info(\"The FastAPI People data hasn't changed, finishing.\")\n+        sys.exit(0)\n+    people_path.write_text(new_content, encoding=\"utf-8\")\n     logging.info(\"Setting up GitHub Actions git user\")\n     subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n-    subprocess.run([\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True)\n+    subprocess.run(\n+        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n+    )\n     branch_name = \"fastapi-people\"\n     logging.info(f\"Creating a new branch {branch_name}\")\n     subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n"}
{"commit_hash": "8650dee4bc6bbd868bfb09face4412aa7179f621", "issue_description": "\ud83d\udc1b Fix docs order generation for partial translations (#2238)", "code_before": "import os\nimport shutil\nfrom http.server import HTTPServer, SimpleHTTPRequestHandler\nfrom pathlib import Path\nfrom typing import Dict, Optional, Tuple\n\nimport mkdocs.commands.build\nimport mkdocs.commands.serve\nimport mkdocs.config\nimport mkdocs.utils\nimport typer\nimport yaml\n\napp = typer.Typer()\n\nmkdocs_name = \"mkdocs.yml\"\n\nmissing_translation_snippet = \"\"\"\n{!../../../docs/missing-translation.md!}\n\"\"\"\n\ndocs_path = Path(\"docs\")\nen_docs_path = Path(\"docs/en\")\nen_config_path: Path = en_docs_path / mkdocs_name\n\n\ndef get_en_config() -> dict:\n    return mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n\n\ndef get_lang_paths():\n    return sorted(docs_path.iterdir())\n\n\ndef lang_callback(lang: Optional[str]):\n    if lang is None:\n        return\n    if not lang.isalpha() or len(lang) != 2:\n        typer.echo(\"Use a 2 letter language code, like: es\")\n        raise typer.Abort()\n    lang = lang.lower()\n    return lang\n\n\ndef complete_existing_lang(incomplete: str):\n    lang_path: Path\n    for lang_path in get_lang_paths():\n        if lang_path.is_dir() and lang_path.name.startswith(incomplete):\n            yield lang_path.name\n\n\ndef get_base_lang_config(lang: str):\n    en_config = get_en_config()\n    fastapi_url_base = \"https://fastapi.tiangolo.com/\"\n    new_config = en_config.copy()\n    new_config[\"site_url\"] = en_config[\"site_url\"] + f\"{lang}/\"\n    new_config[\"theme\"][\"logo\"] = fastapi_url_base + en_config[\"theme\"][\"logo\"]\n    new_config[\"theme\"][\"favicon\"] = fastapi_url_base + en_config[\"theme\"][\"favicon\"]\n    new_config[\"theme\"][\"language\"] = lang\n    new_config[\"nav\"] = en_config[\"nav\"][:2]\n    extra_css = []\n    css: str\n    for css in en_config[\"extra_css\"]:\n        if css.startswith(\"http\"):\n            extra_css.append(css)\n        else:\n            extra_css.append(fastapi_url_base + css)\n    new_config[\"extra_css\"] = extra_css\n\n    extra_js = []\n    js: str\n    for js in en_config[\"extra_javascript\"]:\n        if js.startswith(\"http\"):\n            extra_js.append(js)\n        else:\n            extra_js.append(fastapi_url_base + js)\n    new_config[\"extra_javascript\"] = extra_js\n    return new_config\n\n\n@app.command()\ndef new_lang(lang: str = typer.Argument(..., callback=lang_callback)):\n    \"\"\"\n    Generate a new docs translation directory for the language LANG.\n\n    LANG should be a 2-letter language code, like: en, es, de, pt, etc.\n    \"\"\"\n    new_path: Path = Path(\"docs\") / lang\n    if new_path.exists():\n        typer.echo(f\"The language was already created: {lang}\")\n        raise typer.Abort()\n    new_path.mkdir()\n    new_config = get_base_lang_config(lang)\n    new_config_path: Path = Path(new_path) / mkdocs_name\n    new_config_path.write_text(\n        yaml.dump(new_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    new_config_docs_path: Path = new_path / \"docs\"\n    new_config_docs_path.mkdir()\n    en_index_path: Path = en_docs_path / \"docs\" / \"index.md\"\n    new_index_path: Path = new_config_docs_path / \"index.md\"\n    en_index_content = en_index_path.read_text(encoding=\"utf-8\")\n    new_index_content = f\"{missing_translation_snippet}\\n\\n{en_index_content}\"\n    new_index_path.write_text(new_index_content, encoding=\"utf-8\")\n    typer.secho(f\"Successfully initialized: {new_path}\", color=typer.colors.GREEN)\n    update_languages(lang=None)\n\n\n@app.command()\ndef build_lang(\n    lang: str = typer.Argument(\n        ..., callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Build the docs for a language, filling missing pages with translation notifications.\n    \"\"\"\n    lang_path: Path = Path(\"docs\") / lang\n    if not lang_path.is_dir():\n        typer.echo(f\"The language translation doesn't seem to exist yet: {lang}\")\n        raise typer.Abort()\n    typer.echo(f\"Building docs for: {lang}\")\n    build_dir_path = Path(\"docs_build\")\n    build_dir_path.mkdir(exist_ok=True)\n    build_lang_path = build_dir_path / lang\n    en_lang_path = Path(\"docs/en\")\n    site_path = Path(\"site\").absolute()\n    if lang == \"en\":\n        dist_path = site_path\n    else:\n        dist_path: Path = site_path / lang\n    shutil.rmtree(build_lang_path, ignore_errors=True)\n    shutil.copytree(lang_path, build_lang_path)\n    shutil.copytree(en_docs_path / \"data\", build_lang_path / \"data\")\n    en_config_path: Path = en_lang_path / mkdocs_name\n    en_config: dict = mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n    nav = en_config[\"nav\"]\n    lang_config_path: Path = lang_path / mkdocs_name\n    lang_config: dict = mkdocs.utils.yaml_load(\n        lang_config_path.read_text(encoding=\"utf-8\")\n    )\n    lang_nav = lang_config[\"nav\"]\n    # Exclude first 2 entries FastAPI and Languages, for custom handling\n    use_nav = nav[2:]\n    lang_use_nav = lang_nav[2:]\n    file_to_nav = get_file_to_nav_map(use_nav)\n    sections = get_sections(use_nav)\n    lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    use_lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    for file in file_to_nav:\n        file_path = Path(file)\n        lang_file_path: Path = build_lang_path / \"docs\" / file_path\n        en_file_path: Path = en_lang_path / \"docs\" / file_path\n        lang_file_path.parent.mkdir(parents=True, exist_ok=True)\n        if not lang_file_path.is_file():\n            en_text = en_file_path.read_text(encoding=\"utf-8\")\n            lang_text = get_text_with_translate_missing(en_text)\n            lang_file_path.write_text(lang_text, encoding=\"utf-8\")\n            file_key = file_to_nav[file]\n            use_lang_file_to_nav[file] = file_key\n            if file_key:\n                composite_key = ()\n                new_key = ()\n                for key_part in file_key:\n                    composite_key += (key_part,)\n                    key_first_file = sections[composite_key]\n                    if key_first_file in lang_file_to_nav:\n                        new_key = lang_file_to_nav[key_first_file]\n                    else:\n                        new_key += (key_part,)\n                use_lang_file_to_nav[file] = new_key\n    key_to_section = {(): []}\n    for file, file_key in use_lang_file_to_nav.items():\n        section = get_key_section(key_to_section=key_to_section, key=file_key)\n        section.append(file)\n    new_nav = key_to_section[()]\n    export_lang_nav = [lang_nav[0], nav[1]] + new_nav\n    lang_config[\"nav\"] = export_lang_nav\n    build_lang_config_path: Path = build_lang_path / mkdocs_name\n    build_lang_config_path.write_text(\n        yaml.dump(lang_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    current_dir = os.getcwd()\n    os.chdir(build_lang_path)\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(dist_path)))\n    os.chdir(current_dir)\n    typer.secho(f\"Successfully built docs for: {lang}\", color=typer.colors.GREEN)\n\n\n@app.command()\ndef build_all():\n    \"\"\"\n    Build mkdocs site for en, and then build each language inside, end result is located\n    at directory ./site/ with each language inside.\n    \"\"\"\n    site_path = Path(\"site\").absolute()\n    update_languages(lang=None)\n    en_build_path: Path = docs_path / \"en\"\n    current_dir = os.getcwd()\n    os.chdir(en_build_path)\n    typer.echo(f\"Building docs for: en\")\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(site_path)))\n    os.chdir(current_dir)\n    for lang in get_lang_paths():\n        if lang == en_build_path or not lang.is_dir():\n            continue\n        build_lang(lang.name)\n    typer.echo(\"Copying en index.md to README.md\")\n    en_index = en_build_path / \"docs\" / \"index.md\"\n    shutil.copyfile(en_index, \"README.md\")\n\n\ndef update_single_lang(lang: str):\n    lang_path = docs_path / lang\n    typer.echo(f\"Updating {lang_path.name}\")\n    update_config(lang_path.name)\n\n\n@app.command()\ndef update_languages(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Update the mkdocs.yml file Languages section including all the available languages.\n\n    The LANG argument is a 2-letter language code. If it's not provided, update all the\n    mkdocs.yml files (for all the languages).\n    \"\"\"\n    if lang is None:\n        for lang_path in get_lang_paths():\n            if lang_path.is_dir():\n                update_single_lang(lang_path.name)\n    else:\n        update_single_lang(lang)\n\n\n@app.command()\ndef serve():\n    \"\"\"\n    A quick server to preview a built site with translations.\n\n    For development, prefer the command live (or just mkdocs serve).\n\n    This is here only to preview a site with translations already built.\n\n    Make sure you run the build-all command first.\n    \"\"\"\n    typer.echo(\"Warning: this is a very simple server.\")\n    typer.echo(\"For development, use the command live instead.\")\n    typer.echo(\"This is here only to preview a site with translations already built.\")\n    typer.echo(\"Make sure you run the build-all command first.\")\n    os.chdir(\"site\")\n    server_address = (\"\", 8008)\n    server = HTTPServer(server_address, SimpleHTTPRequestHandler)\n    typer.echo(f\"Serving at: http://127.0.0.1:8008\")\n    server.serve_forever()\n\n\n@app.command()\ndef live(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Serve with livereload a docs site for a specific language.\n\n    This only shows the actual translated files, not the placeholders created with\n    build-all.\n\n    Takes an optional LANG argument with the name of the language to serve, by default\n    en.\n    \"\"\"\n    if lang is None:\n        lang = \"en\"\n    lang_path: Path = docs_path / lang\n    os.chdir(lang_path)\n    mkdocs.commands.serve.serve(dev_addr=\"127.0.0.1:8008\")\n\n\ndef update_config(lang: str):\n    lang_path: Path = docs_path / lang\n    config_path = lang_path / mkdocs_name\n    current_config: dict = mkdocs.utils.yaml_load(\n        config_path.read_text(encoding=\"utf-8\")\n    )\n    if lang == \"en\":\n        config = get_en_config()\n    else:\n        config = get_base_lang_config(lang)\n        config[\"nav\"] = current_config[\"nav\"]\n        config[\"theme\"][\"language\"] = current_config[\"theme\"][\"language\"]\n    languages = [{\"en\": \"/\"}]\n    for lang in get_lang_paths():\n        if lang.name == \"en\" or not lang.is_dir():\n            continue\n        name = lang.name\n        languages.append({name: f\"/{name}/\"})\n    config[\"nav\"][1] = {\"Languages\": languages}\n    config_path.write_text(\n        yaml.dump(config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n\n\ndef get_key_section(\n    *, key_to_section: Dict[Tuple[str, ...], list], key: Tuple[str, ...]\n) -> list:\n    if key in key_to_section:\n        return key_to_section[key]\n    super_key = key[:-1]\n    title = key[-1]\n    super_section = get_key_section(key_to_section=key_to_section, key=super_key)\n    new_section = []\n    super_section.append({title: new_section})\n    key_to_section[key] = new_section\n    return new_section\n\n\ndef get_text_with_translate_missing(text: str) -> str:\n    lines = text.splitlines()\n    lines.insert(1, missing_translation_snippet)\n    new_text = \"\\n\".join(lines)\n    return new_text\n\n\ndef get_file_to_nav_map(nav: list) -> Dict[str, Tuple[str, ...]]:\n    file_to_nav = {}\n    for item in nav:\n        if type(item) is str:\n            file_to_nav[item] = tuple()\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sub_file_to_nav = get_file_to_nav_map(sub_nav)\n            for k, v in sub_file_to_nav.items():\n                file_to_nav[k] = (item_key,) + v\n    return file_to_nav\n\n\ndef get_sections(nav: list) -> Dict[Tuple[str, ...], str]:\n    sections = {}\n    for item in nav:\n        if type(item) is str:\n            continue\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sections[(item_key,)] = sub_nav[0]\n            sub_sections = get_sections(sub_nav)\n            for k, v in sub_sections.items():\n                new_key = (item_key,) + k\n                sections[new_key] = v\n    return sections\n\n\nif __name__ == \"__main__\":\n    app()\n", "fix_code": "import os\nimport shutil\nfrom http.server import HTTPServer, SimpleHTTPRequestHandler\nfrom pathlib import Path\nfrom typing import Dict, Optional, Tuple\n\nimport mkdocs.commands.build\nimport mkdocs.commands.serve\nimport mkdocs.config\nimport mkdocs.utils\nimport typer\nimport yaml\n\napp = typer.Typer()\n\nmkdocs_name = \"mkdocs.yml\"\n\nmissing_translation_snippet = \"\"\"\n{!../../../docs/missing-translation.md!}\n\"\"\"\n\ndocs_path = Path(\"docs\")\nen_docs_path = Path(\"docs/en\")\nen_config_path: Path = en_docs_path / mkdocs_name\n\n\ndef get_en_config() -> dict:\n    return mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n\n\ndef get_lang_paths():\n    return sorted(docs_path.iterdir())\n\n\ndef lang_callback(lang: Optional[str]):\n    if lang is None:\n        return\n    if not lang.isalpha() or len(lang) != 2:\n        typer.echo(\"Use a 2 letter language code, like: es\")\n        raise typer.Abort()\n    lang = lang.lower()\n    return lang\n\n\ndef complete_existing_lang(incomplete: str):\n    lang_path: Path\n    for lang_path in get_lang_paths():\n        if lang_path.is_dir() and lang_path.name.startswith(incomplete):\n            yield lang_path.name\n\n\ndef get_base_lang_config(lang: str):\n    en_config = get_en_config()\n    fastapi_url_base = \"https://fastapi.tiangolo.com/\"\n    new_config = en_config.copy()\n    new_config[\"site_url\"] = en_config[\"site_url\"] + f\"{lang}/\"\n    new_config[\"theme\"][\"logo\"] = fastapi_url_base + en_config[\"theme\"][\"logo\"]\n    new_config[\"theme\"][\"favicon\"] = fastapi_url_base + en_config[\"theme\"][\"favicon\"]\n    new_config[\"theme\"][\"language\"] = lang\n    new_config[\"nav\"] = en_config[\"nav\"][:2]\n    extra_css = []\n    css: str\n    for css in en_config[\"extra_css\"]:\n        if css.startswith(\"http\"):\n            extra_css.append(css)\n        else:\n            extra_css.append(fastapi_url_base + css)\n    new_config[\"extra_css\"] = extra_css\n\n    extra_js = []\n    js: str\n    for js in en_config[\"extra_javascript\"]:\n        if js.startswith(\"http\"):\n            extra_js.append(js)\n        else:\n            extra_js.append(fastapi_url_base + js)\n    new_config[\"extra_javascript\"] = extra_js\n    return new_config\n\n\n@app.command()\ndef new_lang(lang: str = typer.Argument(..., callback=lang_callback)):\n    \"\"\"\n    Generate a new docs translation directory for the language LANG.\n\n    LANG should be a 2-letter language code, like: en, es, de, pt, etc.\n    \"\"\"\n    new_path: Path = Path(\"docs\") / lang\n    if new_path.exists():\n        typer.echo(f\"The language was already created: {lang}\")\n        raise typer.Abort()\n    new_path.mkdir()\n    new_config = get_base_lang_config(lang)\n    new_config_path: Path = Path(new_path) / mkdocs_name\n    new_config_path.write_text(\n        yaml.dump(new_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    new_config_docs_path: Path = new_path / \"docs\"\n    new_config_docs_path.mkdir()\n    en_index_path: Path = en_docs_path / \"docs\" / \"index.md\"\n    new_index_path: Path = new_config_docs_path / \"index.md\"\n    en_index_content = en_index_path.read_text(encoding=\"utf-8\")\n    new_index_content = f\"{missing_translation_snippet}\\n\\n{en_index_content}\"\n    new_index_path.write_text(new_index_content, encoding=\"utf-8\")\n    typer.secho(f\"Successfully initialized: {new_path}\", color=typer.colors.GREEN)\n    update_languages(lang=None)\n\n\n@app.command()\ndef build_lang(\n    lang: str = typer.Argument(\n        ..., callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Build the docs for a language, filling missing pages with translation notifications.\n    \"\"\"\n    lang_path: Path = Path(\"docs\") / lang\n    if not lang_path.is_dir():\n        typer.echo(f\"The language translation doesn't seem to exist yet: {lang}\")\n        raise typer.Abort()\n    typer.echo(f\"Building docs for: {lang}\")\n    build_dir_path = Path(\"docs_build\")\n    build_dir_path.mkdir(exist_ok=True)\n    build_lang_path = build_dir_path / lang\n    en_lang_path = Path(\"docs/en\")\n    site_path = Path(\"site\").absolute()\n    if lang == \"en\":\n        dist_path = site_path\n    else:\n        dist_path: Path = site_path / lang\n    shutil.rmtree(build_lang_path, ignore_errors=True)\n    shutil.copytree(lang_path, build_lang_path)\n    shutil.copytree(en_docs_path / \"data\", build_lang_path / \"data\")\n    en_config_path: Path = en_lang_path / mkdocs_name\n    en_config: dict = mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n    nav = en_config[\"nav\"]\n    lang_config_path: Path = lang_path / mkdocs_name\n    lang_config: dict = mkdocs.utils.yaml_load(\n        lang_config_path.read_text(encoding=\"utf-8\")\n    )\n    lang_nav = lang_config[\"nav\"]\n    # Exclude first 2 entries FastAPI and Languages, for custom handling\n    use_nav = nav[2:]\n    lang_use_nav = lang_nav[2:]\n    file_to_nav = get_file_to_nav_map(use_nav)\n    sections = get_sections(use_nav)\n    lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    use_lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    for file in file_to_nav:\n        file_path = Path(file)\n        lang_file_path: Path = build_lang_path / \"docs\" / file_path\n        en_file_path: Path = en_lang_path / \"docs\" / file_path\n        lang_file_path.parent.mkdir(parents=True, exist_ok=True)\n        if not lang_file_path.is_file():\n            en_text = en_file_path.read_text(encoding=\"utf-8\")\n            lang_text = get_text_with_translate_missing(en_text)\n            lang_file_path.write_text(lang_text, encoding=\"utf-8\")\n            file_key = file_to_nav[file]\n            use_lang_file_to_nav[file] = file_key\n            if file_key:\n                composite_key = ()\n                new_key = ()\n                for key_part in file_key:\n                    composite_key += (key_part,)\n                    key_first_file = sections[composite_key]\n                    if key_first_file in lang_file_to_nav:\n                        new_key = lang_file_to_nav[key_first_file]\n                    else:\n                        new_key += (key_part,)\n                use_lang_file_to_nav[file] = new_key\n    key_to_section = {(): []}\n    for file, orig_file_key in file_to_nav.items():\n        if file in use_lang_file_to_nav:\n            file_key = use_lang_file_to_nav[file]\n        else:\n            file_key = orig_file_key\n        section = get_key_section(key_to_section=key_to_section, key=file_key)\n        section.append(file)\n    new_nav = key_to_section[()]\n    export_lang_nav = [lang_nav[0], nav[1]] + new_nav\n    lang_config[\"nav\"] = export_lang_nav\n    build_lang_config_path: Path = build_lang_path / mkdocs_name\n    build_lang_config_path.write_text(\n        yaml.dump(lang_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    current_dir = os.getcwd()\n    os.chdir(build_lang_path)\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(dist_path)))\n    os.chdir(current_dir)\n    typer.secho(f\"Successfully built docs for: {lang}\", color=typer.colors.GREEN)\n\n\n@app.command()\ndef build_all():\n    \"\"\"\n    Build mkdocs site for en, and then build each language inside, end result is located\n    at directory ./site/ with each language inside.\n    \"\"\"\n    site_path = Path(\"site\").absolute()\n    update_languages(lang=None)\n    en_build_path: Path = docs_path / \"en\"\n    current_dir = os.getcwd()\n    os.chdir(en_build_path)\n    typer.echo(f\"Building docs for: en\")\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(site_path)))\n    os.chdir(current_dir)\n    for lang in get_lang_paths():\n        if lang == en_build_path or not lang.is_dir():\n            continue\n        build_lang(lang.name)\n    typer.echo(\"Copying en index.md to README.md\")\n    en_index = en_build_path / \"docs\" / \"index.md\"\n    shutil.copyfile(en_index, \"README.md\")\n\n\ndef update_single_lang(lang: str):\n    lang_path = docs_path / lang\n    typer.echo(f\"Updating {lang_path.name}\")\n    update_config(lang_path.name)\n\n\n@app.command()\ndef update_languages(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Update the mkdocs.yml file Languages section including all the available languages.\n\n    The LANG argument is a 2-letter language code. If it's not provided, update all the\n    mkdocs.yml files (for all the languages).\n    \"\"\"\n    if lang is None:\n        for lang_path in get_lang_paths():\n            if lang_path.is_dir():\n                update_single_lang(lang_path.name)\n    else:\n        update_single_lang(lang)\n\n\n@app.command()\ndef serve():\n    \"\"\"\n    A quick server to preview a built site with translations.\n\n    For development, prefer the command live (or just mkdocs serve).\n\n    This is here only to preview a site with translations already built.\n\n    Make sure you run the build-all command first.\n    \"\"\"\n    typer.echo(\"Warning: this is a very simple server.\")\n    typer.echo(\"For development, use the command live instead.\")\n    typer.echo(\"This is here only to preview a site with translations already built.\")\n    typer.echo(\"Make sure you run the build-all command first.\")\n    os.chdir(\"site\")\n    server_address = (\"\", 8008)\n    server = HTTPServer(server_address, SimpleHTTPRequestHandler)\n    typer.echo(f\"Serving at: http://127.0.0.1:8008\")\n    server.serve_forever()\n\n\n@app.command()\ndef live(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Serve with livereload a docs site for a specific language.\n\n    This only shows the actual translated files, not the placeholders created with\n    build-all.\n\n    Takes an optional LANG argument with the name of the language to serve, by default\n    en.\n    \"\"\"\n    if lang is None:\n        lang = \"en\"\n    lang_path: Path = docs_path / lang\n    os.chdir(lang_path)\n    mkdocs.commands.serve.serve(dev_addr=\"127.0.0.1:8008\")\n\n\ndef update_config(lang: str):\n    lang_path: Path = docs_path / lang\n    config_path = lang_path / mkdocs_name\n    current_config: dict = mkdocs.utils.yaml_load(\n        config_path.read_text(encoding=\"utf-8\")\n    )\n    if lang == \"en\":\n        config = get_en_config()\n    else:\n        config = get_base_lang_config(lang)\n        config[\"nav\"] = current_config[\"nav\"]\n        config[\"theme\"][\"language\"] = current_config[\"theme\"][\"language\"]\n    languages = [{\"en\": \"/\"}]\n    for lang in get_lang_paths():\n        if lang.name == \"en\" or not lang.is_dir():\n            continue\n        name = lang.name\n        languages.append({name: f\"/{name}/\"})\n    config[\"nav\"][1] = {\"Languages\": languages}\n    config_path.write_text(\n        yaml.dump(config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n\n\ndef get_key_section(\n    *, key_to_section: Dict[Tuple[str, ...], list], key: Tuple[str, ...]\n) -> list:\n    if key in key_to_section:\n        return key_to_section[key]\n    super_key = key[:-1]\n    title = key[-1]\n    super_section = get_key_section(key_to_section=key_to_section, key=super_key)\n    new_section = []\n    super_section.append({title: new_section})\n    key_to_section[key] = new_section\n    return new_section\n\n\ndef get_text_with_translate_missing(text: str) -> str:\n    lines = text.splitlines()\n    lines.insert(1, missing_translation_snippet)\n    new_text = \"\\n\".join(lines)\n    return new_text\n\n\ndef get_file_to_nav_map(nav: list) -> Dict[str, Tuple[str, ...]]:\n    file_to_nav = {}\n    for item in nav:\n        if type(item) is str:\n            file_to_nav[item] = tuple()\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sub_file_to_nav = get_file_to_nav_map(sub_nav)\n            for k, v in sub_file_to_nav.items():\n                file_to_nav[k] = (item_key,) + v\n    return file_to_nav\n\n\ndef get_sections(nav: list) -> Dict[Tuple[str, ...], str]:\n    sections = {}\n    for item in nav:\n        if type(item) is str:\n            continue\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sections[(item_key,)] = sub_nav[0]\n            sub_sections = get_sections(sub_nav)\n            for k, v in sub_sections.items():\n                new_key = (item_key,) + k\n                sections[new_key] = v\n    return sections\n\n\nif __name__ == \"__main__\":\n    app()\n", "diff": "@@ -171,7 +171,11 @@ def build_lang(\n                         new_key += (key_part,)\n                 use_lang_file_to_nav[file] = new_key\n     key_to_section = {(): []}\n-    for file, file_key in use_lang_file_to_nav.items():\n+    for file, orig_file_key in file_to_nav.items():\n+        if file in use_lang_file_to_nav:\n+            file_key = use_lang_file_to_nav[file]\n+        else:\n+            file_key = orig_file_key\n         section = get_key_section(key_to_section=key_to_section, key=file_key)\n         section.append(file)\n     new_nav = key_to_section[()]\n"}
{"commit_hash": "dfcc6bc154d3d6fb0a072649234c5fc3c2b19673", "issue_description": "\ud83d\udcdd Fix example code with sets in Tutorial - Body - Nested Models (#2052)", "code_before": "from typing import List, Optional, Set\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n    tags: Set[str] = []\n    images: Optional[List[Image]] = None\n\n\nclass Offer(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    items: List[Item]\n\n\n@app.post(\"/offers/\")\nasync def create_offer(offer: Offer):\n    return offer\n", "fix_code": "from typing import List, Optional, Set\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n    tags: Set[str] = set()\n    images: Optional[List[Image]] = None\n\n\nclass Offer(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    items: List[Item]\n\n\n@app.post(\"/offers/\")\nasync def create_offer(offer: Offer):\n    return offer\n", "diff": "@@ -16,7 +16,7 @@ class Item(BaseModel):\n     description: Optional[str] = None\n     price: float\n     tax: Optional[float] = None\n-    tags: Set[str] = []\n+    tags: Set[str] = set()\n     images: Optional[List[Image]] = None\n \n \n"}
{"commit_hash": "c041c52d9122ce666b7b1935d5c7011b03830560", "issue_description": "\ud83d\udcdd Fix example code with sets in Tutorial - Body - Nested Models 2 (#2053)", "code_before": "from typing import List, Optional, Set\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n    tags: Set[str] = []\n    images: Optional[List[Image]] = None\n\n\n@app.put(\"/items/{item_id}\")\nasync def update_item(item_id: int, item: Item):\n    results = {\"item_id\": item_id, \"item\": item}\n    return results\n", "fix_code": "from typing import List, Optional, Set\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, HttpUrl\n\napp = FastAPI()\n\n\nclass Image(BaseModel):\n    url: HttpUrl\n    name: str\n\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n    tags: Set[str] = set()\n    images: Optional[List[Image]] = None\n\n\n@app.put(\"/items/{item_id}\")\nasync def update_item(item_id: int, item: Item):\n    results = {\"item_id\": item_id, \"item\": item}\n    return results\n", "diff": "@@ -16,7 +16,7 @@ class Item(BaseModel):\n     description: Optional[str] = None\n     price: float\n     tax: Optional[float] = None\n-    tags: Set[str] = []\n+    tags: Set[str] = set()\n     images: Optional[List[Image]] = None\n \n \n"}
{"commit_hash": "273b2cd6462ef8c3baa38997bb13f5fe4f15c892", "issue_description": "\ud83d\udc1b Fix docs script to generate a new translation language with overrides boilerplate (#3202)", "code_before": "import os\nimport re\nimport shutil\nfrom http.server import HTTPServer, SimpleHTTPRequestHandler\nfrom multiprocessing import Pool\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\nimport mkdocs.commands.build\nimport mkdocs.commands.serve\nimport mkdocs.config\nimport mkdocs.utils\nimport typer\nimport yaml\nfrom jinja2 import Template\n\napp = typer.Typer()\n\nmkdocs_name = \"mkdocs.yml\"\n\nmissing_translation_snippet = \"\"\"\n{!../../../docs/missing-translation.md!}\n\"\"\"\n\ndocs_path = Path(\"docs\")\nen_docs_path = Path(\"docs/en\")\nen_config_path: Path = en_docs_path / mkdocs_name\n\n\ndef get_en_config() -> dict:\n    return mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n\n\ndef get_lang_paths():\n    return sorted(docs_path.iterdir())\n\n\ndef lang_callback(lang: Optional[str]):\n    if lang is None:\n        return\n    if not lang.isalpha() or len(lang) != 2:\n        typer.echo(\"Use a 2 letter language code, like: es\")\n        raise typer.Abort()\n    lang = lang.lower()\n    return lang\n\n\ndef complete_existing_lang(incomplete: str):\n    lang_path: Path\n    for lang_path in get_lang_paths():\n        if lang_path.is_dir() and lang_path.name.startswith(incomplete):\n            yield lang_path.name\n\n\ndef get_base_lang_config(lang: str):\n    en_config = get_en_config()\n    fastapi_url_base = \"https://fastapi.tiangolo.com/\"\n    new_config = en_config.copy()\n    new_config[\"site_url\"] = en_config[\"site_url\"] + f\"{lang}/\"\n    new_config[\"theme\"][\"logo\"] = fastapi_url_base + en_config[\"theme\"][\"logo\"]\n    new_config[\"theme\"][\"favicon\"] = fastapi_url_base + en_config[\"theme\"][\"favicon\"]\n    new_config[\"theme\"][\"language\"] = lang\n    new_config[\"nav\"] = en_config[\"nav\"][:2]\n    extra_css = []\n    css: str\n    for css in en_config[\"extra_css\"]:\n        if css.startswith(\"http\"):\n            extra_css.append(css)\n        else:\n            extra_css.append(fastapi_url_base + css)\n    new_config[\"extra_css\"] = extra_css\n\n    extra_js = []\n    js: str\n    for js in en_config[\"extra_javascript\"]:\n        if js.startswith(\"http\"):\n            extra_js.append(js)\n        else:\n            extra_js.append(fastapi_url_base + js)\n    new_config[\"extra_javascript\"] = extra_js\n    return new_config\n\n\n@app.command()\ndef new_lang(lang: str = typer.Argument(..., callback=lang_callback)):\n    \"\"\"\n    Generate a new docs translation directory for the language LANG.\n\n    LANG should be a 2-letter language code, like: en, es, de, pt, etc.\n    \"\"\"\n    new_path: Path = Path(\"docs\") / lang\n    if new_path.exists():\n        typer.echo(f\"The language was already created: {lang}\")\n        raise typer.Abort()\n    new_path.mkdir()\n    new_config = get_base_lang_config(lang)\n    new_config_path: Path = Path(new_path) / mkdocs_name\n    new_config_path.write_text(\n        yaml.dump(new_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    new_config_docs_path: Path = new_path / \"docs\"\n    new_config_docs_path.mkdir()\n    en_index_path: Path = en_docs_path / \"docs\" / \"index.md\"\n    new_index_path: Path = new_config_docs_path / \"index.md\"\n    en_index_content = en_index_path.read_text(encoding=\"utf-8\")\n    new_index_content = f\"{missing_translation_snippet}\\n\\n{en_index_content}\"\n    new_index_path.write_text(new_index_content, encoding=\"utf-8\")\n    typer.secho(f\"Successfully initialized: {new_path}\", color=typer.colors.GREEN)\n    update_languages(lang=None)\n\n\n@app.command()\ndef build_lang(\n    lang: str = typer.Argument(\n        ..., callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Build the docs for a language, filling missing pages with translation notifications.\n    \"\"\"\n    lang_path: Path = Path(\"docs\") / lang\n    if not lang_path.is_dir():\n        typer.echo(f\"The language translation doesn't seem to exist yet: {lang}\")\n        raise typer.Abort()\n    typer.echo(f\"Building docs for: {lang}\")\n    build_dir_path = Path(\"docs_build\")\n    build_dir_path.mkdir(exist_ok=True)\n    build_lang_path = build_dir_path / lang\n    en_lang_path = Path(\"docs/en\")\n    site_path = Path(\"site\").absolute()\n    if lang == \"en\":\n        dist_path = site_path\n    else:\n        dist_path: Path = site_path / lang\n    shutil.rmtree(build_lang_path, ignore_errors=True)\n    shutil.copytree(lang_path, build_lang_path)\n    shutil.copytree(en_docs_path / \"data\", build_lang_path / \"data\")\n    overrides_src = en_docs_path / \"overrides\"\n    overrides_dest = build_lang_path / \"overrides\"\n    for path in overrides_src.iterdir():\n        dest_path = overrides_dest / path.name\n        if not dest_path.exists():\n            shutil.copy(path, dest_path)\n    en_config_path: Path = en_lang_path / mkdocs_name\n    en_config: dict = mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n    nav = en_config[\"nav\"]\n    lang_config_path: Path = lang_path / mkdocs_name\n    lang_config: dict = mkdocs.utils.yaml_load(\n        lang_config_path.read_text(encoding=\"utf-8\")\n    )\n    lang_nav = lang_config[\"nav\"]\n    # Exclude first 2 entries FastAPI and Languages, for custom handling\n    use_nav = nav[2:]\n    lang_use_nav = lang_nav[2:]\n    file_to_nav = get_file_to_nav_map(use_nav)\n    sections = get_sections(use_nav)\n    lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    use_lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    for file in file_to_nav:\n        file_path = Path(file)\n        lang_file_path: Path = build_lang_path / \"docs\" / file_path\n        en_file_path: Path = en_lang_path / \"docs\" / file_path\n        lang_file_path.parent.mkdir(parents=True, exist_ok=True)\n        if not lang_file_path.is_file():\n            en_text = en_file_path.read_text(encoding=\"utf-8\")\n            lang_text = get_text_with_translate_missing(en_text)\n            lang_file_path.write_text(lang_text, encoding=\"utf-8\")\n            file_key = file_to_nav[file]\n            use_lang_file_to_nav[file] = file_key\n            if file_key:\n                composite_key = ()\n                new_key = ()\n                for key_part in file_key:\n                    composite_key += (key_part,)\n                    key_first_file = sections[composite_key]\n                    if key_first_file in lang_file_to_nav:\n                        new_key = lang_file_to_nav[key_first_file]\n                    else:\n                        new_key += (key_part,)\n                use_lang_file_to_nav[file] = new_key\n    key_to_section = {(): []}\n    for file, orig_file_key in file_to_nav.items():\n        if file in use_lang_file_to_nav:\n            file_key = use_lang_file_to_nav[file]\n        else:\n            file_key = orig_file_key\n        section = get_key_section(key_to_section=key_to_section, key=file_key)\n        section.append(file)\n    new_nav = key_to_section[()]\n    export_lang_nav = [lang_nav[0], nav[1]] + new_nav\n    lang_config[\"nav\"] = export_lang_nav\n    build_lang_config_path: Path = build_lang_path / mkdocs_name\n    build_lang_config_path.write_text(\n        yaml.dump(lang_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    current_dir = os.getcwd()\n    os.chdir(build_lang_path)\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(dist_path)))\n    os.chdir(current_dir)\n    typer.secho(f\"Successfully built docs for: {lang}\", color=typer.colors.GREEN)\n\n\nindex_sponsors_template = \"\"\"\n{% if sponsors %}\n{% for sponsor in sponsors.gold -%}\n<a href=\"{{ sponsor.url }}\" target=\"_blank\" title=\"{{ sponsor.title }}\"><img src=\"{{ sponsor.img }}\"></a>\n{% endfor -%}\n{%- for sponsor in sponsors.silver -%}\n<a href=\"{{ sponsor.url }}\" target=\"_blank\" title=\"{{ sponsor.title }}\"><img src=\"{{ sponsor.img }}\"></a>\n{% endfor %}\n{% endif %}\n\"\"\"\n\n\ndef generate_readme_content():\n    en_index = en_docs_path / \"docs\" / \"index.md\"\n    content = en_index.read_text(\"utf-8\")\n    match_start = re.search(r\"<!-- sponsors -->\", content)\n    match_end = re.search(r\"<!-- /sponsors -->\", content)\n    sponsors_data_path = en_docs_path / \"data\" / \"sponsors.yml\"\n    sponsors = mkdocs.utils.yaml_load(sponsors_data_path.read_text(encoding=\"utf-8\"))\n    if not (match_start and match_end):\n        raise RuntimeError(\"Couldn't auto-generate sponsors section\")\n    pre_end = match_start.end()\n    post_start = match_end.start()\n    template = Template(index_sponsors_template)\n    message = template.render(sponsors=sponsors)\n    pre_content = content[:pre_end]\n    post_content = content[post_start:]\n    new_content = pre_content + message + post_content\n    return new_content\n\n\n@app.command()\ndef generate_readme():\n    \"\"\"\n    Generate README.md content from main index.md\n    \"\"\"\n    typer.echo(\"Generating README\")\n    readme_path = Path(\"README.md\")\n    new_content = generate_readme_content()\n    readme_path.write_text(new_content, encoding=\"utf-8\")\n\n\n@app.command()\ndef verify_readme():\n    \"\"\"\n    Verify README.md content from main index.md\n    \"\"\"\n    typer.echo(\"Verifying README\")\n    readme_path = Path(\"README.md\")\n    generated_content = generate_readme_content()\n    readme_content = readme_path.read_text(\"utf-8\")\n    if generated_content != readme_content:\n        typer.secho(\n            \"README.md outdated from the latest index.md\", color=typer.colors.RED\n        )\n        raise typer.Abort()\n    typer.echo(\"Valid README \u2705\")\n\n\n@app.command()\ndef build_all():\n    \"\"\"\n    Build mkdocs site for en, and then build each language inside, end result is located\n    at directory ./site/ with each language inside.\n    \"\"\"\n    site_path = Path(\"site\").absolute()\n    update_languages(lang=None)\n    current_dir = os.getcwd()\n    os.chdir(en_docs_path)\n    typer.echo(\"Building docs for: en\")\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(site_path)))\n    os.chdir(current_dir)\n    langs = []\n    for lang in get_lang_paths():\n        if lang == en_docs_path or not lang.is_dir():\n            continue\n        langs.append(lang.name)\n    cpu_count = os.cpu_count() or 1\n    with Pool(cpu_count * 2) as p:\n        p.map(build_lang, langs)\n\n\ndef update_single_lang(lang: str):\n    lang_path = docs_path / lang\n    typer.echo(f\"Updating {lang_path.name}\")\n    update_config(lang_path.name)\n\n\n@app.command()\ndef update_languages(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Update the mkdocs.yml file Languages section including all the available languages.\n\n    The LANG argument is a 2-letter language code. If it's not provided, update all the\n    mkdocs.yml files (for all the languages).\n    \"\"\"\n    if lang is None:\n        for lang_path in get_lang_paths():\n            if lang_path.is_dir():\n                update_single_lang(lang_path.name)\n    else:\n        update_single_lang(lang)\n\n\n@app.command()\ndef serve():\n    \"\"\"\n    A quick server to preview a built site with translations.\n\n    For development, prefer the command live (or just mkdocs serve).\n\n    This is here only to preview a site with translations already built.\n\n    Make sure you run the build-all command first.\n    \"\"\"\n    typer.echo(\"Warning: this is a very simple server.\")\n    typer.echo(\"For development, use the command live instead.\")\n    typer.echo(\"This is here only to preview a site with translations already built.\")\n    typer.echo(\"Make sure you run the build-all command first.\")\n    os.chdir(\"site\")\n    server_address = (\"\", 8008)\n    server = HTTPServer(server_address, SimpleHTTPRequestHandler)\n    typer.echo(f\"Serving at: http://127.0.0.1:8008\")\n    server.serve_forever()\n\n\n@app.command()\ndef live(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Serve with livereload a docs site for a specific language.\n\n    This only shows the actual translated files, not the placeholders created with\n    build-all.\n\n    Takes an optional LANG argument with the name of the language to serve, by default\n    en.\n    \"\"\"\n    if lang is None:\n        lang = \"en\"\n    lang_path: Path = docs_path / lang\n    os.chdir(lang_path)\n    mkdocs.commands.serve.serve(dev_addr=\"127.0.0.1:8008\")\n\n\ndef update_config(lang: str):\n    lang_path: Path = docs_path / lang\n    config_path = lang_path / mkdocs_name\n    current_config: dict = mkdocs.utils.yaml_load(\n        config_path.read_text(encoding=\"utf-8\")\n    )\n    if lang == \"en\":\n        config = get_en_config()\n    else:\n        config = get_base_lang_config(lang)\n        config[\"nav\"] = current_config[\"nav\"]\n        config[\"theme\"][\"language\"] = current_config[\"theme\"][\"language\"]\n    languages = [{\"en\": \"/\"}]\n    alternate: List[Dict[str, str]] = config[\"extra\"].get(\"alternate\", [])\n    alternate_dict = {alt[\"link\"]: alt[\"name\"] for alt in alternate}\n    new_alternate: List[Dict[str, str]] = []\n    for lang_path in get_lang_paths():\n        if lang_path.name == \"en\" or not lang_path.is_dir():\n            continue\n        name = lang_path.name\n        languages.append({name: f\"/{name}/\"})\n    for lang_dict in languages:\n        name = list(lang_dict.keys())[0]\n        url = lang_dict[name]\n        if url not in alternate_dict:\n            new_alternate.append({\"link\": url, \"name\": name})\n        else:\n            use_name = alternate_dict[url]\n            new_alternate.append({\"link\": url, \"name\": use_name})\n    config[\"nav\"][1] = {\"Languages\": languages}\n    config[\"extra\"][\"alternate\"] = new_alternate\n    config_path.write_text(\n        yaml.dump(config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n\n\ndef get_key_section(\n    *, key_to_section: Dict[Tuple[str, ...], list], key: Tuple[str, ...]\n) -> list:\n    if key in key_to_section:\n        return key_to_section[key]\n    super_key = key[:-1]\n    title = key[-1]\n    super_section = get_key_section(key_to_section=key_to_section, key=super_key)\n    new_section = []\n    super_section.append({title: new_section})\n    key_to_section[key] = new_section\n    return new_section\n\n\ndef get_text_with_translate_missing(text: str) -> str:\n    lines = text.splitlines()\n    lines.insert(1, missing_translation_snippet)\n    new_text = \"\\n\".join(lines)\n    return new_text\n\n\ndef get_file_to_nav_map(nav: list) -> Dict[str, Tuple[str, ...]]:\n    file_to_nav = {}\n    for item in nav:\n        if type(item) is str:\n            file_to_nav[item] = tuple()\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sub_file_to_nav = get_file_to_nav_map(sub_nav)\n            for k, v in sub_file_to_nav.items():\n                file_to_nav[k] = (item_key,) + v\n    return file_to_nav\n\n\ndef get_sections(nav: list) -> Dict[Tuple[str, ...], str]:\n    sections = {}\n    for item in nav:\n        if type(item) is str:\n            continue\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sections[(item_key,)] = sub_nav[0]\n            sub_sections = get_sections(sub_nav)\n            for k, v in sub_sections.items():\n                new_key = (item_key,) + k\n                sections[new_key] = v\n    return sections\n\n\nif __name__ == \"__main__\":\n    app()\n", "fix_code": "import os\nimport re\nimport shutil\nfrom http.server import HTTPServer, SimpleHTTPRequestHandler\nfrom multiprocessing import Pool\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\nimport mkdocs.commands.build\nimport mkdocs.commands.serve\nimport mkdocs.config\nimport mkdocs.utils\nimport typer\nimport yaml\nfrom jinja2 import Template\n\napp = typer.Typer()\n\nmkdocs_name = \"mkdocs.yml\"\n\nmissing_translation_snippet = \"\"\"\n{!../../../docs/missing-translation.md!}\n\"\"\"\n\ndocs_path = Path(\"docs\")\nen_docs_path = Path(\"docs/en\")\nen_config_path: Path = en_docs_path / mkdocs_name\n\n\ndef get_en_config() -> dict:\n    return mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n\n\ndef get_lang_paths():\n    return sorted(docs_path.iterdir())\n\n\ndef lang_callback(lang: Optional[str]):\n    if lang is None:\n        return\n    if not lang.isalpha() or len(lang) != 2:\n        typer.echo(\"Use a 2 letter language code, like: es\")\n        raise typer.Abort()\n    lang = lang.lower()\n    return lang\n\n\ndef complete_existing_lang(incomplete: str):\n    lang_path: Path\n    for lang_path in get_lang_paths():\n        if lang_path.is_dir() and lang_path.name.startswith(incomplete):\n            yield lang_path.name\n\n\ndef get_base_lang_config(lang: str):\n    en_config = get_en_config()\n    fastapi_url_base = \"https://fastapi.tiangolo.com/\"\n    new_config = en_config.copy()\n    new_config[\"site_url\"] = en_config[\"site_url\"] + f\"{lang}/\"\n    new_config[\"theme\"][\"logo\"] = fastapi_url_base + en_config[\"theme\"][\"logo\"]\n    new_config[\"theme\"][\"favicon\"] = fastapi_url_base + en_config[\"theme\"][\"favicon\"]\n    new_config[\"theme\"][\"language\"] = lang\n    new_config[\"nav\"] = en_config[\"nav\"][:2]\n    extra_css = []\n    css: str\n    for css in en_config[\"extra_css\"]:\n        if css.startswith(\"http\"):\n            extra_css.append(css)\n        else:\n            extra_css.append(fastapi_url_base + css)\n    new_config[\"extra_css\"] = extra_css\n\n    extra_js = []\n    js: str\n    for js in en_config[\"extra_javascript\"]:\n        if js.startswith(\"http\"):\n            extra_js.append(js)\n        else:\n            extra_js.append(fastapi_url_base + js)\n    new_config[\"extra_javascript\"] = extra_js\n    return new_config\n\n\n@app.command()\ndef new_lang(lang: str = typer.Argument(..., callback=lang_callback)):\n    \"\"\"\n    Generate a new docs translation directory for the language LANG.\n\n    LANG should be a 2-letter language code, like: en, es, de, pt, etc.\n    \"\"\"\n    new_path: Path = Path(\"docs\") / lang\n    if new_path.exists():\n        typer.echo(f\"The language was already created: {lang}\")\n        raise typer.Abort()\n    new_path.mkdir()\n    new_config = get_base_lang_config(lang)\n    new_config_path: Path = Path(new_path) / mkdocs_name\n    new_config_path.write_text(\n        yaml.dump(new_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    new_config_docs_path: Path = new_path / \"docs\"\n    new_config_docs_path.mkdir()\n    en_index_path: Path = en_docs_path / \"docs\" / \"index.md\"\n    new_index_path: Path = new_config_docs_path / \"index.md\"\n    en_index_content = en_index_path.read_text(encoding=\"utf-8\")\n    new_index_content = f\"{missing_translation_snippet}\\n\\n{en_index_content}\"\n    new_index_path.write_text(new_index_content, encoding=\"utf-8\")\n    new_overrides_gitignore_path = new_path / \"overrides\" / \".gitignore\"\n    new_overrides_gitignore_path.parent.mkdir(parents=True, exist_ok=True)\n    new_overrides_gitignore_path.write_text(\"\")\n    typer.secho(f\"Successfully initialized: {new_path}\", color=typer.colors.GREEN)\n    update_languages(lang=None)\n\n\n@app.command()\ndef build_lang(\n    lang: str = typer.Argument(\n        ..., callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Build the docs for a language, filling missing pages with translation notifications.\n    \"\"\"\n    lang_path: Path = Path(\"docs\") / lang\n    if not lang_path.is_dir():\n        typer.echo(f\"The language translation doesn't seem to exist yet: {lang}\")\n        raise typer.Abort()\n    typer.echo(f\"Building docs for: {lang}\")\n    build_dir_path = Path(\"docs_build\")\n    build_dir_path.mkdir(exist_ok=True)\n    build_lang_path = build_dir_path / lang\n    en_lang_path = Path(\"docs/en\")\n    site_path = Path(\"site\").absolute()\n    if lang == \"en\":\n        dist_path = site_path\n    else:\n        dist_path: Path = site_path / lang\n    shutil.rmtree(build_lang_path, ignore_errors=True)\n    shutil.copytree(lang_path, build_lang_path)\n    shutil.copytree(en_docs_path / \"data\", build_lang_path / \"data\")\n    overrides_src = en_docs_path / \"overrides\"\n    overrides_dest = build_lang_path / \"overrides\"\n    for path in overrides_src.iterdir():\n        dest_path = overrides_dest / path.name\n        if not dest_path.exists():\n            shutil.copy(path, dest_path)\n    en_config_path: Path = en_lang_path / mkdocs_name\n    en_config: dict = mkdocs.utils.yaml_load(en_config_path.read_text(encoding=\"utf-8\"))\n    nav = en_config[\"nav\"]\n    lang_config_path: Path = lang_path / mkdocs_name\n    lang_config: dict = mkdocs.utils.yaml_load(\n        lang_config_path.read_text(encoding=\"utf-8\")\n    )\n    lang_nav = lang_config[\"nav\"]\n    # Exclude first 2 entries FastAPI and Languages, for custom handling\n    use_nav = nav[2:]\n    lang_use_nav = lang_nav[2:]\n    file_to_nav = get_file_to_nav_map(use_nav)\n    sections = get_sections(use_nav)\n    lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    use_lang_file_to_nav = get_file_to_nav_map(lang_use_nav)\n    for file in file_to_nav:\n        file_path = Path(file)\n        lang_file_path: Path = build_lang_path / \"docs\" / file_path\n        en_file_path: Path = en_lang_path / \"docs\" / file_path\n        lang_file_path.parent.mkdir(parents=True, exist_ok=True)\n        if not lang_file_path.is_file():\n            en_text = en_file_path.read_text(encoding=\"utf-8\")\n            lang_text = get_text_with_translate_missing(en_text)\n            lang_file_path.write_text(lang_text, encoding=\"utf-8\")\n            file_key = file_to_nav[file]\n            use_lang_file_to_nav[file] = file_key\n            if file_key:\n                composite_key = ()\n                new_key = ()\n                for key_part in file_key:\n                    composite_key += (key_part,)\n                    key_first_file = sections[composite_key]\n                    if key_first_file in lang_file_to_nav:\n                        new_key = lang_file_to_nav[key_first_file]\n                    else:\n                        new_key += (key_part,)\n                use_lang_file_to_nav[file] = new_key\n    key_to_section = {(): []}\n    for file, orig_file_key in file_to_nav.items():\n        if file in use_lang_file_to_nav:\n            file_key = use_lang_file_to_nav[file]\n        else:\n            file_key = orig_file_key\n        section = get_key_section(key_to_section=key_to_section, key=file_key)\n        section.append(file)\n    new_nav = key_to_section[()]\n    export_lang_nav = [lang_nav[0], nav[1]] + new_nav\n    lang_config[\"nav\"] = export_lang_nav\n    build_lang_config_path: Path = build_lang_path / mkdocs_name\n    build_lang_config_path.write_text(\n        yaml.dump(lang_config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n    current_dir = os.getcwd()\n    os.chdir(build_lang_path)\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(dist_path)))\n    os.chdir(current_dir)\n    typer.secho(f\"Successfully built docs for: {lang}\", color=typer.colors.GREEN)\n\n\nindex_sponsors_template = \"\"\"\n{% if sponsors %}\n{% for sponsor in sponsors.gold -%}\n<a href=\"{{ sponsor.url }}\" target=\"_blank\" title=\"{{ sponsor.title }}\"><img src=\"{{ sponsor.img }}\"></a>\n{% endfor -%}\n{%- for sponsor in sponsors.silver -%}\n<a href=\"{{ sponsor.url }}\" target=\"_blank\" title=\"{{ sponsor.title }}\"><img src=\"{{ sponsor.img }}\"></a>\n{% endfor %}\n{% endif %}\n\"\"\"\n\n\ndef generate_readme_content():\n    en_index = en_docs_path / \"docs\" / \"index.md\"\n    content = en_index.read_text(\"utf-8\")\n    match_start = re.search(r\"<!-- sponsors -->\", content)\n    match_end = re.search(r\"<!-- /sponsors -->\", content)\n    sponsors_data_path = en_docs_path / \"data\" / \"sponsors.yml\"\n    sponsors = mkdocs.utils.yaml_load(sponsors_data_path.read_text(encoding=\"utf-8\"))\n    if not (match_start and match_end):\n        raise RuntimeError(\"Couldn't auto-generate sponsors section\")\n    pre_end = match_start.end()\n    post_start = match_end.start()\n    template = Template(index_sponsors_template)\n    message = template.render(sponsors=sponsors)\n    pre_content = content[:pre_end]\n    post_content = content[post_start:]\n    new_content = pre_content + message + post_content\n    return new_content\n\n\n@app.command()\ndef generate_readme():\n    \"\"\"\n    Generate README.md content from main index.md\n    \"\"\"\n    typer.echo(\"Generating README\")\n    readme_path = Path(\"README.md\")\n    new_content = generate_readme_content()\n    readme_path.write_text(new_content, encoding=\"utf-8\")\n\n\n@app.command()\ndef verify_readme():\n    \"\"\"\n    Verify README.md content from main index.md\n    \"\"\"\n    typer.echo(\"Verifying README\")\n    readme_path = Path(\"README.md\")\n    generated_content = generate_readme_content()\n    readme_content = readme_path.read_text(\"utf-8\")\n    if generated_content != readme_content:\n        typer.secho(\n            \"README.md outdated from the latest index.md\", color=typer.colors.RED\n        )\n        raise typer.Abort()\n    typer.echo(\"Valid README \u2705\")\n\n\n@app.command()\ndef build_all():\n    \"\"\"\n    Build mkdocs site for en, and then build each language inside, end result is located\n    at directory ./site/ with each language inside.\n    \"\"\"\n    site_path = Path(\"site\").absolute()\n    update_languages(lang=None)\n    current_dir = os.getcwd()\n    os.chdir(en_docs_path)\n    typer.echo(\"Building docs for: en\")\n    mkdocs.commands.build.build(mkdocs.config.load_config(site_dir=str(site_path)))\n    os.chdir(current_dir)\n    langs = []\n    for lang in get_lang_paths():\n        if lang == en_docs_path or not lang.is_dir():\n            continue\n        langs.append(lang.name)\n    cpu_count = os.cpu_count() or 1\n    with Pool(cpu_count * 2) as p:\n        p.map(build_lang, langs)\n\n\ndef update_single_lang(lang: str):\n    lang_path = docs_path / lang\n    typer.echo(f\"Updating {lang_path.name}\")\n    update_config(lang_path.name)\n\n\n@app.command()\ndef update_languages(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Update the mkdocs.yml file Languages section including all the available languages.\n\n    The LANG argument is a 2-letter language code. If it's not provided, update all the\n    mkdocs.yml files (for all the languages).\n    \"\"\"\n    if lang is None:\n        for lang_path in get_lang_paths():\n            if lang_path.is_dir():\n                update_single_lang(lang_path.name)\n    else:\n        update_single_lang(lang)\n\n\n@app.command()\ndef serve():\n    \"\"\"\n    A quick server to preview a built site with translations.\n\n    For development, prefer the command live (or just mkdocs serve).\n\n    This is here only to preview a site with translations already built.\n\n    Make sure you run the build-all command first.\n    \"\"\"\n    typer.echo(\"Warning: this is a very simple server.\")\n    typer.echo(\"For development, use the command live instead.\")\n    typer.echo(\"This is here only to preview a site with translations already built.\")\n    typer.echo(\"Make sure you run the build-all command first.\")\n    os.chdir(\"site\")\n    server_address = (\"\", 8008)\n    server = HTTPServer(server_address, SimpleHTTPRequestHandler)\n    typer.echo(f\"Serving at: http://127.0.0.1:8008\")\n    server.serve_forever()\n\n\n@app.command()\ndef live(\n    lang: str = typer.Argument(\n        None, callback=lang_callback, autocompletion=complete_existing_lang\n    )\n):\n    \"\"\"\n    Serve with livereload a docs site for a specific language.\n\n    This only shows the actual translated files, not the placeholders created with\n    build-all.\n\n    Takes an optional LANG argument with the name of the language to serve, by default\n    en.\n    \"\"\"\n    if lang is None:\n        lang = \"en\"\n    lang_path: Path = docs_path / lang\n    os.chdir(lang_path)\n    mkdocs.commands.serve.serve(dev_addr=\"127.0.0.1:8008\")\n\n\ndef update_config(lang: str):\n    lang_path: Path = docs_path / lang\n    config_path = lang_path / mkdocs_name\n    current_config: dict = mkdocs.utils.yaml_load(\n        config_path.read_text(encoding=\"utf-8\")\n    )\n    if lang == \"en\":\n        config = get_en_config()\n    else:\n        config = get_base_lang_config(lang)\n        config[\"nav\"] = current_config[\"nav\"]\n        config[\"theme\"][\"language\"] = current_config[\"theme\"][\"language\"]\n    languages = [{\"en\": \"/\"}]\n    alternate: List[Dict[str, str]] = config[\"extra\"].get(\"alternate\", [])\n    alternate_dict = {alt[\"link\"]: alt[\"name\"] for alt in alternate}\n    new_alternate: List[Dict[str, str]] = []\n    for lang_path in get_lang_paths():\n        if lang_path.name == \"en\" or not lang_path.is_dir():\n            continue\n        name = lang_path.name\n        languages.append({name: f\"/{name}/\"})\n    for lang_dict in languages:\n        name = list(lang_dict.keys())[0]\n        url = lang_dict[name]\n        if url not in alternate_dict:\n            new_alternate.append({\"link\": url, \"name\": name})\n        else:\n            use_name = alternate_dict[url]\n            new_alternate.append({\"link\": url, \"name\": use_name})\n    config[\"nav\"][1] = {\"Languages\": languages}\n    config[\"extra\"][\"alternate\"] = new_alternate\n    config_path.write_text(\n        yaml.dump(config, sort_keys=False, width=200, allow_unicode=True),\n        encoding=\"utf-8\",\n    )\n\n\ndef get_key_section(\n    *, key_to_section: Dict[Tuple[str, ...], list], key: Tuple[str, ...]\n) -> list:\n    if key in key_to_section:\n        return key_to_section[key]\n    super_key = key[:-1]\n    title = key[-1]\n    super_section = get_key_section(key_to_section=key_to_section, key=super_key)\n    new_section = []\n    super_section.append({title: new_section})\n    key_to_section[key] = new_section\n    return new_section\n\n\ndef get_text_with_translate_missing(text: str) -> str:\n    lines = text.splitlines()\n    lines.insert(1, missing_translation_snippet)\n    new_text = \"\\n\".join(lines)\n    return new_text\n\n\ndef get_file_to_nav_map(nav: list) -> Dict[str, Tuple[str, ...]]:\n    file_to_nav = {}\n    for item in nav:\n        if type(item) is str:\n            file_to_nav[item] = tuple()\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sub_file_to_nav = get_file_to_nav_map(sub_nav)\n            for k, v in sub_file_to_nav.items():\n                file_to_nav[k] = (item_key,) + v\n    return file_to_nav\n\n\ndef get_sections(nav: list) -> Dict[Tuple[str, ...], str]:\n    sections = {}\n    for item in nav:\n        if type(item) is str:\n            continue\n        elif type(item) is dict:\n            item_key = list(item.keys())[0]\n            sub_nav = item[item_key]\n            sections[(item_key,)] = sub_nav[0]\n            sub_sections = get_sections(sub_nav)\n            for k, v in sub_sections.items():\n                new_key = (item_key,) + k\n                sections[new_key] = v\n    return sections\n\n\nif __name__ == \"__main__\":\n    app()\n", "diff": "@@ -106,6 +106,9 @@ def new_lang(lang: str = typer.Argument(..., callback=lang_callback)):\n     en_index_content = en_index_path.read_text(encoding=\"utf-8\")\n     new_index_content = f\"{missing_translation_snippet}\\n\\n{en_index_content}\"\n     new_index_path.write_text(new_index_content, encoding=\"utf-8\")\n+    new_overrides_gitignore_path = new_path / \"overrides\" / \".gitignore\"\n+    new_overrides_gitignore_path.parent.mkdir(parents=True, exist_ok=True)\n+    new_overrides_gitignore_path.write_text(\"\")\n     typer.secho(f\"Successfully initialized: {new_path}\", color=typer.colors.GREEN)\n     update_languages(lang=None)\n \n"}
{"commit_hash": "1ce7258a018d0ab190b4b80683f938798aa8577f", "issue_description": "\u270f\ufe0f Fix typo on docstring in datastructures file (#2887)", "code_before": "from typing import Any, Callable, Iterable, Type, TypeVar\n\nfrom starlette.datastructures import State as State  # noqa: F401\nfrom starlette.datastructures import UploadFile as StarletteUploadFile\n\n\nclass UploadFile(StarletteUploadFile):\n    @classmethod\n    def __get_validators__(cls: Type[\"UploadFile\"]) -> Iterable[Callable[..., Any]]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls: Type[\"UploadFile\"], v: Any) -> Any:\n        if not isinstance(v, StarletteUploadFile):\n            raise ValueError(f\"Expected UploadFile, received: {type(v)}\")\n        return v\n\n\nclass DefaultPlaceholder:\n    \"\"\"\n    You shouldn't use this class directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overriden default value was truthy.\n    \"\"\"\n\n    def __init__(self, value: Any):\n        self.value = value\n\n    def __bool__(self) -> bool:\n        return bool(self.value)\n\n    def __eq__(self, o: object) -> bool:\n        return isinstance(o, DefaultPlaceholder) and o.value == self.value\n\n\nDefaultType = TypeVar(\"DefaultType\")\n\n\ndef Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overriden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)  # type: ignore\n", "fix_code": "from typing import Any, Callable, Iterable, Type, TypeVar\n\nfrom starlette.datastructures import State as State  # noqa: F401\nfrom starlette.datastructures import UploadFile as StarletteUploadFile\n\n\nclass UploadFile(StarletteUploadFile):\n    @classmethod\n    def __get_validators__(cls: Type[\"UploadFile\"]) -> Iterable[Callable[..., Any]]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls: Type[\"UploadFile\"], v: Any) -> Any:\n        if not isinstance(v, StarletteUploadFile):\n            raise ValueError(f\"Expected UploadFile, received: {type(v)}\")\n        return v\n\n\nclass DefaultPlaceholder:\n    \"\"\"\n    You shouldn't use this class directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n\n    def __init__(self, value: Any):\n        self.value = value\n\n    def __bool__(self) -> bool:\n        return bool(self.value)\n\n    def __eq__(self, o: object) -> bool:\n        return isinstance(o, DefaultPlaceholder) and o.value == self.value\n\n\nDefaultType = TypeVar(\"DefaultType\")\n\n\ndef Default(value: DefaultType) -> DefaultType:\n    \"\"\"\n    You shouldn't use this function directly.\n\n    It's used internally to recognize when a default value has been overwritten, even\n    if the overridden default value was truthy.\n    \"\"\"\n    return DefaultPlaceholder(value)  # type: ignore\n", "diff": "@@ -21,7 +21,7 @@ class DefaultPlaceholder:\n     You shouldn't use this class directly.\n \n     It's used internally to recognize when a default value has been overwritten, even\n-    if the overriden default value was truthy.\n+    if the overridden default value was truthy.\n     \"\"\"\n \n     def __init__(self, value: Any):\n@@ -42,6 +42,6 @@ def Default(value: DefaultType) -> DefaultType:\n     You shouldn't use this function directly.\n \n     It's used internally to recognize when a default value has been overwritten, even\n-    if the overriden default value was truthy.\n+    if the overridden default value was truthy.\n     \"\"\"\n     return DefaultPlaceholder(value)  # type: ignore\n"}
{"commit_hash": "b0cd4d7e7ebdbab130d663d73d5474361116ce63", "issue_description": "\ud83d\udc1b Fix JSON Schema for dataclasses, supporting the fixes in Pydantic 1.9 (#4272)\n\nCo-authored-by: Sebasti\u00e1n Ram\u00edrez <tiangolo@gmail.com>", "code_before": "from fastapi.testclient import TestClient\n\nfrom docs_src.dataclasses.tutorial002 import app\n\nclient = TestClient(app)\n\nopenapi_schema = {\n    \"openapi\": \"3.0.2\",\n    \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n    \"paths\": {\n        \"/items/next\": {\n            \"get\": {\n                \"summary\": \"Read Next Item\",\n                \"operationId\": \"read_next_item_items_next_get\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                            }\n                        },\n                    }\n                },\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Item\": {\n                \"title\": \"Item\",\n                \"required\": [\"name\", \"price\", \"tags\"],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n                    \"price\": {\"title\": \"Price\", \"type\": \"number\"},\n                    \"tags\": {\n                        \"title\": \"Tags\",\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\"},\n                    },\n                    \"description\": {\"title\": \"Description\", \"type\": \"string\"},\n                    \"tax\": {\"title\": \"Tax\", \"type\": \"number\"},\n                },\n            }\n        }\n    },\n}\n\n\ndef test_openapi_schema():\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200\n    assert response.json() == openapi_schema\n\n\ndef test_get_item():\n    response = client.get(\"/items/next\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"name\": \"Island In The Moon\",\n        \"price\": 12.99,\n        \"description\": \"A place to be be playin' and havin' fun\",\n        \"tags\": [\"breater\"],\n        \"tax\": None,\n    }\n", "fix_code": "from copy import deepcopy\n\nfrom fastapi.testclient import TestClient\n\nfrom docs_src.dataclasses.tutorial002 import app\n\nclient = TestClient(app)\n\nopenapi_schema = {\n    \"openapi\": \"3.0.2\",\n    \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n    \"paths\": {\n        \"/items/next\": {\n            \"get\": {\n                \"summary\": \"Read Next Item\",\n                \"operationId\": \"read_next_item_items_next_get\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                            }\n                        },\n                    }\n                },\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"Item\": {\n                \"title\": \"Item\",\n                \"required\": [\"name\", \"price\"],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n                    \"price\": {\"title\": \"Price\", \"type\": \"number\"},\n                    \"tags\": {\n                        \"title\": \"Tags\",\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\"},\n                    },\n                    \"description\": {\"title\": \"Description\", \"type\": \"string\"},\n                    \"tax\": {\"title\": \"Tax\", \"type\": \"number\"},\n                },\n            }\n        }\n    },\n}\n\n\ndef test_openapi_schema():\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200\n    # TODO: remove this once Pydantic 1.9 is released\n    # Ref: https://github.com/samuelcolvin/pydantic/pull/2557\n    data = response.json()\n    alternative_data1 = deepcopy(data)\n    alternative_data2 = deepcopy(data)\n    alternative_data1[\"components\"][\"schemas\"][\"Item\"][\"required\"] = [\"name\", \"price\"]\n    alternative_data2[\"components\"][\"schemas\"][\"Item\"][\"required\"] = [\n        \"name\",\n        \"price\",\n        \"tags\",\n    ]\n    assert alternative_data1 == openapi_schema or alternative_data2 == openapi_schema\n\n\ndef test_get_item():\n    response = client.get(\"/items/next\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"name\": \"Island In The Moon\",\n        \"price\": 12.99,\n        \"description\": \"A place to be be playin' and havin' fun\",\n        \"tags\": [\"breater\"],\n        \"tax\": None,\n    }\n", "diff": "@@ -1,3 +1,5 @@\n+from copy import deepcopy\n+\n from fastapi.testclient import TestClient\n \n from docs_src.dataclasses.tutorial002 import app\n@@ -29,7 +31,7 @@ openapi_schema = {\n         \"schemas\": {\n             \"Item\": {\n                 \"title\": \"Item\",\n-                \"required\": [\"name\", \"price\", \"tags\"],\n+                \"required\": [\"name\", \"price\"],\n                 \"type\": \"object\",\n                 \"properties\": {\n                     \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n@@ -51,7 +53,18 @@ openapi_schema = {\n def test_openapi_schema():\n     response = client.get(\"/openapi.json\")\n     assert response.status_code == 200\n-    assert response.json() == openapi_schema\n+    # TODO: remove this once Pydantic 1.9 is released\n+    # Ref: https://github.com/samuelcolvin/pydantic/pull/2557\n+    data = response.json()\n+    alternative_data1 = deepcopy(data)\n+    alternative_data2 = deepcopy(data)\n+    alternative_data1[\"components\"][\"schemas\"][\"Item\"][\"required\"] = [\"name\", \"price\"]\n+    alternative_data2[\"components\"][\"schemas\"][\"Item\"][\"required\"] = [\n+        \"name\",\n+        \"price\",\n+        \"tags\",\n+    ]\n+    assert alternative_data1 == openapi_schema or alternative_data2 == openapi_schema\n \n \n def test_get_item():\n"}
{"commit_hash": "d3eb78709030650f24f5e31730f47591d6cef4cb", "issue_description": "\ud83d\udc1b Fix FastAPI People generation to include missing file in commit (#4695)", "code_before": "import logging\nimport subprocess\nimport sys\nfrom collections import Counter, defaultdict\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Container, DefaultDict, Dict, List, Optional, Set\n\nimport httpx\nimport yaml\nfrom github import Github\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_graphql_url = \"https://api.github.com/graphql\"\n\nissues_query = \"\"\"\nquery Q($after: String) { \n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    issues(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nprs_query = \"\"\"\nquery Q($after: String) { \n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    pullRequests(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          labels(first: 100) {\n            nodes {\n              name\n            }\n          }\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n          reviews(first:100) {\n            nodes {\n              author {\n                login\n                avatarUrl\n                url\n              }\n              state\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nsponsors_query = \"\"\"\nquery Q($after: String) {\n  user(login: \"tiangolo\") {\n    sponsorshipsAsMaintainer(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          sponsorEntity {\n            ... on Organization {\n              login\n              avatarUrl\n              url\n            }\n            ... on User {\n              login\n              avatarUrl\n              url\n            }\n          }\n          tier {\n            name\n            monthlyPriceInDollars\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\n\nclass Author(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass CommentsNode(BaseModel):\n    createdAt: datetime\n    author: Optional[Author] = None\n\n\nclass Comments(BaseModel):\n    nodes: List[CommentsNode]\n\n\nclass IssuesNode(BaseModel):\n    number: int\n    author: Optional[Author] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n\n\nclass IssuesEdge(BaseModel):\n    cursor: str\n    node: IssuesNode\n\n\nclass Issues(BaseModel):\n    edges: List[IssuesEdge]\n\n\nclass IssuesRepository(BaseModel):\n    issues: Issues\n\n\nclass IssuesResponseData(BaseModel):\n    repository: IssuesRepository\n\n\nclass IssuesResponse(BaseModel):\n    data: IssuesResponseData\n\n\nclass LabelNode(BaseModel):\n    name: str\n\n\nclass Labels(BaseModel):\n    nodes: List[LabelNode]\n\n\nclass ReviewNode(BaseModel):\n    author: Optional[Author] = None\n    state: str\n\n\nclass Reviews(BaseModel):\n    nodes: List[ReviewNode]\n\n\nclass PullRequestNode(BaseModel):\n    number: int\n    labels: Labels\n    author: Optional[Author] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n    reviews: Reviews\n\n\nclass PullRequestEdge(BaseModel):\n    cursor: str\n    node: PullRequestNode\n\n\nclass PullRequests(BaseModel):\n    edges: List[PullRequestEdge]\n\n\nclass PRsRepository(BaseModel):\n    pullRequests: PullRequests\n\n\nclass PRsResponseData(BaseModel):\n    repository: PRsRepository\n\n\nclass PRsResponse(BaseModel):\n    data: PRsResponseData\n\n\nclass SponsorEntity(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass Tier(BaseModel):\n    name: str\n    monthlyPriceInDollars: float\n\n\nclass SponsorshipAsMaintainerNode(BaseModel):\n    sponsorEntity: SponsorEntity\n    tier: Tier\n\n\nclass SponsorshipAsMaintainerEdge(BaseModel):\n    cursor: str\n    node: SponsorshipAsMaintainerNode\n\n\nclass SponsorshipAsMaintainer(BaseModel):\n    edges: List[SponsorshipAsMaintainerEdge]\n\n\nclass SponsorsUser(BaseModel):\n    sponsorshipsAsMaintainer: SponsorshipAsMaintainer\n\n\nclass SponsorsResponseData(BaseModel):\n    user: SponsorsUser\n\n\nclass SponsorsResponse(BaseModel):\n    data: SponsorsResponseData\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    input_standard_token: SecretStr\n    github_repository: str\n\n\ndef get_graphql_response(\n    *, settings: Settings, query: str, after: Optional[str] = None\n):\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = httpx.post(\n        github_graphql_url,\n        headers=headers,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if not response.status_code == 200:\n        logging.error(f\"Response was not 200, after: {after}\")\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    return data\n\n\ndef get_graphql_issue_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.parse_obj(data)\n    return graphql_response.data.repository.issues.edges\n\n\ndef get_graphql_pr_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.parse_obj(data)\n    return graphql_response.data.repository.pullRequests.edges\n\n\ndef get_graphql_sponsor_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n    graphql_response = SponsorsResponse.parse_obj(data)\n    return graphql_response.data.user.sponsorshipsAsMaintainer.edges\n\n\ndef get_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == issue_author_name:\n                    continue\n                issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors\n\n\ndef get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors\n\n\ndef get_individual_sponsors(settings: Settings):\n    nodes: List[SponsorshipAsMaintainerNode] = []\n    edges = get_graphql_sponsor_edges(settings=settings)\n\n    while edges:\n        for edge in edges:\n            nodes.append(edge.node)\n        last_edge = edges[-1]\n        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n\n    tiers: DefaultDict[float, Dict[str, SponsorEntity]] = defaultdict(dict)\n    for node in nodes:\n        tiers[node.tier.monthlyPriceInDollars][\n            node.sponsorEntity.login\n        ] = node.sponsorEntity\n    return tiers\n\n\ndef get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_standard_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    issue_commentors, issue_last_month_commentors, issue_authors = get_experts(\n        settings=settings\n    )\n    contributors, pr_commentors, reviewers, pr_authors = get_contributors(\n        settings=settings\n    )\n    authors = {**issue_authors, **pr_authors}\n    maintainers_logins = {\"tiangolo\"}\n    bot_names = {\"codecov\", \"github-actions\"}\n    maintainers = []\n    for login in maintainers_logins:\n        user = authors[login]\n        maintainers.append(\n            {\n                \"login\": login,\n                \"answers\": issue_commentors[login],\n                \"prs\": contributors[login],\n                \"avatarUrl\": user.avatarUrl,\n                \"url\": user.url,\n            }\n        )\n\n    min_count_expert = 10\n    min_count_last_month = 3\n    min_count_contributor = 4\n    min_count_reviewer = 4\n    skip_users = maintainers_logins | bot_names\n    experts = get_top_users(\n        counter=issue_commentors,\n        min_count=min_count_expert,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    last_month_active = get_top_users(\n        counter=issue_last_month_commentors,\n        min_count=min_count_last_month,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_contributors = get_top_users(\n        counter=contributors,\n        min_count=min_count_contributor,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_reviewers = get_top_users(\n        counter=reviewers,\n        min_count=min_count_reviewer,\n        authors=authors,\n        skip_users=skip_users,\n    )\n\n    tiers = get_individual_sponsors(settings=settings)\n    keys = list(tiers.keys())\n    keys.sort(reverse=True)\n    sponsors = []\n    for key in keys:\n        sponsor_group = []\n        for login, sponsor in tiers[key].items():\n            sponsor_group.append(\n                {\"login\": login, \"avatarUrl\": sponsor.avatarUrl, \"url\": sponsor.url}\n            )\n        sponsors.append(sponsor_group)\n\n    people = {\n        \"maintainers\": maintainers,\n        \"experts\": experts,\n        \"last_month_active\": last_month_active,\n        \"top_contributors\": top_contributors,\n        \"top_reviewers\": top_reviewers,\n    }\n    github_sponsors = {\n        \"sponsors\": sponsors,\n    }\n    people_path = Path(\"./docs/en/data/people.yml\")\n    github_sponsors_path = Path(\"./docs/en/data/github_sponsors.yml\")\n    people_old_content = people_path.read_text(encoding=\"utf-8\")\n    github_sponsors_old_content = github_sponsors_path.read_text(encoding=\"utf-8\")\n    new_people_content = yaml.dump(people, sort_keys=False, width=200, allow_unicode=True)\n    new_github_sponsors_content = yaml.dump(github_sponsors, sort_keys=False, width=200, allow_unicode=True)\n    if people_old_content == new_people_content and github_sponsors_old_content == new_github_sponsors_content:\n        logging.info(\"The FastAPI People data hasn't changed, finishing.\")\n        sys.exit(0)\n    people_path.write_text(new_people_content, encoding=\"utf-8\")\n    github_sponsors_path.write_text(new_github_sponsors_content, encoding=\"utf-8\")\n    logging.info(\"Setting up GitHub Actions git user\")\n    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n    subprocess.run(\n        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n    )\n    branch_name = \"fastapi-people\"\n    logging.info(f\"Creating a new branch {branch_name}\")\n    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n    logging.info(\"Adding updated file\")\n    subprocess.run([\"git\", \"add\", str(people_path)], check=True)\n    logging.info(\"Committing updated file\")\n    message = \"\ud83d\udc65 Update FastAPI People\"\n    result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n    logging.info(\"Pushing branch\")\n    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n    logging.info(\"Creating PR\")\n    pr = repo.create_pull(title=message, body=message, base=\"master\", head=branch_name)\n    logging.info(f\"Created PR: {pr.number}\")\n    logging.info(\"Finished\")\n", "fix_code": "import logging\nimport subprocess\nimport sys\nfrom collections import Counter, defaultdict\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Container, DefaultDict, Dict, List, Optional, Set\n\nimport httpx\nimport yaml\nfrom github import Github\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_graphql_url = \"https://api.github.com/graphql\"\n\nissues_query = \"\"\"\nquery Q($after: String) { \n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    issues(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nprs_query = \"\"\"\nquery Q($after: String) { \n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    pullRequests(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          labels(first: 100) {\n            nodes {\n              name\n            }\n          }\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n          reviews(first:100) {\n            nodes {\n              author {\n                login\n                avatarUrl\n                url\n              }\n              state\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nsponsors_query = \"\"\"\nquery Q($after: String) {\n  user(login: \"tiangolo\") {\n    sponsorshipsAsMaintainer(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          sponsorEntity {\n            ... on Organization {\n              login\n              avatarUrl\n              url\n            }\n            ... on User {\n              login\n              avatarUrl\n              url\n            }\n          }\n          tier {\n            name\n            monthlyPriceInDollars\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\n\nclass Author(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass CommentsNode(BaseModel):\n    createdAt: datetime\n    author: Optional[Author] = None\n\n\nclass Comments(BaseModel):\n    nodes: List[CommentsNode]\n\n\nclass IssuesNode(BaseModel):\n    number: int\n    author: Optional[Author] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n\n\nclass IssuesEdge(BaseModel):\n    cursor: str\n    node: IssuesNode\n\n\nclass Issues(BaseModel):\n    edges: List[IssuesEdge]\n\n\nclass IssuesRepository(BaseModel):\n    issues: Issues\n\n\nclass IssuesResponseData(BaseModel):\n    repository: IssuesRepository\n\n\nclass IssuesResponse(BaseModel):\n    data: IssuesResponseData\n\n\nclass LabelNode(BaseModel):\n    name: str\n\n\nclass Labels(BaseModel):\n    nodes: List[LabelNode]\n\n\nclass ReviewNode(BaseModel):\n    author: Optional[Author] = None\n    state: str\n\n\nclass Reviews(BaseModel):\n    nodes: List[ReviewNode]\n\n\nclass PullRequestNode(BaseModel):\n    number: int\n    labels: Labels\n    author: Optional[Author] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n    reviews: Reviews\n\n\nclass PullRequestEdge(BaseModel):\n    cursor: str\n    node: PullRequestNode\n\n\nclass PullRequests(BaseModel):\n    edges: List[PullRequestEdge]\n\n\nclass PRsRepository(BaseModel):\n    pullRequests: PullRequests\n\n\nclass PRsResponseData(BaseModel):\n    repository: PRsRepository\n\n\nclass PRsResponse(BaseModel):\n    data: PRsResponseData\n\n\nclass SponsorEntity(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass Tier(BaseModel):\n    name: str\n    monthlyPriceInDollars: float\n\n\nclass SponsorshipAsMaintainerNode(BaseModel):\n    sponsorEntity: SponsorEntity\n    tier: Tier\n\n\nclass SponsorshipAsMaintainerEdge(BaseModel):\n    cursor: str\n    node: SponsorshipAsMaintainerNode\n\n\nclass SponsorshipAsMaintainer(BaseModel):\n    edges: List[SponsorshipAsMaintainerEdge]\n\n\nclass SponsorsUser(BaseModel):\n    sponsorshipsAsMaintainer: SponsorshipAsMaintainer\n\n\nclass SponsorsResponseData(BaseModel):\n    user: SponsorsUser\n\n\nclass SponsorsResponse(BaseModel):\n    data: SponsorsResponseData\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    input_standard_token: SecretStr\n    github_repository: str\n\n\ndef get_graphql_response(\n    *, settings: Settings, query: str, after: Optional[str] = None\n):\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = httpx.post(\n        github_graphql_url,\n        headers=headers,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if not response.status_code == 200:\n        logging.error(f\"Response was not 200, after: {after}\")\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    return data\n\n\ndef get_graphql_issue_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.parse_obj(data)\n    return graphql_response.data.repository.issues.edges\n\n\ndef get_graphql_pr_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.parse_obj(data)\n    return graphql_response.data.repository.pullRequests.edges\n\n\ndef get_graphql_sponsor_edges(*, settings: Settings, after: Optional[str] = None):\n    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n    graphql_response = SponsorsResponse.parse_obj(data)\n    return graphql_response.data.user.sponsorshipsAsMaintainer.edges\n\n\ndef get_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == issue_author_name:\n                    continue\n                issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors\n\n\ndef get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors\n\n\ndef get_individual_sponsors(settings: Settings):\n    nodes: List[SponsorshipAsMaintainerNode] = []\n    edges = get_graphql_sponsor_edges(settings=settings)\n\n    while edges:\n        for edge in edges:\n            nodes.append(edge.node)\n        last_edge = edges[-1]\n        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n\n    tiers: DefaultDict[float, Dict[str, SponsorEntity]] = defaultdict(dict)\n    for node in nodes:\n        tiers[node.tier.monthlyPriceInDollars][\n            node.sponsorEntity.login\n        ] = node.sponsorEntity\n    return tiers\n\n\ndef get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_standard_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    issue_commentors, issue_last_month_commentors, issue_authors = get_experts(\n        settings=settings\n    )\n    contributors, pr_commentors, reviewers, pr_authors = get_contributors(\n        settings=settings\n    )\n    authors = {**issue_authors, **pr_authors}\n    maintainers_logins = {\"tiangolo\"}\n    bot_names = {\"codecov\", \"github-actions\"}\n    maintainers = []\n    for login in maintainers_logins:\n        user = authors[login]\n        maintainers.append(\n            {\n                \"login\": login,\n                \"answers\": issue_commentors[login],\n                \"prs\": contributors[login],\n                \"avatarUrl\": user.avatarUrl,\n                \"url\": user.url,\n            }\n        )\n\n    min_count_expert = 10\n    min_count_last_month = 3\n    min_count_contributor = 4\n    min_count_reviewer = 4\n    skip_users = maintainers_logins | bot_names\n    experts = get_top_users(\n        counter=issue_commentors,\n        min_count=min_count_expert,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    last_month_active = get_top_users(\n        counter=issue_last_month_commentors,\n        min_count=min_count_last_month,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_contributors = get_top_users(\n        counter=contributors,\n        min_count=min_count_contributor,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_reviewers = get_top_users(\n        counter=reviewers,\n        min_count=min_count_reviewer,\n        authors=authors,\n        skip_users=skip_users,\n    )\n\n    tiers = get_individual_sponsors(settings=settings)\n    keys = list(tiers.keys())\n    keys.sort(reverse=True)\n    sponsors = []\n    for key in keys:\n        sponsor_group = []\n        for login, sponsor in tiers[key].items():\n            sponsor_group.append(\n                {\"login\": login, \"avatarUrl\": sponsor.avatarUrl, \"url\": sponsor.url}\n            )\n        sponsors.append(sponsor_group)\n\n    people = {\n        \"maintainers\": maintainers,\n        \"experts\": experts,\n        \"last_month_active\": last_month_active,\n        \"top_contributors\": top_contributors,\n        \"top_reviewers\": top_reviewers,\n    }\n    github_sponsors = {\n        \"sponsors\": sponsors,\n    }\n    people_path = Path(\"./docs/en/data/people.yml\")\n    github_sponsors_path = Path(\"./docs/en/data/github_sponsors.yml\")\n    people_old_content = people_path.read_text(encoding=\"utf-8\")\n    github_sponsors_old_content = github_sponsors_path.read_text(encoding=\"utf-8\")\n    new_people_content = yaml.dump(\n        people, sort_keys=False, width=200, allow_unicode=True\n    )\n    new_github_sponsors_content = yaml.dump(\n        github_sponsors, sort_keys=False, width=200, allow_unicode=True\n    )\n    if (\n        people_old_content == new_people_content\n        and github_sponsors_old_content == new_github_sponsors_content\n    ):\n        logging.info(\"The FastAPI People data hasn't changed, finishing.\")\n        sys.exit(0)\n    people_path.write_text(new_people_content, encoding=\"utf-8\")\n    github_sponsors_path.write_text(new_github_sponsors_content, encoding=\"utf-8\")\n    logging.info(\"Setting up GitHub Actions git user\")\n    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n    subprocess.run(\n        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n    )\n    branch_name = \"fastapi-people\"\n    logging.info(f\"Creating a new branch {branch_name}\")\n    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n    logging.info(\"Adding updated file\")\n    subprocess.run(\n        [\"git\", \"add\", str(people_path), str(github_sponsors_path)], check=True\n    )\n    logging.info(\"Committing updated file\")\n    message = \"\ud83d\udc65 Update FastAPI People\"\n    result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n    logging.info(\"Pushing branch\")\n    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n    logging.info(\"Creating PR\")\n    pr = repo.create_pull(title=message, body=message, base=\"master\", head=branch_name)\n    logging.info(f\"Created PR: {pr.number}\")\n    logging.info(\"Finished\")\n", "diff": "@@ -501,9 +501,16 @@ if __name__ == \"__main__\":\n     github_sponsors_path = Path(\"./docs/en/data/github_sponsors.yml\")\n     people_old_content = people_path.read_text(encoding=\"utf-8\")\n     github_sponsors_old_content = github_sponsors_path.read_text(encoding=\"utf-8\")\n-    new_people_content = yaml.dump(people, sort_keys=False, width=200, allow_unicode=True)\n-    new_github_sponsors_content = yaml.dump(github_sponsors, sort_keys=False, width=200, allow_unicode=True)\n-    if people_old_content == new_people_content and github_sponsors_old_content == new_github_sponsors_content:\n+    new_people_content = yaml.dump(\n+        people, sort_keys=False, width=200, allow_unicode=True\n+    )\n+    new_github_sponsors_content = yaml.dump(\n+        github_sponsors, sort_keys=False, width=200, allow_unicode=True\n+    )\n+    if (\n+        people_old_content == new_people_content\n+        and github_sponsors_old_content == new_github_sponsors_content\n+    ):\n         logging.info(\"The FastAPI People data hasn't changed, finishing.\")\n         sys.exit(0)\n     people_path.write_text(new_people_content, encoding=\"utf-8\")\n@@ -517,7 +524,9 @@ if __name__ == \"__main__\":\n     logging.info(f\"Creating a new branch {branch_name}\")\n     subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n     logging.info(\"Adding updated file\")\n-    subprocess.run([\"git\", \"add\", str(people_path)], check=True)\n+    subprocess.run(\n+        [\"git\", \"add\", str(people_path), str(github_sponsors_path)], check=True\n+    )\n     logging.info(\"Committing updated file\")\n     message = \"\ud83d\udc65 Update FastAPI People\"\n     result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n"}
{"commit_hash": "8b66b9ca3ef8b1cdb0ca2089781a04fe0e021c65", "issue_description": "\ud83c\udfa8 Fix default value as set in tutorial for Path Operations Advanced Configurations (#4899)", "code_before": "from typing import Optional, Set\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n    tags: Set[str] = []\n\n\n@app.post(\"/items/\", response_model=Item, summary=\"Create an item\")\nasync def create_item(item: Item):\n    \"\"\"\n    Create an item with all the information:\n\n    - **name**: each item must have a name\n    - **description**: a long description\n    - **price**: required\n    - **tax**: if the item doesn't have tax, you can omit this\n    - **tags**: a set of unique tag strings for this item\n    \\f\n    :param item: User input.\n    \"\"\"\n    return item\n", "fix_code": "from typing import Optional, Set\n\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n    tags: Set[str] = set()\n\n\n@app.post(\"/items/\", response_model=Item, summary=\"Create an item\")\nasync def create_item(item: Item):\n    \"\"\"\n    Create an item with all the information:\n\n    - **name**: each item must have a name\n    - **description**: a long description\n    - **price**: required\n    - **tax**: if the item doesn't have tax, you can omit this\n    - **tags**: a set of unique tag strings for this item\n    \\f\n    :param item: User input.\n    \"\"\"\n    return item\n", "diff": "@@ -11,7 +11,7 @@ class Item(BaseModel):\n     description: Optional[str] = None\n     price: float\n     tax: Optional[float] = None\n-    tags: Set[str] = []\n+    tags: Set[str] = set()\n \n \n @app.post(\"/items/\", response_model=Item, summary=\"Create an item\")\n"}
{"commit_hash": "ec072d75fe0aae16caec3a8aa3f57ca8d6f05de5", "issue_description": "\u2b06 Upgrade Swagger UI copy of `oauth2-redirect.html` to include fixes for flavors of authorization code flows in Swagger UI (#3439)\n\nCo-authored-by: Sebasti\u00e1n Ram\u00edrez <tiangolo@gmail.com>", "code_before": "import json\nfrom typing import Any, Dict, Optional\n\nfrom fastapi.encoders import jsonable_encoder\nfrom starlette.responses import HTMLResponse\n\nswagger_ui_default_parameters = {\n    \"dom_id\": \"#swagger-ui\",\n    \"layout\": \"BaseLayout\",\n    \"deepLinking\": True,\n    \"showExtensions\": True,\n    \"showCommonExtensions\": True,\n}\n\n\ndef get_swagger_ui_html(\n    *,\n    openapi_url: str,\n    title: str,\n    swagger_js_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@4/swagger-ui-bundle.js\",\n    swagger_css_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@4/swagger-ui.css\",\n    swagger_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Optional[str] = None,\n    init_oauth: Optional[Dict[str, Any]] = None,\n    swagger_ui_parameters: Optional[Dict[str, Any]] = None,\n) -> HTMLResponse:\n    current_swagger_ui_parameters = swagger_ui_default_parameters.copy()\n    if swagger_ui_parameters:\n        current_swagger_ui_parameters.update(swagger_ui_parameters)\n\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    for key, value in current_swagger_ui_parameters.items():\n        html += f\"{json.dumps(key)}: {json.dumps(jsonable_encoder(value))},\\n\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n    presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n    })\"\"\"\n\n    if init_oauth:\n        html += f\"\"\"\n        ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})\n        \"\"\"\n\n    html += \"\"\"\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_redoc_html(\n    *,\n    openapi_url: str,\n    title: str,\n    redoc_js_url: str = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    with_google_fonts: bool = True,\n) -> HTMLResponse:\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    \"\"\"\n    if with_google_fonts:\n        html += \"\"\"\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    \"\"\"\n    html += f\"\"\"\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    html = \"\"\"\n    <!DOCTYPE html>\n    <html lang=\"en-US\">\n    <body onload=\"run()\">\n    </body>\n    </html>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1);\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\")\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';})\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value)\n                    }\n            ) : {}\n\n            isValid = qp.state === sentState\n\n            if ((\n            oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n            oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n    </script>\n        \"\"\"\n    return HTMLResponse(content=html)\n", "fix_code": "import json\nfrom typing import Any, Dict, Optional\n\nfrom fastapi.encoders import jsonable_encoder\nfrom starlette.responses import HTMLResponse\n\nswagger_ui_default_parameters = {\n    \"dom_id\": \"#swagger-ui\",\n    \"layout\": \"BaseLayout\",\n    \"deepLinking\": True,\n    \"showExtensions\": True,\n    \"showCommonExtensions\": True,\n}\n\n\ndef get_swagger_ui_html(\n    *,\n    openapi_url: str,\n    title: str,\n    swagger_js_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@4/swagger-ui-bundle.js\",\n    swagger_css_url: str = \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@4/swagger-ui.css\",\n    swagger_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    oauth2_redirect_url: Optional[str] = None,\n    init_oauth: Optional[Dict[str, Any]] = None,\n    swagger_ui_parameters: Optional[Dict[str, Any]] = None,\n) -> HTMLResponse:\n    current_swagger_ui_parameters = swagger_ui_default_parameters.copy()\n    if swagger_ui_parameters:\n        current_swagger_ui_parameters.update(swagger_ui_parameters)\n\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <link type=\"text/css\" rel=\"stylesheet\" href=\"{swagger_css_url}\">\n    <link rel=\"shortcut icon\" href=\"{swagger_favicon_url}\">\n    <title>{title}</title>\n    </head>\n    <body>\n    <div id=\"swagger-ui\">\n    </div>\n    <script src=\"{swagger_js_url}\"></script>\n    <!-- `SwaggerUIBundle` is now available on the page -->\n    <script>\n    const ui = SwaggerUIBundle({{\n        url: '{openapi_url}',\n    \"\"\"\n\n    for key, value in current_swagger_ui_parameters.items():\n        html += f\"{json.dumps(key)}: {json.dumps(jsonable_encoder(value))},\\n\"\n\n    if oauth2_redirect_url:\n        html += f\"oauth2RedirectUrl: window.location.origin + '{oauth2_redirect_url}',\"\n\n    html += \"\"\"\n    presets: [\n        SwaggerUIBundle.presets.apis,\n        SwaggerUIBundle.SwaggerUIStandalonePreset\n        ],\n    })\"\"\"\n\n    if init_oauth:\n        html += f\"\"\"\n        ui.initOAuth({json.dumps(jsonable_encoder(init_oauth))})\n        \"\"\"\n\n    html += \"\"\"\n    </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_redoc_html(\n    *,\n    openapi_url: str,\n    title: str,\n    redoc_js_url: str = \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\",\n    redoc_favicon_url: str = \"https://fastapi.tiangolo.com/img/favicon.png\",\n    with_google_fonts: bool = True,\n) -> HTMLResponse:\n    html = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n    <title>{title}</title>\n    <!-- needed for adaptive design -->\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    \"\"\"\n    if with_google_fonts:\n        html += \"\"\"\n    <link href=\"https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700\" rel=\"stylesheet\">\n    \"\"\"\n    html += f\"\"\"\n    <link rel=\"shortcut icon\" href=\"{redoc_favicon_url}\">\n    <!--\n    ReDoc doesn't change outer page styles\n    -->\n    <style>\n      body {{\n        margin: 0;\n        padding: 0;\n      }}\n    </style>\n    </head>\n    <body>\n    <redoc spec-url=\"{openapi_url}\"></redoc>\n    <script src=\"{redoc_js_url}\"> </script>\n    </body>\n    </html>\n    \"\"\"\n    return HTMLResponse(html)\n\n\ndef get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n    # copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html\n    html = \"\"\"\n    <!doctype html>\n    <html lang=\"en-US\">\n    <head>\n        <title>Swagger UI: OAuth2 Redirect</title>\n    </head>\n    <body>\n    <script>\n        'use strict';\n        function run () {\n            var oauth2 = window.opener.swaggerUIRedirectOauth2;\n            var sentState = oauth2.state;\n            var redirectUrl = oauth2.redirectUrl;\n            var isValid, qp, arr;\n\n            if (/code|token|error/.test(window.location.hash)) {\n                qp = window.location.hash.substring(1).replace('?', '&');\n            } else {\n                qp = location.search.substring(1);\n            }\n\n            arr = qp.split(\"&\");\n            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';});\n            qp = qp ? JSON.parse('{' + arr.join() + '}',\n                    function (key, value) {\n                        return key === \"\" ? value : decodeURIComponent(value);\n                    }\n            ) : {};\n\n            isValid = qp.state === sentState;\n\n            if ((\n              oauth2.auth.schema.get(\"flow\") === \"accessCode\" ||\n              oauth2.auth.schema.get(\"flow\") === \"authorizationCode\" ||\n              oauth2.auth.schema.get(\"flow\") === \"authorization_code\"\n            ) && !oauth2.auth.code) {\n                if (!isValid) {\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"warning\",\n                        message: \"Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server.\"\n                    });\n                }\n\n                if (qp.code) {\n                    delete oauth2.state;\n                    oauth2.auth.code = qp.code;\n                    oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                } else {\n                    let oauthErrorMsg;\n                    if (qp.error) {\n                        oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                            (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n                            (qp.error_uri ? \"More info: \"+qp.error_uri : \"\");\n                    }\n\n                    oauth2.errCb({\n                        authId: oauth2.auth.name,\n                        source: \"auth\",\n                        level: \"error\",\n                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server.\"\n                    });\n                }\n            } else {\n                oauth2.callback({auth: oauth2.auth, token: qp, isValid: isValid, redirectUrl: redirectUrl});\n            }\n            window.close();\n        }\n\n        if (document.readyState !== 'loading') {\n            run();\n        } else {\n            document.addEventListener('DOMContentLoaded', function () {\n                run();\n            });\n        }\n    </script>\n    </body>\n    </html>\n        \"\"\"\n    return HTMLResponse(content=html)\n", "diff": "@@ -115,12 +115,14 @@ def get_redoc_html(\n \n \n def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n+    # copied from https://github.com/swagger-api/swagger-ui/blob/v4.14.0/dist/oauth2-redirect.html\n     html = \"\"\"\n-    <!DOCTYPE html>\n+    <!doctype html>\n     <html lang=\"en-US\">\n-    <body onload=\"run()\">\n-    </body>\n-    </html>\n+    <head>\n+        <title>Swagger UI: OAuth2 Redirect</title>\n+    </head>\n+    <body>\n     <script>\n         'use strict';\n         function run () {\n@@ -130,31 +132,32 @@ def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n             var isValid, qp, arr;\n \n             if (/code|token|error/.test(window.location.hash)) {\n-                qp = window.location.hash.substring(1);\n+                qp = window.location.hash.substring(1).replace('?', '&');\n             } else {\n                 qp = location.search.substring(1);\n             }\n \n-            arr = qp.split(\"&\")\n-            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';})\n+            arr = qp.split(\"&\");\n+            arr.forEach(function (v,i,_arr) { _arr[i] = '\"' + v.replace('=', '\":\"') + '\"';});\n             qp = qp ? JSON.parse('{' + arr.join() + '}',\n                     function (key, value) {\n-                        return key === \"\" ? value : decodeURIComponent(value)\n+                        return key === \"\" ? value : decodeURIComponent(value);\n                     }\n-            ) : {}\n+            ) : {};\n \n-            isValid = qp.state === sentState\n+            isValid = qp.state === sentState;\n \n             if ((\n-            oauth2.auth.schema.get(\"flow\") === \"accessCode\"||\n-            oauth2.auth.schema.get(\"flow\") === \"authorizationCode\"\n+              oauth2.auth.schema.get(\"flow\") === \"accessCode\" ||\n+              oauth2.auth.schema.get(\"flow\") === \"authorizationCode\" ||\n+              oauth2.auth.schema.get(\"flow\") === \"authorization_code\"\n             ) && !oauth2.auth.code) {\n                 if (!isValid) {\n                     oauth2.errCb({\n                         authId: oauth2.auth.name,\n                         source: \"auth\",\n                         level: \"warning\",\n-                        message: \"Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server\"\n+                        message: \"Authorization may be unsafe, passed state was changed in server. The passed state wasn't returned from auth server.\"\n                     });\n                 }\n \n@@ -163,7 +166,7 @@ def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n                     oauth2.auth.code = qp.code;\n                     oauth2.callback({auth: oauth2.auth, redirectUrl: redirectUrl});\n                 } else {\n-                    let oauthErrorMsg\n+                    let oauthErrorMsg;\n                     if (qp.error) {\n                         oauthErrorMsg = \"[\"+qp.error+\"]: \" +\n                             (qp.error_description ? qp.error_description+ \". \" : \"no accessCode received from the server. \") +\n@@ -174,7 +177,7 @@ def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n                         authId: oauth2.auth.name,\n                         source: \"auth\",\n                         level: \"error\",\n-                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server\"\n+                        message: oauthErrorMsg || \"[Authorization failed]: no accessCode received from the server.\"\n                     });\n                 }\n             } else {\n@@ -182,6 +185,16 @@ def get_swagger_ui_oauth2_redirect_html() -> HTMLResponse:\n             }\n             window.close();\n         }\n+\n+        if (document.readyState !== 'loading') {\n+            run();\n+        } else {\n+            document.addEventListener('DOMContentLoaded', function () {\n+                run();\n+            });\n+        }\n     </script>\n+    </body>\n+    </html>\n         \"\"\"\n     return HTMLResponse(content=html)\n"}
{"commit_hash": "0539dd9cd35b7eb3b19945c19c1dc569440c0ec1", "issue_description": "\ud83d\udd27 Fix Type hint of `auto_error` which does not need to be `Optional[bool]` (#4933)", "code_before": "from typing import Any, Dict, List, Optional, Union\n\nfrom fastapi.exceptions import HTTPException\nfrom fastapi.openapi.models import OAuth2 as OAuth2Model\nfrom fastapi.openapi.models import OAuthFlows as OAuthFlowsModel\nfrom fastapi.param_functions import Form\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom starlette.requests import Request\nfrom starlette.status import HTTP_401_UNAUTHORIZED, HTTP_403_FORBIDDEN\n\n\nclass OAuth2PasswordRequestForm:\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: OAuth2PasswordRequestForm = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scopes:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n\n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        Nevertheless, this dependency class is permissive and allows not passing it. If you want to enforce it,\n        use instead the OAuth2PasswordRequestFormStrict dependency.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(default=None, regex=\"password\"),\n        username: str = Form(),\n        password: str = Form(),\n        scope: str = Form(default=\"\"),\n        client_id: Optional[str] = Form(default=None),\n        client_secret: Optional[str] = Form(default=None),\n    ):\n        self.grant_type = grant_type\n        self.username = username\n        self.password = password\n        self.scopes = scope.split()\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n\nclass OAuth2PasswordRequestFormStrict(OAuth2PasswordRequestForm):\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: OAuth2PasswordRequestFormStrict = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scopes:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n\n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        This dependency is strict about it. If you want to be permissive, use instead the\n        OAuth2PasswordRequestForm dependency class.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(regex=\"password\"),\n        username: str = Form(),\n        password: str = Form(),\n        scope: str = Form(default=\"\"),\n        client_id: Optional[str] = Form(default=None),\n        client_secret: Optional[str] = Form(default=None),\n    ):\n        super().__init__(\n            grant_type=grant_type,\n            username=username,\n            password=password,\n            scope=scope,\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n\nclass OAuth2(SecurityBase):\n    def __init__(\n        self,\n        *,\n        flows: Union[OAuthFlowsModel, Dict[str, Dict[str, Any]]] = OAuthFlowsModel(),\n        scheme_name: Optional[str] = None,\n        description: Optional[str] = None,\n        auto_error: Optional[bool] = True\n    ):\n        self.model = OAuth2Model(flows=flows, description=description)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        if not authorization:\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        return authorization\n\n\nclass OAuth2PasswordBearer(OAuth2):\n    def __init__(\n        self,\n        tokenUrl: str,\n        scheme_name: Optional[str] = None,\n        scopes: Optional[Dict[str, str]] = None,\n        description: Optional[str] = None,\n        auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(password={\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        super().__init__(\n            flows=flows,\n            scheme_name=scheme_name,\n            description=description,\n            auto_error=auto_error,\n        )\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            else:\n                return None\n        return param\n\n\nclass OAuth2AuthorizationCodeBearer(OAuth2):\n    def __init__(\n        self,\n        authorizationUrl: str,\n        tokenUrl: str,\n        refreshUrl: Optional[str] = None,\n        scheme_name: Optional[str] = None,\n        scopes: Optional[Dict[str, str]] = None,\n        description: Optional[str] = None,\n        auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(\n            authorizationCode={\n                \"authorizationUrl\": authorizationUrl,\n                \"tokenUrl\": tokenUrl,\n                \"refreshUrl\": refreshUrl,\n                \"scopes\": scopes,\n            }\n        )\n        super().__init__(\n            flows=flows,\n            scheme_name=scheme_name,\n            description=description,\n            auto_error=auto_error,\n        )\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            else:\n                return None  # pragma: nocover\n        return param\n\n\nclass SecurityScopes:\n    def __init__(self, scopes: Optional[List[str]] = None):\n        self.scopes = scopes or []\n        self.scope_str = \" \".join(self.scopes)\n", "fix_code": "from typing import Any, Dict, List, Optional, Union\n\nfrom fastapi.exceptions import HTTPException\nfrom fastapi.openapi.models import OAuth2 as OAuth2Model\nfrom fastapi.openapi.models import OAuthFlows as OAuthFlowsModel\nfrom fastapi.param_functions import Form\nfrom fastapi.security.base import SecurityBase\nfrom fastapi.security.utils import get_authorization_scheme_param\nfrom starlette.requests import Request\nfrom starlette.status import HTTP_401_UNAUTHORIZED, HTTP_403_FORBIDDEN\n\n\nclass OAuth2PasswordRequestForm:\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: OAuth2PasswordRequestForm = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scopes:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n\n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        Nevertheless, this dependency class is permissive and allows not passing it. If you want to enforce it,\n        use instead the OAuth2PasswordRequestFormStrict dependency.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(default=None, regex=\"password\"),\n        username: str = Form(),\n        password: str = Form(),\n        scope: str = Form(default=\"\"),\n        client_id: Optional[str] = Form(default=None),\n        client_secret: Optional[str] = Form(default=None),\n    ):\n        self.grant_type = grant_type\n        self.username = username\n        self.password = password\n        self.scopes = scope.split()\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n\nclass OAuth2PasswordRequestFormStrict(OAuth2PasswordRequestForm):\n    \"\"\"\n    This is a dependency class, use it like:\n\n        @app.post(\"/login\")\n        def login(form_data: OAuth2PasswordRequestFormStrict = Depends()):\n            data = form_data.parse()\n            print(data.username)\n            print(data.password)\n            for scope in data.scopes:\n                print(scope)\n            if data.client_id:\n                print(data.client_id)\n            if data.client_secret:\n                print(data.client_secret)\n            return data\n\n\n    It creates the following Form request parameters in your endpoint:\n\n    grant_type: the OAuth2 spec says it is required and MUST be the fixed string \"password\".\n        This dependency is strict about it. If you want to be permissive, use instead the\n        OAuth2PasswordRequestForm dependency class.\n    username: username string. The OAuth2 spec requires the exact field name \"username\".\n    password: password string. The OAuth2 spec requires the exact field name \"password\".\n    scope: Optional string. Several scopes (each one a string) separated by spaces. E.g.\n        \"items:read items:write users:read profile openid\"\n    client_id: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    client_secret: optional string. OAuth2 recommends sending the client_id and client_secret (if any)\n        using HTTP Basic auth, as: client_id:client_secret\n    \"\"\"\n\n    def __init__(\n        self,\n        grant_type: str = Form(regex=\"password\"),\n        username: str = Form(),\n        password: str = Form(),\n        scope: str = Form(default=\"\"),\n        client_id: Optional[str] = Form(default=None),\n        client_secret: Optional[str] = Form(default=None),\n    ):\n        super().__init__(\n            grant_type=grant_type,\n            username=username,\n            password=password,\n            scope=scope,\n            client_id=client_id,\n            client_secret=client_secret,\n        )\n\n\nclass OAuth2(SecurityBase):\n    def __init__(\n        self,\n        *,\n        flows: Union[OAuthFlowsModel, Dict[str, Dict[str, Any]]] = OAuthFlowsModel(),\n        scheme_name: Optional[str] = None,\n        description: Optional[str] = None,\n        auto_error: bool = True\n    ):\n        self.model = OAuth2Model(flows=flows, description=description)\n        self.scheme_name = scheme_name or self.__class__.__name__\n        self.auto_error = auto_error\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        if not authorization:\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_403_FORBIDDEN, detail=\"Not authenticated\"\n                )\n            else:\n                return None\n        return authorization\n\n\nclass OAuth2PasswordBearer(OAuth2):\n    def __init__(\n        self,\n        tokenUrl: str,\n        scheme_name: Optional[str] = None,\n        scopes: Optional[Dict[str, str]] = None,\n        description: Optional[str] = None,\n        auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(password={\"tokenUrl\": tokenUrl, \"scopes\": scopes})\n        super().__init__(\n            flows=flows,\n            scheme_name=scheme_name,\n            description=description,\n            auto_error=auto_error,\n        )\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            else:\n                return None\n        return param\n\n\nclass OAuth2AuthorizationCodeBearer(OAuth2):\n    def __init__(\n        self,\n        authorizationUrl: str,\n        tokenUrl: str,\n        refreshUrl: Optional[str] = None,\n        scheme_name: Optional[str] = None,\n        scopes: Optional[Dict[str, str]] = None,\n        description: Optional[str] = None,\n        auto_error: bool = True,\n    ):\n        if not scopes:\n            scopes = {}\n        flows = OAuthFlowsModel(\n            authorizationCode={\n                \"authorizationUrl\": authorizationUrl,\n                \"tokenUrl\": tokenUrl,\n                \"refreshUrl\": refreshUrl,\n                \"scopes\": scopes,\n            }\n        )\n        super().__init__(\n            flows=flows,\n            scheme_name=scheme_name,\n            description=description,\n            auto_error=auto_error,\n        )\n\n    async def __call__(self, request: Request) -> Optional[str]:\n        authorization: str = request.headers.get(\"Authorization\")\n        scheme, param = get_authorization_scheme_param(authorization)\n        if not authorization or scheme.lower() != \"bearer\":\n            if self.auto_error:\n                raise HTTPException(\n                    status_code=HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n            else:\n                return None  # pragma: nocover\n        return param\n\n\nclass SecurityScopes:\n    def __init__(self, scopes: Optional[List[str]] = None):\n        self.scopes = scopes or []\n        self.scope_str = \" \".join(self.scopes)\n", "diff": "@@ -119,7 +119,7 @@ class OAuth2(SecurityBase):\n         flows: Union[OAuthFlowsModel, Dict[str, Dict[str, Any]]] = OAuthFlowsModel(),\n         scheme_name: Optional[str] = None,\n         description: Optional[str] = None,\n-        auto_error: Optional[bool] = True\n+        auto_error: bool = True\n     ):\n         self.model = OAuth2Model(flows=flows, description=description)\n         self.scheme_name = scheme_name or self.__class__.__name__\n"}
{"commit_hash": "5e34cb1868461a45e852c59c18e089ca7de2f140", "issue_description": "\u270f Fix typos in `tests/test_schema_extra_examples.py` (#5126)", "code_before": "from typing import Union\n\nfrom fastapi import Body, Cookie, FastAPI, Header, Path, Query\nfrom fastapi.testclient import TestClient\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    data: str\n\n    class Config:\n        schema_extra = {\"example\": {\"data\": \"Data in schema_extra\"}}\n\n\n@app.post(\"/schema_extra/\")\ndef schema_extra(item: Item):\n    return item\n\n\n@app.post(\"/example/\")\ndef example(item: Item = Body(example={\"data\": \"Data in Body example\"})):\n    return item\n\n\n@app.post(\"/examples/\")\ndef examples(\n    item: Item = Body(\n        examples={\n            \"example1\": {\n                \"summary\": \"example1 summary\",\n                \"value\": {\"data\": \"Data in Body examples, example1\"},\n            },\n            \"example2\": {\"value\": {\"data\": \"Data in Body examples, example2\"}},\n        },\n    )\n):\n    return item\n\n\n@app.post(\"/example_examples/\")\ndef example_examples(\n    item: Item = Body(\n        example={\"data\": \"Overriden example\"},\n        examples={\n            \"example1\": {\"value\": {\"data\": \"examples example_examples 1\"}},\n            \"example2\": {\"value\": {\"data\": \"examples example_examples 2\"}},\n        },\n    )\n):\n    return item\n\n\n# TODO: enable these tests once/if Form(embed=False) is supported\n# TODO: In that case, define if File() should support example/examples too\n# @app.post(\"/form_example\")\n# def form_example(firstname: str = Form(example=\"John\")):\n#     return firstname\n\n\n# @app.post(\"/form_examples\")\n# def form_examples(\n#     lastname: str = Form(\n#         ...,\n#         examples={\n#             \"example1\": {\"summary\": \"last name summary\", \"value\": \"Doe\"},\n#             \"example2\": {\"value\": \"Doesn't\"},\n#         },\n#     ),\n# ):\n#     return lastname\n\n\n# @app.post(\"/form_example_examples\")\n# def form_example_examples(\n#     lastname: str = Form(\n#         ...,\n#         example=\"Doe overriden\",\n#         examples={\n#             \"example1\": {\"summary\": \"last name summary\", \"value\": \"Doe\"},\n#             \"example2\": {\"value\": \"Doesn't\"},\n#         },\n#     ),\n# ):\n#     return lastname\n\n\n@app.get(\"/path_example/{item_id}\")\ndef path_example(\n    item_id: str = Path(\n        example=\"item_1\",\n    ),\n):\n    return item_id\n\n\n@app.get(\"/path_examples/{item_id}\")\ndef path_examples(\n    item_id: str = Path(\n        examples={\n            \"example1\": {\"summary\": \"item ID summary\", \"value\": \"item_1\"},\n            \"example2\": {\"value\": \"item_2\"},\n        },\n    ),\n):\n    return item_id\n\n\n@app.get(\"/path_example_examples/{item_id}\")\ndef path_example_examples(\n    item_id: str = Path(\n        example=\"item_overriden\",\n        examples={\n            \"example1\": {\"summary\": \"item ID summary\", \"value\": \"item_1\"},\n            \"example2\": {\"value\": \"item_2\"},\n        },\n    ),\n):\n    return item_id\n\n\n@app.get(\"/query_example/\")\ndef query_example(\n    data: Union[str, None] = Query(\n        default=None,\n        example=\"query1\",\n    ),\n):\n    return data\n\n\n@app.get(\"/query_examples/\")\ndef query_examples(\n    data: Union[str, None] = Query(\n        default=None,\n        examples={\n            \"example1\": {\"summary\": \"Query example 1\", \"value\": \"query1\"},\n            \"example2\": {\"value\": \"query2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/query_example_examples/\")\ndef query_example_examples(\n    data: Union[str, None] = Query(\n        default=None,\n        example=\"query_overriden\",\n        examples={\n            \"example1\": {\"summary\": \"Qeury example 1\", \"value\": \"query1\"},\n            \"example2\": {\"value\": \"query2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/header_example/\")\ndef header_example(\n    data: Union[str, None] = Header(\n        default=None,\n        example=\"header1\",\n    ),\n):\n    return data\n\n\n@app.get(\"/header_examples/\")\ndef header_examples(\n    data: Union[str, None] = Header(\n        default=None,\n        examples={\n            \"example1\": {\"summary\": \"header example 1\", \"value\": \"header1\"},\n            \"example2\": {\"value\": \"header2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/header_example_examples/\")\ndef header_example_examples(\n    data: Union[str, None] = Header(\n        default=None,\n        example=\"header_overriden\",\n        examples={\n            \"example1\": {\"summary\": \"Qeury example 1\", \"value\": \"header1\"},\n            \"example2\": {\"value\": \"header2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/cookie_example/\")\ndef cookie_example(\n    data: Union[str, None] = Cookie(\n        default=None,\n        example=\"cookie1\",\n    ),\n):\n    return data\n\n\n@app.get(\"/cookie_examples/\")\ndef cookie_examples(\n    data: Union[str, None] = Cookie(\n        default=None,\n        examples={\n            \"example1\": {\"summary\": \"cookie example 1\", \"value\": \"cookie1\"},\n            \"example2\": {\"value\": \"cookie2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/cookie_example_examples/\")\ndef cookie_example_examples(\n    data: Union[str, None] = Cookie(\n        default=None,\n        example=\"cookie_overriden\",\n        examples={\n            \"example1\": {\"summary\": \"Qeury example 1\", \"value\": \"cookie1\"},\n            \"example2\": {\"value\": \"cookie2\"},\n        },\n    ),\n):\n    return data\n\n\nclient = TestClient(app)\n\n\nopenapi_schema = {\n    \"openapi\": \"3.0.2\",\n    \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n    \"paths\": {\n        \"/schema_extra/\": {\n            \"post\": {\n                \"summary\": \"Schema Extra\",\n                \"operationId\": \"schema_extra_schema_extra__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                        }\n                    },\n                    \"required\": True,\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/example/\": {\n            \"post\": {\n                \"summary\": \"Example\",\n                \"operationId\": \"example_example__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"},\n                            \"example\": {\"data\": \"Data in Body example\"},\n                        }\n                    },\n                    \"required\": True,\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/examples/\": {\n            \"post\": {\n                \"summary\": \"Examples\",\n                \"operationId\": \"examples_examples__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"},\n                            \"examples\": {\n                                \"example1\": {\n                                    \"summary\": \"example1 summary\",\n                                    \"value\": {\n                                        \"data\": \"Data in Body examples, example1\"\n                                    },\n                                },\n                                \"example2\": {\n                                    \"value\": {\"data\": \"Data in Body examples, example2\"}\n                                },\n                            },\n                        }\n                    },\n                    \"required\": True,\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/example_examples/\": {\n            \"post\": {\n                \"summary\": \"Example Examples\",\n                \"operationId\": \"example_examples_example_examples__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"},\n                            \"examples\": {\n                                \"example1\": {\n                                    \"value\": {\"data\": \"examples example_examples 1\"}\n                                },\n                                \"example2\": {\n                                    \"value\": {\"data\": \"examples example_examples 2\"}\n                                },\n                            },\n                        }\n                    },\n                    \"required\": True,\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/path_example/{item_id}\": {\n            \"get\": {\n                \"summary\": \"Path Example\",\n                \"operationId\": \"path_example_path_example__item_id__get\",\n                \"parameters\": [\n                    {\n                        \"required\": True,\n                        \"schema\": {\"title\": \"Item Id\", \"type\": \"string\"},\n                        \"example\": \"item_1\",\n                        \"name\": \"item_id\",\n                        \"in\": \"path\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/path_examples/{item_id}\": {\n            \"get\": {\n                \"summary\": \"Path Examples\",\n                \"operationId\": \"path_examples_path_examples__item_id__get\",\n                \"parameters\": [\n                    {\n                        \"required\": True,\n                        \"schema\": {\"title\": \"Item Id\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"item ID summary\",\n                                \"value\": \"item_1\",\n                            },\n                            \"example2\": {\"value\": \"item_2\"},\n                        },\n                        \"name\": \"item_id\",\n                        \"in\": \"path\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/path_example_examples/{item_id}\": {\n            \"get\": {\n                \"summary\": \"Path Example Examples\",\n                \"operationId\": \"path_example_examples_path_example_examples__item_id__get\",\n                \"parameters\": [\n                    {\n                        \"required\": True,\n                        \"schema\": {\"title\": \"Item Id\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"item ID summary\",\n                                \"value\": \"item_1\",\n                            },\n                            \"example2\": {\"value\": \"item_2\"},\n                        },\n                        \"name\": \"item_id\",\n                        \"in\": \"path\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/query_example/\": {\n            \"get\": {\n                \"summary\": \"Query Example\",\n                \"operationId\": \"query_example_query_example__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"example\": \"query1\",\n                        \"name\": \"data\",\n                        \"in\": \"query\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/query_examples/\": {\n            \"get\": {\n                \"summary\": \"Query Examples\",\n                \"operationId\": \"query_examples_query_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"Query example 1\",\n                                \"value\": \"query1\",\n                            },\n                            \"example2\": {\"value\": \"query2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"query\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/query_example_examples/\": {\n            \"get\": {\n                \"summary\": \"Query Example Examples\",\n                \"operationId\": \"query_example_examples_query_example_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"Qeury example 1\",\n                                \"value\": \"query1\",\n                            },\n                            \"example2\": {\"value\": \"query2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"query\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/header_example/\": {\n            \"get\": {\n                \"summary\": \"Header Example\",\n                \"operationId\": \"header_example_header_example__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"example\": \"header1\",\n                        \"name\": \"data\",\n                        \"in\": \"header\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/header_examples/\": {\n            \"get\": {\n                \"summary\": \"Header Examples\",\n                \"operationId\": \"header_examples_header_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"header example 1\",\n                                \"value\": \"header1\",\n                            },\n                            \"example2\": {\"value\": \"header2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"header\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/header_example_examples/\": {\n            \"get\": {\n                \"summary\": \"Header Example Examples\",\n                \"operationId\": \"header_example_examples_header_example_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"Qeury example 1\",\n                                \"value\": \"header1\",\n                            },\n                            \"example2\": {\"value\": \"header2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"header\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/cookie_example/\": {\n            \"get\": {\n                \"summary\": \"Cookie Example\",\n                \"operationId\": \"cookie_example_cookie_example__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"example\": \"cookie1\",\n                        \"name\": \"data\",\n                        \"in\": \"cookie\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/cookie_examples/\": {\n            \"get\": {\n                \"summary\": \"Cookie Examples\",\n                \"operationId\": \"cookie_examples_cookie_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"cookie example 1\",\n                                \"value\": \"cookie1\",\n                            },\n                            \"example2\": {\"value\": \"cookie2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"cookie\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/cookie_example_examples/\": {\n            \"get\": {\n                \"summary\": \"Cookie Example Examples\",\n                \"operationId\": \"cookie_example_examples_cookie_example_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"Qeury example 1\",\n                                \"value\": \"cookie1\",\n                            },\n                            \"example2\": {\"value\": \"cookie2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"cookie\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n    },\n    \"components\": {\n        \"schemas\": {\n            \"HTTPValidationError\": {\n                \"title\": \"HTTPValidationError\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"detail\": {\n                        \"title\": \"Detail\",\n                        \"type\": \"array\",\n                        \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                    }\n                },\n            },\n            \"Item\": {\n                \"title\": \"Item\",\n                \"required\": [\"data\"],\n                \"type\": \"object\",\n                \"properties\": {\"data\": {\"title\": \"Data\", \"type\": \"string\"}},\n                \"example\": {\"data\": \"Data in schema_extra\"},\n            },\n            \"ValidationError\": {\n                \"title\": \"ValidationError\",\n                \"required\": [\"loc\", \"msg\", \"type\"],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"loc\": {\n                        \"title\": \"Location\",\n                        \"type\": \"array\",\n                        \"items\": {\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]},\n                    },\n                    \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n                    \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n                },\n            },\n        }\n    },\n}\n\n\ndef test_openapi_schema():\n    \"\"\"\n    Test that example overrides work:\n\n    * pydantic model schema_extra is included\n    * Body(example={}) overrides schema_extra in pydantic model\n    * Body(examples{}) overrides Body(example={}) and schema_extra in pydantic model\n    \"\"\"\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == openapi_schema\n\n\ndef test_call_api():\n    response = client.post(\"/schema_extra/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/example/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/examples/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/example_examples/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_example/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_examples/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_example_examples/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_example_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_example_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_example_examples/\")\n    assert response.status_code == 200, response.text\n", "fix_code": "from typing import Union\n\nfrom fastapi import Body, Cookie, FastAPI, Header, Path, Query\nfrom fastapi.testclient import TestClient\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n\nclass Item(BaseModel):\n    data: str\n\n    class Config:\n        schema_extra = {\"example\": {\"data\": \"Data in schema_extra\"}}\n\n\n@app.post(\"/schema_extra/\")\ndef schema_extra(item: Item):\n    return item\n\n\n@app.post(\"/example/\")\ndef example(item: Item = Body(example={\"data\": \"Data in Body example\"})):\n    return item\n\n\n@app.post(\"/examples/\")\ndef examples(\n    item: Item = Body(\n        examples={\n            \"example1\": {\n                \"summary\": \"example1 summary\",\n                \"value\": {\"data\": \"Data in Body examples, example1\"},\n            },\n            \"example2\": {\"value\": {\"data\": \"Data in Body examples, example2\"}},\n        },\n    )\n):\n    return item\n\n\n@app.post(\"/example_examples/\")\ndef example_examples(\n    item: Item = Body(\n        example={\"data\": \"Overriden example\"},\n        examples={\n            \"example1\": {\"value\": {\"data\": \"examples example_examples 1\"}},\n            \"example2\": {\"value\": {\"data\": \"examples example_examples 2\"}},\n        },\n    )\n):\n    return item\n\n\n# TODO: enable these tests once/if Form(embed=False) is supported\n# TODO: In that case, define if File() should support example/examples too\n# @app.post(\"/form_example\")\n# def form_example(firstname: str = Form(example=\"John\")):\n#     return firstname\n\n\n# @app.post(\"/form_examples\")\n# def form_examples(\n#     lastname: str = Form(\n#         ...,\n#         examples={\n#             \"example1\": {\"summary\": \"last name summary\", \"value\": \"Doe\"},\n#             \"example2\": {\"value\": \"Doesn't\"},\n#         },\n#     ),\n# ):\n#     return lastname\n\n\n# @app.post(\"/form_example_examples\")\n# def form_example_examples(\n#     lastname: str = Form(\n#         ...,\n#         example=\"Doe overriden\",\n#         examples={\n#             \"example1\": {\"summary\": \"last name summary\", \"value\": \"Doe\"},\n#             \"example2\": {\"value\": \"Doesn't\"},\n#         },\n#     ),\n# ):\n#     return lastname\n\n\n@app.get(\"/path_example/{item_id}\")\ndef path_example(\n    item_id: str = Path(\n        example=\"item_1\",\n    ),\n):\n    return item_id\n\n\n@app.get(\"/path_examples/{item_id}\")\ndef path_examples(\n    item_id: str = Path(\n        examples={\n            \"example1\": {\"summary\": \"item ID summary\", \"value\": \"item_1\"},\n            \"example2\": {\"value\": \"item_2\"},\n        },\n    ),\n):\n    return item_id\n\n\n@app.get(\"/path_example_examples/{item_id}\")\ndef path_example_examples(\n    item_id: str = Path(\n        example=\"item_overriden\",\n        examples={\n            \"example1\": {\"summary\": \"item ID summary\", \"value\": \"item_1\"},\n            \"example2\": {\"value\": \"item_2\"},\n        },\n    ),\n):\n    return item_id\n\n\n@app.get(\"/query_example/\")\ndef query_example(\n    data: Union[str, None] = Query(\n        default=None,\n        example=\"query1\",\n    ),\n):\n    return data\n\n\n@app.get(\"/query_examples/\")\ndef query_examples(\n    data: Union[str, None] = Query(\n        default=None,\n        examples={\n            \"example1\": {\"summary\": \"Query example 1\", \"value\": \"query1\"},\n            \"example2\": {\"value\": \"query2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/query_example_examples/\")\ndef query_example_examples(\n    data: Union[str, None] = Query(\n        default=None,\n        example=\"query_overriden\",\n        examples={\n            \"example1\": {\"summary\": \"Query example 1\", \"value\": \"query1\"},\n            \"example2\": {\"value\": \"query2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/header_example/\")\ndef header_example(\n    data: Union[str, None] = Header(\n        default=None,\n        example=\"header1\",\n    ),\n):\n    return data\n\n\n@app.get(\"/header_examples/\")\ndef header_examples(\n    data: Union[str, None] = Header(\n        default=None,\n        examples={\n            \"example1\": {\"summary\": \"header example 1\", \"value\": \"header1\"},\n            \"example2\": {\"value\": \"header2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/header_example_examples/\")\ndef header_example_examples(\n    data: Union[str, None] = Header(\n        default=None,\n        example=\"header_overriden\",\n        examples={\n            \"example1\": {\"summary\": \"Query example 1\", \"value\": \"header1\"},\n            \"example2\": {\"value\": \"header2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/cookie_example/\")\ndef cookie_example(\n    data: Union[str, None] = Cookie(\n        default=None,\n        example=\"cookie1\",\n    ),\n):\n    return data\n\n\n@app.get(\"/cookie_examples/\")\ndef cookie_examples(\n    data: Union[str, None] = Cookie(\n        default=None,\n        examples={\n            \"example1\": {\"summary\": \"cookie example 1\", \"value\": \"cookie1\"},\n            \"example2\": {\"value\": \"cookie2\"},\n        },\n    ),\n):\n    return data\n\n\n@app.get(\"/cookie_example_examples/\")\ndef cookie_example_examples(\n    data: Union[str, None] = Cookie(\n        default=None,\n        example=\"cookie_overriden\",\n        examples={\n            \"example1\": {\"summary\": \"Query example 1\", \"value\": \"cookie1\"},\n            \"example2\": {\"value\": \"cookie2\"},\n        },\n    ),\n):\n    return data\n\n\nclient = TestClient(app)\n\n\nopenapi_schema = {\n    \"openapi\": \"3.0.2\",\n    \"info\": {\"title\": \"FastAPI\", \"version\": \"0.1.0\"},\n    \"paths\": {\n        \"/schema_extra/\": {\n            \"post\": {\n                \"summary\": \"Schema Extra\",\n                \"operationId\": \"schema_extra_schema_extra__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"}\n                        }\n                    },\n                    \"required\": True,\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/example/\": {\n            \"post\": {\n                \"summary\": \"Example\",\n                \"operationId\": \"example_example__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"},\n                            \"example\": {\"data\": \"Data in Body example\"},\n                        }\n                    },\n                    \"required\": True,\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/examples/\": {\n            \"post\": {\n                \"summary\": \"Examples\",\n                \"operationId\": \"examples_examples__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"},\n                            \"examples\": {\n                                \"example1\": {\n                                    \"summary\": \"example1 summary\",\n                                    \"value\": {\n                                        \"data\": \"Data in Body examples, example1\"\n                                    },\n                                },\n                                \"example2\": {\n                                    \"value\": {\"data\": \"Data in Body examples, example2\"}\n                                },\n                            },\n                        }\n                    },\n                    \"required\": True,\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/example_examples/\": {\n            \"post\": {\n                \"summary\": \"Example Examples\",\n                \"operationId\": \"example_examples_example_examples__post\",\n                \"requestBody\": {\n                    \"content\": {\n                        \"application/json\": {\n                            \"schema\": {\"$ref\": \"#/components/schemas/Item\"},\n                            \"examples\": {\n                                \"example1\": {\n                                    \"value\": {\"data\": \"examples example_examples 1\"}\n                                },\n                                \"example2\": {\n                                    \"value\": {\"data\": \"examples example_examples 2\"}\n                                },\n                            },\n                        }\n                    },\n                    \"required\": True,\n                },\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/path_example/{item_id}\": {\n            \"get\": {\n                \"summary\": \"Path Example\",\n                \"operationId\": \"path_example_path_example__item_id__get\",\n                \"parameters\": [\n                    {\n                        \"required\": True,\n                        \"schema\": {\"title\": \"Item Id\", \"type\": \"string\"},\n                        \"example\": \"item_1\",\n                        \"name\": \"item_id\",\n                        \"in\": \"path\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/path_examples/{item_id}\": {\n            \"get\": {\n                \"summary\": \"Path Examples\",\n                \"operationId\": \"path_examples_path_examples__item_id__get\",\n                \"parameters\": [\n                    {\n                        \"required\": True,\n                        \"schema\": {\"title\": \"Item Id\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"item ID summary\",\n                                \"value\": \"item_1\",\n                            },\n                            \"example2\": {\"value\": \"item_2\"},\n                        },\n                        \"name\": \"item_id\",\n                        \"in\": \"path\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/path_example_examples/{item_id}\": {\n            \"get\": {\n                \"summary\": \"Path Example Examples\",\n                \"operationId\": \"path_example_examples_path_example_examples__item_id__get\",\n                \"parameters\": [\n                    {\n                        \"required\": True,\n                        \"schema\": {\"title\": \"Item Id\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"item ID summary\",\n                                \"value\": \"item_1\",\n                            },\n                            \"example2\": {\"value\": \"item_2\"},\n                        },\n                        \"name\": \"item_id\",\n                        \"in\": \"path\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/query_example/\": {\n            \"get\": {\n                \"summary\": \"Query Example\",\n                \"operationId\": \"query_example_query_example__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"example\": \"query1\",\n                        \"name\": \"data\",\n                        \"in\": \"query\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/query_examples/\": {\n            \"get\": {\n                \"summary\": \"Query Examples\",\n                \"operationId\": \"query_examples_query_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"Query example 1\",\n                                \"value\": \"query1\",\n                            },\n                            \"example2\": {\"value\": \"query2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"query\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/query_example_examples/\": {\n            \"get\": {\n                \"summary\": \"Query Example Examples\",\n                \"operationId\": \"query_example_examples_query_example_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"Query example 1\",\n                                \"value\": \"query1\",\n                            },\n                            \"example2\": {\"value\": \"query2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"query\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/header_example/\": {\n            \"get\": {\n                \"summary\": \"Header Example\",\n                \"operationId\": \"header_example_header_example__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"example\": \"header1\",\n                        \"name\": \"data\",\n                        \"in\": \"header\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/header_examples/\": {\n            \"get\": {\n                \"summary\": \"Header Examples\",\n                \"operationId\": \"header_examples_header_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"header example 1\",\n                                \"value\": \"header1\",\n                            },\n                            \"example2\": {\"value\": \"header2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"header\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/header_example_examples/\": {\n            \"get\": {\n                \"summary\": \"Header Example Examples\",\n                \"operationId\": \"header_example_examples_header_example_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"Query example 1\",\n                                \"value\": \"header1\",\n                            },\n                            \"example2\": {\"value\": \"header2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"header\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/cookie_example/\": {\n            \"get\": {\n                \"summary\": \"Cookie Example\",\n                \"operationId\": \"cookie_example_cookie_example__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"example\": \"cookie1\",\n                        \"name\": \"data\",\n                        \"in\": \"cookie\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/cookie_examples/\": {\n            \"get\": {\n                \"summary\": \"Cookie Examples\",\n                \"operationId\": \"cookie_examples_cookie_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"cookie example 1\",\n                                \"value\": \"cookie1\",\n                            },\n                            \"example2\": {\"value\": \"cookie2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"cookie\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n        \"/cookie_example_examples/\": {\n            \"get\": {\n                \"summary\": \"Cookie Example Examples\",\n                \"operationId\": \"cookie_example_examples_cookie_example_examples__get\",\n                \"parameters\": [\n                    {\n                        \"required\": False,\n                        \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                        \"examples\": {\n                            \"example1\": {\n                                \"summary\": \"Query example 1\",\n                                \"value\": \"cookie1\",\n                            },\n                            \"example2\": {\"value\": \"cookie2\"},\n                        },\n                        \"name\": \"data\",\n                        \"in\": \"cookie\",\n                    }\n                ],\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Successful Response\",\n                        \"content\": {\"application/json\": {\"schema\": {}}},\n                    },\n                    \"422\": {\n                        \"description\": \"Validation Error\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/HTTPValidationError\"\n                                }\n                            }\n                        },\n                    },\n                },\n            }\n        },\n    },\n    \"components\": {\n        \"schemas\": {\n            \"HTTPValidationError\": {\n                \"title\": \"HTTPValidationError\",\n                \"type\": \"object\",\n                \"properties\": {\n                    \"detail\": {\n                        \"title\": \"Detail\",\n                        \"type\": \"array\",\n                        \"items\": {\"$ref\": \"#/components/schemas/ValidationError\"},\n                    }\n                },\n            },\n            \"Item\": {\n                \"title\": \"Item\",\n                \"required\": [\"data\"],\n                \"type\": \"object\",\n                \"properties\": {\"data\": {\"title\": \"Data\", \"type\": \"string\"}},\n                \"example\": {\"data\": \"Data in schema_extra\"},\n            },\n            \"ValidationError\": {\n                \"title\": \"ValidationError\",\n                \"required\": [\"loc\", \"msg\", \"type\"],\n                \"type\": \"object\",\n                \"properties\": {\n                    \"loc\": {\n                        \"title\": \"Location\",\n                        \"type\": \"array\",\n                        \"items\": {\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]},\n                    },\n                    \"msg\": {\"title\": \"Message\", \"type\": \"string\"},\n                    \"type\": {\"title\": \"Error Type\", \"type\": \"string\"},\n                },\n            },\n        }\n    },\n}\n\n\ndef test_openapi_schema():\n    \"\"\"\n    Test that example overrides work:\n\n    * pydantic model schema_extra is included\n    * Body(example={}) overrides schema_extra in pydantic model\n    * Body(examples{}) overrides Body(example={}) and schema_extra in pydantic model\n    \"\"\"\n    response = client.get(\"/openapi.json\")\n    assert response.status_code == 200, response.text\n    assert response.json() == openapi_schema\n\n\ndef test_call_api():\n    response = client.post(\"/schema_extra/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/example/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/examples/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.post(\"/example_examples/\", json={\"data\": \"Foo\"})\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_example/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_examples/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/path_example_examples/foo\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/query_example_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/header_example_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_example/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_examples/\")\n    assert response.status_code == 200, response.text\n    response = client.get(\"/cookie_example_examples/\")\n    assert response.status_code == 200, response.text\n", "diff": "@@ -149,7 +149,7 @@ def query_example_examples(\n         default=None,\n         example=\"query_overriden\",\n         examples={\n-            \"example1\": {\"summary\": \"Qeury example 1\", \"value\": \"query1\"},\n+            \"example1\": {\"summary\": \"Query example 1\", \"value\": \"query1\"},\n             \"example2\": {\"value\": \"query2\"},\n         },\n     ),\n@@ -186,7 +186,7 @@ def header_example_examples(\n         default=None,\n         example=\"header_overriden\",\n         examples={\n-            \"example1\": {\"summary\": \"Qeury example 1\", \"value\": \"header1\"},\n+            \"example1\": {\"summary\": \"Query example 1\", \"value\": \"header1\"},\n             \"example2\": {\"value\": \"header2\"},\n         },\n     ),\n@@ -223,7 +223,7 @@ def cookie_example_examples(\n         default=None,\n         example=\"cookie_overriden\",\n         examples={\n-            \"example1\": {\"summary\": \"Qeury example 1\", \"value\": \"cookie1\"},\n+            \"example1\": {\"summary\": \"Query example 1\", \"value\": \"cookie1\"},\n             \"example2\": {\"value\": \"cookie2\"},\n         },\n     ),\n@@ -561,7 +561,7 @@ openapi_schema = {\n                         \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                         \"examples\": {\n                             \"example1\": {\n-                                \"summary\": \"Qeury example 1\",\n+                                \"summary\": \"Query example 1\",\n                                 \"value\": \"query1\",\n                             },\n                             \"example2\": {\"value\": \"query2\"},\n@@ -666,7 +666,7 @@ openapi_schema = {\n                         \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                         \"examples\": {\n                             \"example1\": {\n-                                \"summary\": \"Qeury example 1\",\n+                                \"summary\": \"Query example 1\",\n                                 \"value\": \"header1\",\n                             },\n                             \"example2\": {\"value\": \"header2\"},\n@@ -771,7 +771,7 @@ openapi_schema = {\n                         \"schema\": {\"title\": \"Data\", \"type\": \"string\"},\n                         \"examples\": {\n                             \"example1\": {\n-                                \"summary\": \"Qeury example 1\",\n+                                \"summary\": \"Query example 1\",\n                                 \"value\": \"cookie1\",\n                             },\n                             \"example2\": {\"value\": \"cookie2\"},\n"}
{"commit_hash": "4cff206ebb925acfa4904bb5ddf62c6748f8b15f", "issue_description": "\ud83d\udc1b Fix FastAPI People GitHub Action: set HTTPX timeout for GraphQL query request (#5222)\n\nCo-authored-by: Irfanuddin <irfanuddin@knowledgelens.com>\r\nCo-authored-by: pre-commit-ci[bot] <66853113+pre-commit-ci[bot]@users.noreply.github.com>\r\nCo-authored-by: Sebasti\u00e1n Ram\u00edrez <tiangolo@gmail.com>", "code_before": "import logging\nimport subprocess\nimport sys\nfrom collections import Counter, defaultdict\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Container, DefaultDict, Dict, List, Set, Union\n\nimport httpx\nimport yaml\nfrom github import Github\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_graphql_url = \"https://api.github.com/graphql\"\n\nissues_query = \"\"\"\nquery Q($after: String) {\n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    issues(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nprs_query = \"\"\"\nquery Q($after: String) {\n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    pullRequests(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          labels(first: 100) {\n            nodes {\n              name\n            }\n          }\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n          reviews(first:100) {\n            nodes {\n              author {\n                login\n                avatarUrl\n                url\n              }\n              state\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nsponsors_query = \"\"\"\nquery Q($after: String) {\n  user(login: \"tiangolo\") {\n    sponsorshipsAsMaintainer(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          sponsorEntity {\n            ... on Organization {\n              login\n              avatarUrl\n              url\n            }\n            ... on User {\n              login\n              avatarUrl\n              url\n            }\n          }\n          tier {\n            name\n            monthlyPriceInDollars\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\n\nclass Author(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass CommentsNode(BaseModel):\n    createdAt: datetime\n    author: Union[Author, None] = None\n\n\nclass Comments(BaseModel):\n    nodes: List[CommentsNode]\n\n\nclass IssuesNode(BaseModel):\n    number: int\n    author: Union[Author, None] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n\n\nclass IssuesEdge(BaseModel):\n    cursor: str\n    node: IssuesNode\n\n\nclass Issues(BaseModel):\n    edges: List[IssuesEdge]\n\n\nclass IssuesRepository(BaseModel):\n    issues: Issues\n\n\nclass IssuesResponseData(BaseModel):\n    repository: IssuesRepository\n\n\nclass IssuesResponse(BaseModel):\n    data: IssuesResponseData\n\n\nclass LabelNode(BaseModel):\n    name: str\n\n\nclass Labels(BaseModel):\n    nodes: List[LabelNode]\n\n\nclass ReviewNode(BaseModel):\n    author: Union[Author, None] = None\n    state: str\n\n\nclass Reviews(BaseModel):\n    nodes: List[ReviewNode]\n\n\nclass PullRequestNode(BaseModel):\n    number: int\n    labels: Labels\n    author: Union[Author, None] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n    reviews: Reviews\n\n\nclass PullRequestEdge(BaseModel):\n    cursor: str\n    node: PullRequestNode\n\n\nclass PullRequests(BaseModel):\n    edges: List[PullRequestEdge]\n\n\nclass PRsRepository(BaseModel):\n    pullRequests: PullRequests\n\n\nclass PRsResponseData(BaseModel):\n    repository: PRsRepository\n\n\nclass PRsResponse(BaseModel):\n    data: PRsResponseData\n\n\nclass SponsorEntity(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass Tier(BaseModel):\n    name: str\n    monthlyPriceInDollars: float\n\n\nclass SponsorshipAsMaintainerNode(BaseModel):\n    sponsorEntity: SponsorEntity\n    tier: Tier\n\n\nclass SponsorshipAsMaintainerEdge(BaseModel):\n    cursor: str\n    node: SponsorshipAsMaintainerNode\n\n\nclass SponsorshipAsMaintainer(BaseModel):\n    edges: List[SponsorshipAsMaintainerEdge]\n\n\nclass SponsorsUser(BaseModel):\n    sponsorshipsAsMaintainer: SponsorshipAsMaintainer\n\n\nclass SponsorsResponseData(BaseModel):\n    user: SponsorsUser\n\n\nclass SponsorsResponse(BaseModel):\n    data: SponsorsResponseData\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    input_standard_token: SecretStr\n    github_repository: str\n\n\ndef get_graphql_response(\n    *, settings: Settings, query: str, after: Union[str, None] = None\n):\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = httpx.post(\n        github_graphql_url,\n        headers=headers,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if not response.status_code == 200:\n        logging.error(f\"Response was not 200, after: {after}\")\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    return data\n\n\ndef get_graphql_issue_edges(*, settings: Settings, after: Union[str, None] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.parse_obj(data)\n    return graphql_response.data.repository.issues.edges\n\n\ndef get_graphql_pr_edges(*, settings: Settings, after: Union[str, None] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.parse_obj(data)\n    return graphql_response.data.repository.pullRequests.edges\n\n\ndef get_graphql_sponsor_edges(*, settings: Settings, after: Union[str, None] = None):\n    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n    graphql_response = SponsorsResponse.parse_obj(data)\n    return graphql_response.data.user.sponsorshipsAsMaintainer.edges\n\n\ndef get_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == issue_author_name:\n                    continue\n                issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors\n\n\ndef get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors\n\n\ndef get_individual_sponsors(settings: Settings):\n    nodes: List[SponsorshipAsMaintainerNode] = []\n    edges = get_graphql_sponsor_edges(settings=settings)\n\n    while edges:\n        for edge in edges:\n            nodes.append(edge.node)\n        last_edge = edges[-1]\n        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n\n    tiers: DefaultDict[float, Dict[str, SponsorEntity]] = defaultdict(dict)\n    for node in nodes:\n        tiers[node.tier.monthlyPriceInDollars][\n            node.sponsorEntity.login\n        ] = node.sponsorEntity\n    return tiers\n\n\ndef get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_standard_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    issue_commentors, issue_last_month_commentors, issue_authors = get_experts(\n        settings=settings\n    )\n    contributors, pr_commentors, reviewers, pr_authors = get_contributors(\n        settings=settings\n    )\n    authors = {**issue_authors, **pr_authors}\n    maintainers_logins = {\"tiangolo\"}\n    bot_names = {\"codecov\", \"github-actions\"}\n    maintainers = []\n    for login in maintainers_logins:\n        user = authors[login]\n        maintainers.append(\n            {\n                \"login\": login,\n                \"answers\": issue_commentors[login],\n                \"prs\": contributors[login],\n                \"avatarUrl\": user.avatarUrl,\n                \"url\": user.url,\n            }\n        )\n\n    min_count_expert = 10\n    min_count_last_month = 3\n    min_count_contributor = 4\n    min_count_reviewer = 4\n    skip_users = maintainers_logins | bot_names\n    experts = get_top_users(\n        counter=issue_commentors,\n        min_count=min_count_expert,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    last_month_active = get_top_users(\n        counter=issue_last_month_commentors,\n        min_count=min_count_last_month,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_contributors = get_top_users(\n        counter=contributors,\n        min_count=min_count_contributor,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_reviewers = get_top_users(\n        counter=reviewers,\n        min_count=min_count_reviewer,\n        authors=authors,\n        skip_users=skip_users,\n    )\n\n    tiers = get_individual_sponsors(settings=settings)\n    keys = list(tiers.keys())\n    keys.sort(reverse=True)\n    sponsors = []\n    for key in keys:\n        sponsor_group = []\n        for login, sponsor in tiers[key].items():\n            sponsor_group.append(\n                {\"login\": login, \"avatarUrl\": sponsor.avatarUrl, \"url\": sponsor.url}\n            )\n        sponsors.append(sponsor_group)\n\n    people = {\n        \"maintainers\": maintainers,\n        \"experts\": experts,\n        \"last_month_active\": last_month_active,\n        \"top_contributors\": top_contributors,\n        \"top_reviewers\": top_reviewers,\n    }\n    github_sponsors = {\n        \"sponsors\": sponsors,\n    }\n    people_path = Path(\"./docs/en/data/people.yml\")\n    github_sponsors_path = Path(\"./docs/en/data/github_sponsors.yml\")\n    people_old_content = people_path.read_text(encoding=\"utf-8\")\n    github_sponsors_old_content = github_sponsors_path.read_text(encoding=\"utf-8\")\n    new_people_content = yaml.dump(\n        people, sort_keys=False, width=200, allow_unicode=True\n    )\n    new_github_sponsors_content = yaml.dump(\n        github_sponsors, sort_keys=False, width=200, allow_unicode=True\n    )\n    if (\n        people_old_content == new_people_content\n        and github_sponsors_old_content == new_github_sponsors_content\n    ):\n        logging.info(\"The FastAPI People data hasn't changed, finishing.\")\n        sys.exit(0)\n    people_path.write_text(new_people_content, encoding=\"utf-8\")\n    github_sponsors_path.write_text(new_github_sponsors_content, encoding=\"utf-8\")\n    logging.info(\"Setting up GitHub Actions git user\")\n    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n    subprocess.run(\n        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n    )\n    branch_name = \"fastapi-people\"\n    logging.info(f\"Creating a new branch {branch_name}\")\n    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n    logging.info(\"Adding updated file\")\n    subprocess.run(\n        [\"git\", \"add\", str(people_path), str(github_sponsors_path)], check=True\n    )\n    logging.info(\"Committing updated file\")\n    message = \"\ud83d\udc65 Update FastAPI People\"\n    result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n    logging.info(\"Pushing branch\")\n    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n    logging.info(\"Creating PR\")\n    pr = repo.create_pull(title=message, body=message, base=\"master\", head=branch_name)\n    logging.info(f\"Created PR: {pr.number}\")\n    logging.info(\"Finished\")\n", "fix_code": "import logging\nimport subprocess\nimport sys\nfrom collections import Counter, defaultdict\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Container, DefaultDict, Dict, List, Set, Union\n\nimport httpx\nimport yaml\nfrom github import Github\nfrom pydantic import BaseModel, BaseSettings, SecretStr\n\ngithub_graphql_url = \"https://api.github.com/graphql\"\n\nissues_query = \"\"\"\nquery Q($after: String) {\n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    issues(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nprs_query = \"\"\"\nquery Q($after: String) {\n  repository(name: \"fastapi\", owner: \"tiangolo\") {\n    pullRequests(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          labels(first: 100) {\n            nodes {\n              name\n            }\n          }\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n          reviews(first:100) {\n            nodes {\n              author {\n                login\n                avatarUrl\n                url\n              }\n              state\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nsponsors_query = \"\"\"\nquery Q($after: String) {\n  user(login: \"tiangolo\") {\n    sponsorshipsAsMaintainer(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          sponsorEntity {\n            ... on Organization {\n              login\n              avatarUrl\n              url\n            }\n            ... on User {\n              login\n              avatarUrl\n              url\n            }\n          }\n          tier {\n            name\n            monthlyPriceInDollars\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\n\nclass Author(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass CommentsNode(BaseModel):\n    createdAt: datetime\n    author: Union[Author, None] = None\n\n\nclass Comments(BaseModel):\n    nodes: List[CommentsNode]\n\n\nclass IssuesNode(BaseModel):\n    number: int\n    author: Union[Author, None] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n\n\nclass IssuesEdge(BaseModel):\n    cursor: str\n    node: IssuesNode\n\n\nclass Issues(BaseModel):\n    edges: List[IssuesEdge]\n\n\nclass IssuesRepository(BaseModel):\n    issues: Issues\n\n\nclass IssuesResponseData(BaseModel):\n    repository: IssuesRepository\n\n\nclass IssuesResponse(BaseModel):\n    data: IssuesResponseData\n\n\nclass LabelNode(BaseModel):\n    name: str\n\n\nclass Labels(BaseModel):\n    nodes: List[LabelNode]\n\n\nclass ReviewNode(BaseModel):\n    author: Union[Author, None] = None\n    state: str\n\n\nclass Reviews(BaseModel):\n    nodes: List[ReviewNode]\n\n\nclass PullRequestNode(BaseModel):\n    number: int\n    labels: Labels\n    author: Union[Author, None] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n    reviews: Reviews\n\n\nclass PullRequestEdge(BaseModel):\n    cursor: str\n    node: PullRequestNode\n\n\nclass PullRequests(BaseModel):\n    edges: List[PullRequestEdge]\n\n\nclass PRsRepository(BaseModel):\n    pullRequests: PullRequests\n\n\nclass PRsResponseData(BaseModel):\n    repository: PRsRepository\n\n\nclass PRsResponse(BaseModel):\n    data: PRsResponseData\n\n\nclass SponsorEntity(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\nclass Tier(BaseModel):\n    name: str\n    monthlyPriceInDollars: float\n\n\nclass SponsorshipAsMaintainerNode(BaseModel):\n    sponsorEntity: SponsorEntity\n    tier: Tier\n\n\nclass SponsorshipAsMaintainerEdge(BaseModel):\n    cursor: str\n    node: SponsorshipAsMaintainerNode\n\n\nclass SponsorshipAsMaintainer(BaseModel):\n    edges: List[SponsorshipAsMaintainerEdge]\n\n\nclass SponsorsUser(BaseModel):\n    sponsorshipsAsMaintainer: SponsorshipAsMaintainer\n\n\nclass SponsorsResponseData(BaseModel):\n    user: SponsorsUser\n\n\nclass SponsorsResponse(BaseModel):\n    data: SponsorsResponseData\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    input_standard_token: SecretStr\n    github_repository: str\n    httpx_timeout: int = 30\n\n\ndef get_graphql_response(\n    *, settings: Settings, query: str, after: Union[str, None] = None\n):\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = httpx.post(\n        github_graphql_url,\n        headers=headers,\n        timeout=settings.httpx_timeout,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if response.status_code != 200:\n        logging.error(f\"Response was not 200, after: {after}\")\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    return data\n\n\ndef get_graphql_issue_edges(*, settings: Settings, after: Union[str, None] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.parse_obj(data)\n    return graphql_response.data.repository.issues.edges\n\n\ndef get_graphql_pr_edges(*, settings: Settings, after: Union[str, None] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.parse_obj(data)\n    return graphql_response.data.repository.pullRequests.edges\n\n\ndef get_graphql_sponsor_edges(*, settings: Settings, after: Union[str, None] = None):\n    data = get_graphql_response(settings=settings, query=sponsors_query, after=after)\n    graphql_response = SponsorsResponse.parse_obj(data)\n    return graphql_response.data.user.sponsorshipsAsMaintainer.edges\n\n\ndef get_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == issue_author_name:\n                    continue\n                issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors\n\n\ndef get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors\n\n\ndef get_individual_sponsors(settings: Settings):\n    nodes: List[SponsorshipAsMaintainerNode] = []\n    edges = get_graphql_sponsor_edges(settings=settings)\n\n    while edges:\n        for edge in edges:\n            nodes.append(edge.node)\n        last_edge = edges[-1]\n        edges = get_graphql_sponsor_edges(settings=settings, after=last_edge.cursor)\n\n    tiers: DefaultDict[float, Dict[str, SponsorEntity]] = defaultdict(dict)\n    for node in nodes:\n        tiers[node.tier.monthlyPriceInDollars][\n            node.sponsorEntity.login\n        ] = node.sponsorEntity\n    return tiers\n\n\ndef get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.json()}\")\n    g = Github(settings.input_standard_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    issue_commentors, issue_last_month_commentors, issue_authors = get_experts(\n        settings=settings\n    )\n    contributors, pr_commentors, reviewers, pr_authors = get_contributors(\n        settings=settings\n    )\n    authors = {**issue_authors, **pr_authors}\n    maintainers_logins = {\"tiangolo\"}\n    bot_names = {\"codecov\", \"github-actions\"}\n    maintainers = []\n    for login in maintainers_logins:\n        user = authors[login]\n        maintainers.append(\n            {\n                \"login\": login,\n                \"answers\": issue_commentors[login],\n                \"prs\": contributors[login],\n                \"avatarUrl\": user.avatarUrl,\n                \"url\": user.url,\n            }\n        )\n\n    min_count_expert = 10\n    min_count_last_month = 3\n    min_count_contributor = 4\n    min_count_reviewer = 4\n    skip_users = maintainers_logins | bot_names\n    experts = get_top_users(\n        counter=issue_commentors,\n        min_count=min_count_expert,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    last_month_active = get_top_users(\n        counter=issue_last_month_commentors,\n        min_count=min_count_last_month,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_contributors = get_top_users(\n        counter=contributors,\n        min_count=min_count_contributor,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_reviewers = get_top_users(\n        counter=reviewers,\n        min_count=min_count_reviewer,\n        authors=authors,\n        skip_users=skip_users,\n    )\n\n    tiers = get_individual_sponsors(settings=settings)\n    keys = list(tiers.keys())\n    keys.sort(reverse=True)\n    sponsors = []\n    for key in keys:\n        sponsor_group = []\n        for login, sponsor in tiers[key].items():\n            sponsor_group.append(\n                {\"login\": login, \"avatarUrl\": sponsor.avatarUrl, \"url\": sponsor.url}\n            )\n        sponsors.append(sponsor_group)\n\n    people = {\n        \"maintainers\": maintainers,\n        \"experts\": experts,\n        \"last_month_active\": last_month_active,\n        \"top_contributors\": top_contributors,\n        \"top_reviewers\": top_reviewers,\n    }\n    github_sponsors = {\n        \"sponsors\": sponsors,\n    }\n    people_path = Path(\"./docs/en/data/people.yml\")\n    github_sponsors_path = Path(\"./docs/en/data/github_sponsors.yml\")\n    people_old_content = people_path.read_text(encoding=\"utf-8\")\n    github_sponsors_old_content = github_sponsors_path.read_text(encoding=\"utf-8\")\n    new_people_content = yaml.dump(\n        people, sort_keys=False, width=200, allow_unicode=True\n    )\n    new_github_sponsors_content = yaml.dump(\n        github_sponsors, sort_keys=False, width=200, allow_unicode=True\n    )\n    if (\n        people_old_content == new_people_content\n        and github_sponsors_old_content == new_github_sponsors_content\n    ):\n        logging.info(\"The FastAPI People data hasn't changed, finishing.\")\n        sys.exit(0)\n    people_path.write_text(new_people_content, encoding=\"utf-8\")\n    github_sponsors_path.write_text(new_github_sponsors_content, encoding=\"utf-8\")\n    logging.info(\"Setting up GitHub Actions git user\")\n    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n    subprocess.run(\n        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n    )\n    branch_name = \"fastapi-people\"\n    logging.info(f\"Creating a new branch {branch_name}\")\n    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n    logging.info(\"Adding updated file\")\n    subprocess.run(\n        [\"git\", \"add\", str(people_path), str(github_sponsors_path)], check=True\n    )\n    logging.info(\"Committing updated file\")\n    message = \"\ud83d\udc65 Update FastAPI People\"\n    result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n    logging.info(\"Pushing branch\")\n    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n    logging.info(\"Creating PR\")\n    pr = repo.create_pull(title=message, body=message, base=\"master\", head=branch_name)\n    logging.info(f\"Created PR: {pr.number}\")\n    logging.info(\"Finished\")\n", "diff": "@@ -260,6 +260,7 @@ class Settings(BaseSettings):\n     input_token: SecretStr\n     input_standard_token: SecretStr\n     github_repository: str\n+    httpx_timeout: int = 30\n \n \n def get_graphql_response(\n@@ -270,9 +271,10 @@ def get_graphql_response(\n     response = httpx.post(\n         github_graphql_url,\n         headers=headers,\n+        timeout=settings.httpx_timeout,\n         json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n     )\n-    if not response.status_code == 200:\n+    if response.status_code != 200:\n         logging.error(f\"Response was not 200, after: {after}\")\n         logging.error(response.text)\n         raise RuntimeError(response.text)\n"}
{"commit_hash": "2d35651a5a21db07d2164258cedf35e718662540", "issue_description": "\ud83d\udc1b Fix OpenAPI model fields int validations, change `gte` to `ge` (#9635)\n\n\ud83d\udc1b Fix OpenAPI model fields int validations, change `gte` to `ge`", "code_before": "from enum import Enum\nfrom typing import Any, Callable, Dict, Iterable, List, Optional, Union\n\nfrom fastapi.logger import logger\nfrom pydantic import AnyUrl, BaseModel, Field\n\ntry:\n    import email_validator  # type: ignore\n\n    assert email_validator  # make autoflake ignore the unused import\n    from pydantic import EmailStr\nexcept ImportError:  # pragma: no cover\n\n    class EmailStr(str):  # type: ignore\n        @classmethod\n        def __get_validators__(cls) -> Iterable[Callable[..., Any]]:\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, v: Any) -> str:\n            logger.warning(\n                \"email-validator not installed, email fields will be treated as str.\\n\"\n                \"To install, run: pip install email-validator\"\n            )\n            return str(v)\n\n\nclass Contact(BaseModel):\n    name: Optional[str] = None\n    url: Optional[AnyUrl] = None\n    email: Optional[EmailStr] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass License(BaseModel):\n    name: str\n    url: Optional[AnyUrl] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Info(BaseModel):\n    title: str\n    description: Optional[str] = None\n    termsOfService: Optional[str] = None\n    contact: Optional[Contact] = None\n    license: Optional[License] = None\n    version: str\n\n    class Config:\n        extra = \"allow\"\n\n\nclass ServerVariable(BaseModel):\n    enum: Optional[List[str]] = None\n    default: str\n    description: Optional[str] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Server(BaseModel):\n    url: Union[AnyUrl, str]\n    description: Optional[str] = None\n    variables: Optional[Dict[str, ServerVariable]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Reference(BaseModel):\n    ref: str = Field(alias=\"$ref\")\n\n\nclass Discriminator(BaseModel):\n    propertyName: str\n    mapping: Optional[Dict[str, str]] = None\n\n\nclass XML(BaseModel):\n    name: Optional[str] = None\n    namespace: Optional[str] = None\n    prefix: Optional[str] = None\n    attribute: Optional[bool] = None\n    wrapped: Optional[bool] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass ExternalDocumentation(BaseModel):\n    description: Optional[str] = None\n    url: AnyUrl\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Schema(BaseModel):\n    ref: Optional[str] = Field(default=None, alias=\"$ref\")\n    title: Optional[str] = None\n    multipleOf: Optional[float] = None\n    maximum: Optional[float] = None\n    exclusiveMaximum: Optional[float] = None\n    minimum: Optional[float] = None\n    exclusiveMinimum: Optional[float] = None\n    maxLength: Optional[int] = Field(default=None, gte=0)\n    minLength: Optional[int] = Field(default=None, gte=0)\n    pattern: Optional[str] = None\n    maxItems: Optional[int] = Field(default=None, gte=0)\n    minItems: Optional[int] = Field(default=None, gte=0)\n    uniqueItems: Optional[bool] = None\n    maxProperties: Optional[int] = Field(default=None, gte=0)\n    minProperties: Optional[int] = Field(default=None, gte=0)\n    required: Optional[List[str]] = None\n    enum: Optional[List[Any]] = None\n    type: Optional[str] = None\n    allOf: Optional[List[\"Schema\"]] = None\n    oneOf: Optional[List[\"Schema\"]] = None\n    anyOf: Optional[List[\"Schema\"]] = None\n    not_: Optional[\"Schema\"] = Field(default=None, alias=\"not\")\n    items: Optional[Union[\"Schema\", List[\"Schema\"]]] = None\n    properties: Optional[Dict[str, \"Schema\"]] = None\n    additionalProperties: Optional[Union[\"Schema\", Reference, bool]] = None\n    description: Optional[str] = None\n    format: Optional[str] = None\n    default: Optional[Any] = None\n    nullable: Optional[bool] = None\n    discriminator: Optional[Discriminator] = None\n    readOnly: Optional[bool] = None\n    writeOnly: Optional[bool] = None\n    xml: Optional[XML] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    example: Optional[Any] = None\n    deprecated: Optional[bool] = None\n\n    class Config:\n        extra: str = \"allow\"\n\n\nclass Example(BaseModel):\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    value: Optional[Any] = None\n    externalValue: Optional[AnyUrl] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass ParameterInType(Enum):\n    query = \"query\"\n    header = \"header\"\n    path = \"path\"\n    cookie = \"cookie\"\n\n\nclass Encoding(BaseModel):\n    contentType: Optional[str] = None\n    headers: Optional[Dict[str, Union[\"Header\", Reference]]] = None\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass MediaType(BaseModel):\n    schema_: Optional[Union[Schema, Reference]] = Field(default=None, alias=\"schema\")\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    encoding: Optional[Dict[str, Encoding]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass ParameterBase(BaseModel):\n    description: Optional[str] = None\n    required: Optional[bool] = None\n    deprecated: Optional[bool] = None\n    # Serialization rules for simple scenarios\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n    schema_: Optional[Union[Schema, Reference]] = Field(default=None, alias=\"schema\")\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    # Serialization rules for more complex scenarios\n    content: Optional[Dict[str, MediaType]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Parameter(ParameterBase):\n    name: str\n    in_: ParameterInType = Field(alias=\"in\")\n\n\nclass Header(ParameterBase):\n    pass\n\n\nclass RequestBody(BaseModel):\n    description: Optional[str] = None\n    content: Dict[str, MediaType]\n    required: Optional[bool] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Link(BaseModel):\n    operationRef: Optional[str] = None\n    operationId: Optional[str] = None\n    parameters: Optional[Dict[str, Union[Any, str]]] = None\n    requestBody: Optional[Union[Any, str]] = None\n    description: Optional[str] = None\n    server: Optional[Server] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Response(BaseModel):\n    description: str\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    content: Optional[Dict[str, MediaType]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Operation(BaseModel):\n    tags: Optional[List[str]] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    operationId: Optional[str] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n    requestBody: Optional[Union[RequestBody, Reference]] = None\n    # Using Any for Specification Extensions\n    responses: Dict[str, Union[Response, Any]]\n    callbacks: Optional[Dict[str, Union[Dict[str, \"PathItem\"], Reference]]] = None\n    deprecated: Optional[bool] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    servers: Optional[List[Server]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass PathItem(BaseModel):\n    ref: Optional[str] = Field(default=None, alias=\"$ref\")\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    get: Optional[Operation] = None\n    put: Optional[Operation] = None\n    post: Optional[Operation] = None\n    delete: Optional[Operation] = None\n    options: Optional[Operation] = None\n    head: Optional[Operation] = None\n    patch: Optional[Operation] = None\n    trace: Optional[Operation] = None\n    servers: Optional[List[Server]] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass SecuritySchemeType(Enum):\n    apiKey = \"apiKey\"\n    http = \"http\"\n    oauth2 = \"oauth2\"\n    openIdConnect = \"openIdConnect\"\n\n\nclass SecurityBase(BaseModel):\n    type_: SecuritySchemeType = Field(alias=\"type\")\n    description: Optional[str] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass APIKeyIn(Enum):\n    query = \"query\"\n    header = \"header\"\n    cookie = \"cookie\"\n\n\nclass APIKey(SecurityBase):\n    type_ = Field(SecuritySchemeType.apiKey, alias=\"type\")\n    in_: APIKeyIn = Field(alias=\"in\")\n    name: str\n\n\nclass HTTPBase(SecurityBase):\n    type_ = Field(SecuritySchemeType.http, alias=\"type\")\n    scheme: str\n\n\nclass HTTPBearer(HTTPBase):\n    scheme = \"bearer\"\n    bearerFormat: Optional[str] = None\n\n\nclass OAuthFlow(BaseModel):\n    refreshUrl: Optional[str] = None\n    scopes: Dict[str, str] = {}\n\n    class Config:\n        extra = \"allow\"\n\n\nclass OAuthFlowImplicit(OAuthFlow):\n    authorizationUrl: str\n\n\nclass OAuthFlowPassword(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowClientCredentials(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowAuthorizationCode(OAuthFlow):\n    authorizationUrl: str\n    tokenUrl: str\n\n\nclass OAuthFlows(BaseModel):\n    implicit: Optional[OAuthFlowImplicit] = None\n    password: Optional[OAuthFlowPassword] = None\n    clientCredentials: Optional[OAuthFlowClientCredentials] = None\n    authorizationCode: Optional[OAuthFlowAuthorizationCode] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass OAuth2(SecurityBase):\n    type_ = Field(SecuritySchemeType.oauth2, alias=\"type\")\n    flows: OAuthFlows\n\n\nclass OpenIdConnect(SecurityBase):\n    type_ = Field(SecuritySchemeType.openIdConnect, alias=\"type\")\n    openIdConnectUrl: str\n\n\nSecurityScheme = Union[APIKey, HTTPBase, OAuth2, OpenIdConnect, HTTPBearer]\n\n\nclass Components(BaseModel):\n    schemas: Optional[Dict[str, Union[Schema, Reference]]] = None\n    responses: Optional[Dict[str, Union[Response, Reference]]] = None\n    parameters: Optional[Dict[str, Union[Parameter, Reference]]] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    requestBodies: Optional[Dict[str, Union[RequestBody, Reference]]] = None\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    securitySchemes: Optional[Dict[str, Union[SecurityScheme, Reference]]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n    # Using Any for Specification Extensions\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference, Any]]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Tag(BaseModel):\n    name: str\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass OpenAPI(BaseModel):\n    openapi: str\n    info: Info\n    servers: Optional[List[Server]] = None\n    # Using Any for Specification Extensions\n    paths: Dict[str, Union[PathItem, Any]]\n    components: Optional[Components] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    tags: Optional[List[Tag]] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nSchema.update_forward_refs()\nOperation.update_forward_refs()\nEncoding.update_forward_refs()\n", "fix_code": "from enum import Enum\nfrom typing import Any, Callable, Dict, Iterable, List, Optional, Union\n\nfrom fastapi.logger import logger\nfrom pydantic import AnyUrl, BaseModel, Field\n\ntry:\n    import email_validator  # type: ignore\n\n    assert email_validator  # make autoflake ignore the unused import\n    from pydantic import EmailStr\nexcept ImportError:  # pragma: no cover\n\n    class EmailStr(str):  # type: ignore\n        @classmethod\n        def __get_validators__(cls) -> Iterable[Callable[..., Any]]:\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, v: Any) -> str:\n            logger.warning(\n                \"email-validator not installed, email fields will be treated as str.\\n\"\n                \"To install, run: pip install email-validator\"\n            )\n            return str(v)\n\n\nclass Contact(BaseModel):\n    name: Optional[str] = None\n    url: Optional[AnyUrl] = None\n    email: Optional[EmailStr] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass License(BaseModel):\n    name: str\n    url: Optional[AnyUrl] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Info(BaseModel):\n    title: str\n    description: Optional[str] = None\n    termsOfService: Optional[str] = None\n    contact: Optional[Contact] = None\n    license: Optional[License] = None\n    version: str\n\n    class Config:\n        extra = \"allow\"\n\n\nclass ServerVariable(BaseModel):\n    enum: Optional[List[str]] = None\n    default: str\n    description: Optional[str] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Server(BaseModel):\n    url: Union[AnyUrl, str]\n    description: Optional[str] = None\n    variables: Optional[Dict[str, ServerVariable]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Reference(BaseModel):\n    ref: str = Field(alias=\"$ref\")\n\n\nclass Discriminator(BaseModel):\n    propertyName: str\n    mapping: Optional[Dict[str, str]] = None\n\n\nclass XML(BaseModel):\n    name: Optional[str] = None\n    namespace: Optional[str] = None\n    prefix: Optional[str] = None\n    attribute: Optional[bool] = None\n    wrapped: Optional[bool] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass ExternalDocumentation(BaseModel):\n    description: Optional[str] = None\n    url: AnyUrl\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Schema(BaseModel):\n    ref: Optional[str] = Field(default=None, alias=\"$ref\")\n    title: Optional[str] = None\n    multipleOf: Optional[float] = None\n    maximum: Optional[float] = None\n    exclusiveMaximum: Optional[float] = None\n    minimum: Optional[float] = None\n    exclusiveMinimum: Optional[float] = None\n    maxLength: Optional[int] = Field(default=None, ge=0)\n    minLength: Optional[int] = Field(default=None, ge=0)\n    pattern: Optional[str] = None\n    maxItems: Optional[int] = Field(default=None, ge=0)\n    minItems: Optional[int] = Field(default=None, ge=0)\n    uniqueItems: Optional[bool] = None\n    maxProperties: Optional[int] = Field(default=None, ge=0)\n    minProperties: Optional[int] = Field(default=None, ge=0)\n    required: Optional[List[str]] = None\n    enum: Optional[List[Any]] = None\n    type: Optional[str] = None\n    allOf: Optional[List[\"Schema\"]] = None\n    oneOf: Optional[List[\"Schema\"]] = None\n    anyOf: Optional[List[\"Schema\"]] = None\n    not_: Optional[\"Schema\"] = Field(default=None, alias=\"not\")\n    items: Optional[Union[\"Schema\", List[\"Schema\"]]] = None\n    properties: Optional[Dict[str, \"Schema\"]] = None\n    additionalProperties: Optional[Union[\"Schema\", Reference, bool]] = None\n    description: Optional[str] = None\n    format: Optional[str] = None\n    default: Optional[Any] = None\n    nullable: Optional[bool] = None\n    discriminator: Optional[Discriminator] = None\n    readOnly: Optional[bool] = None\n    writeOnly: Optional[bool] = None\n    xml: Optional[XML] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    example: Optional[Any] = None\n    deprecated: Optional[bool] = None\n\n    class Config:\n        extra: str = \"allow\"\n\n\nclass Example(BaseModel):\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    value: Optional[Any] = None\n    externalValue: Optional[AnyUrl] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass ParameterInType(Enum):\n    query = \"query\"\n    header = \"header\"\n    path = \"path\"\n    cookie = \"cookie\"\n\n\nclass Encoding(BaseModel):\n    contentType: Optional[str] = None\n    headers: Optional[Dict[str, Union[\"Header\", Reference]]] = None\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass MediaType(BaseModel):\n    schema_: Optional[Union[Schema, Reference]] = Field(default=None, alias=\"schema\")\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    encoding: Optional[Dict[str, Encoding]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass ParameterBase(BaseModel):\n    description: Optional[str] = None\n    required: Optional[bool] = None\n    deprecated: Optional[bool] = None\n    # Serialization rules for simple scenarios\n    style: Optional[str] = None\n    explode: Optional[bool] = None\n    allowReserved: Optional[bool] = None\n    schema_: Optional[Union[Schema, Reference]] = Field(default=None, alias=\"schema\")\n    example: Optional[Any] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    # Serialization rules for more complex scenarios\n    content: Optional[Dict[str, MediaType]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Parameter(ParameterBase):\n    name: str\n    in_: ParameterInType = Field(alias=\"in\")\n\n\nclass Header(ParameterBase):\n    pass\n\n\nclass RequestBody(BaseModel):\n    description: Optional[str] = None\n    content: Dict[str, MediaType]\n    required: Optional[bool] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Link(BaseModel):\n    operationRef: Optional[str] = None\n    operationId: Optional[str] = None\n    parameters: Optional[Dict[str, Union[Any, str]]] = None\n    requestBody: Optional[Union[Any, str]] = None\n    description: Optional[str] = None\n    server: Optional[Server] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Response(BaseModel):\n    description: str\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    content: Optional[Dict[str, MediaType]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Operation(BaseModel):\n    tags: Optional[List[str]] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n    operationId: Optional[str] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n    requestBody: Optional[Union[RequestBody, Reference]] = None\n    # Using Any for Specification Extensions\n    responses: Dict[str, Union[Response, Any]]\n    callbacks: Optional[Dict[str, Union[Dict[str, \"PathItem\"], Reference]]] = None\n    deprecated: Optional[bool] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    servers: Optional[List[Server]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass PathItem(BaseModel):\n    ref: Optional[str] = Field(default=None, alias=\"$ref\")\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    get: Optional[Operation] = None\n    put: Optional[Operation] = None\n    post: Optional[Operation] = None\n    delete: Optional[Operation] = None\n    options: Optional[Operation] = None\n    head: Optional[Operation] = None\n    patch: Optional[Operation] = None\n    trace: Optional[Operation] = None\n    servers: Optional[List[Server]] = None\n    parameters: Optional[List[Union[Parameter, Reference]]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass SecuritySchemeType(Enum):\n    apiKey = \"apiKey\"\n    http = \"http\"\n    oauth2 = \"oauth2\"\n    openIdConnect = \"openIdConnect\"\n\n\nclass SecurityBase(BaseModel):\n    type_: SecuritySchemeType = Field(alias=\"type\")\n    description: Optional[str] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass APIKeyIn(Enum):\n    query = \"query\"\n    header = \"header\"\n    cookie = \"cookie\"\n\n\nclass APIKey(SecurityBase):\n    type_ = Field(SecuritySchemeType.apiKey, alias=\"type\")\n    in_: APIKeyIn = Field(alias=\"in\")\n    name: str\n\n\nclass HTTPBase(SecurityBase):\n    type_ = Field(SecuritySchemeType.http, alias=\"type\")\n    scheme: str\n\n\nclass HTTPBearer(HTTPBase):\n    scheme = \"bearer\"\n    bearerFormat: Optional[str] = None\n\n\nclass OAuthFlow(BaseModel):\n    refreshUrl: Optional[str] = None\n    scopes: Dict[str, str] = {}\n\n    class Config:\n        extra = \"allow\"\n\n\nclass OAuthFlowImplicit(OAuthFlow):\n    authorizationUrl: str\n\n\nclass OAuthFlowPassword(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowClientCredentials(OAuthFlow):\n    tokenUrl: str\n\n\nclass OAuthFlowAuthorizationCode(OAuthFlow):\n    authorizationUrl: str\n    tokenUrl: str\n\n\nclass OAuthFlows(BaseModel):\n    implicit: Optional[OAuthFlowImplicit] = None\n    password: Optional[OAuthFlowPassword] = None\n    clientCredentials: Optional[OAuthFlowClientCredentials] = None\n    authorizationCode: Optional[OAuthFlowAuthorizationCode] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass OAuth2(SecurityBase):\n    type_ = Field(SecuritySchemeType.oauth2, alias=\"type\")\n    flows: OAuthFlows\n\n\nclass OpenIdConnect(SecurityBase):\n    type_ = Field(SecuritySchemeType.openIdConnect, alias=\"type\")\n    openIdConnectUrl: str\n\n\nSecurityScheme = Union[APIKey, HTTPBase, OAuth2, OpenIdConnect, HTTPBearer]\n\n\nclass Components(BaseModel):\n    schemas: Optional[Dict[str, Union[Schema, Reference]]] = None\n    responses: Optional[Dict[str, Union[Response, Reference]]] = None\n    parameters: Optional[Dict[str, Union[Parameter, Reference]]] = None\n    examples: Optional[Dict[str, Union[Example, Reference]]] = None\n    requestBodies: Optional[Dict[str, Union[RequestBody, Reference]]] = None\n    headers: Optional[Dict[str, Union[Header, Reference]]] = None\n    securitySchemes: Optional[Dict[str, Union[SecurityScheme, Reference]]] = None\n    links: Optional[Dict[str, Union[Link, Reference]]] = None\n    # Using Any for Specification Extensions\n    callbacks: Optional[Dict[str, Union[Dict[str, PathItem], Reference, Any]]] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass Tag(BaseModel):\n    name: str\n    description: Optional[str] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nclass OpenAPI(BaseModel):\n    openapi: str\n    info: Info\n    servers: Optional[List[Server]] = None\n    # Using Any for Specification Extensions\n    paths: Dict[str, Union[PathItem, Any]]\n    components: Optional[Components] = None\n    security: Optional[List[Dict[str, List[str]]]] = None\n    tags: Optional[List[Tag]] = None\n    externalDocs: Optional[ExternalDocumentation] = None\n\n    class Config:\n        extra = \"allow\"\n\n\nSchema.update_forward_refs()\nOperation.update_forward_refs()\nEncoding.update_forward_refs()\n", "diff": "@@ -108,14 +108,14 @@ class Schema(BaseModel):\n     exclusiveMaximum: Optional[float] = None\n     minimum: Optional[float] = None\n     exclusiveMinimum: Optional[float] = None\n-    maxLength: Optional[int] = Field(default=None, gte=0)\n-    minLength: Optional[int] = Field(default=None, gte=0)\n+    maxLength: Optional[int] = Field(default=None, ge=0)\n+    minLength: Optional[int] = Field(default=None, ge=0)\n     pattern: Optional[str] = None\n-    maxItems: Optional[int] = Field(default=None, gte=0)\n-    minItems: Optional[int] = Field(default=None, gte=0)\n+    maxItems: Optional[int] = Field(default=None, ge=0)\n+    minItems: Optional[int] = Field(default=None, ge=0)\n     uniqueItems: Optional[bool] = None\n-    maxProperties: Optional[int] = Field(default=None, gte=0)\n-    minProperties: Optional[int] = Field(default=None, gte=0)\n+    maxProperties: Optional[int] = Field(default=None, ge=0)\n+    minProperties: Optional[int] = Field(default=None, ge=0)\n     required: Optional[List[str]] = None\n     enum: Optional[List[Any]] = None\n     type: Optional[str] = None\n"}
{"commit_hash": "6dd8e567cc2de5993bdb69f57d1cbc2554e6b09e", "issue_description": "\ud83d\udc1b Fix `HTTPException` header type annotations (#9648)", "code_before": "from typing import Any, Dict, Optional, Sequence, Type\n\nfrom pydantic import BaseModel, ValidationError, create_model\nfrom pydantic.error_wrappers import ErrorList\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom starlette.exceptions import WebSocketException as WebSocketException  # noqa: F401\n\n\nclass HTTPException(StarletteHTTPException):\n    def __init__(\n        self,\n        status_code: int,\n        detail: Any = None,\n        headers: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        super().__init__(status_code=status_code, detail=detail, headers=headers)\n\n\nRequestErrorModel: Type[BaseModel] = create_model(\"Request\")\nWebSocketErrorModel: Type[BaseModel] = create_model(\"WebSocket\")\n\n\nclass FastAPIError(RuntimeError):\n    \"\"\"\n    A generic, FastAPI-specific error.\n    \"\"\"\n\n\nclass RequestValidationError(ValidationError):\n    def __init__(self, errors: Sequence[ErrorList], *, body: Any = None) -> None:\n        self.body = body\n        super().__init__(errors, RequestErrorModel)\n\n\nclass WebSocketRequestValidationError(ValidationError):\n    def __init__(self, errors: Sequence[ErrorList]) -> None:\n        super().__init__(errors, WebSocketErrorModel)\n", "fix_code": "from typing import Any, Dict, Optional, Sequence, Type\n\nfrom pydantic import BaseModel, ValidationError, create_model\nfrom pydantic.error_wrappers import ErrorList\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\nfrom starlette.exceptions import WebSocketException as WebSocketException  # noqa: F401\n\n\nclass HTTPException(StarletteHTTPException):\n    def __init__(\n        self,\n        status_code: int,\n        detail: Any = None,\n        headers: Optional[Dict[str, str]] = None,\n    ) -> None:\n        super().__init__(status_code=status_code, detail=detail, headers=headers)\n\n\nRequestErrorModel: Type[BaseModel] = create_model(\"Request\")\nWebSocketErrorModel: Type[BaseModel] = create_model(\"WebSocket\")\n\n\nclass FastAPIError(RuntimeError):\n    \"\"\"\n    A generic, FastAPI-specific error.\n    \"\"\"\n\n\nclass RequestValidationError(ValidationError):\n    def __init__(self, errors: Sequence[ErrorList], *, body: Any = None) -> None:\n        self.body = body\n        super().__init__(errors, RequestErrorModel)\n\n\nclass WebSocketRequestValidationError(ValidationError):\n    def __init__(self, errors: Sequence[ErrorList]) -> None:\n        super().__init__(errors, WebSocketErrorModel)\n", "diff": "@@ -11,7 +11,7 @@ class HTTPException(StarletteHTTPException):\n         self,\n         status_code: int,\n         detail: Any = None,\n-        headers: Optional[Dict[str, Any]] = None,\n+        headers: Optional[Dict[str, str]] = None,\n     ) -> None:\n         super().__init__(status_code=status_code, detail=detail, headers=headers)\n \n"}
